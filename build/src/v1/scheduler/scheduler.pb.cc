// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/v1/scheduler/scheduler.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mesos/v1/scheduler/scheduler.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mesos {
namespace v1 {
namespace scheduler {

namespace {

const ::google::protobuf::Descriptor* Event_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Subscribed_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Subscribed_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Offers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Offers_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Rescind_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Rescind_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Update_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Update_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Message_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Failure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Failure_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Error_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Error_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Event_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Call_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Subscribe_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Subscribe_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Accept_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Accept_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Decline_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Decline_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Kill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Kill_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Shutdown_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Shutdown_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Acknowledge_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Acknowledge_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Reconcile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Reconcile_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Reconcile_Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Reconcile_Task_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Message_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Request_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Call_Type_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto() {
  protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "mesos/v1/scheduler/scheduler.proto");
  GOOGLE_CHECK(file != NULL);
  Event_descriptor_ = file->message_type(0);
  static const int Event_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, subscribed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, rescind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, update_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, failure_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, error_),
  };
  Event_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_descriptor_,
      Event::default_instance_,
      Event_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event));
  Event_Subscribed_descriptor_ = Event_descriptor_->nested_type(0);
  static const int Event_Subscribed_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, heartbeat_interval_seconds_),
  };
  Event_Subscribed_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Subscribed_descriptor_,
      Event_Subscribed::default_instance_,
      Event_Subscribed_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Subscribed));
  Event_Offers_descriptor_ = Event_descriptor_->nested_type(1);
  static const int Event_Offers_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Offers, offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Offers, inverse_offers_),
  };
  Event_Offers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Offers_descriptor_,
      Event_Offers::default_instance_,
      Event_Offers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Offers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Offers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Offers));
  Event_Rescind_descriptor_ = Event_descriptor_->nested_type(2);
  static const int Event_Rescind_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Rescind, offer_id_),
  };
  Event_Rescind_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Rescind_descriptor_,
      Event_Rescind::default_instance_,
      Event_Rescind_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Rescind, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Rescind, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Rescind));
  Event_Update_descriptor_ = Event_descriptor_->nested_type(3);
  static const int Event_Update_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Update, status_),
  };
  Event_Update_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Update_descriptor_,
      Event_Update::default_instance_,
      Event_Update_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Update, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Update, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Update));
  Event_Message_descriptor_ = Event_descriptor_->nested_type(4);
  static const int Event_Message_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, agent_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, data_),
  };
  Event_Message_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Message_descriptor_,
      Event_Message::default_instance_,
      Event_Message_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Message));
  Event_Failure_descriptor_ = Event_descriptor_->nested_type(5);
  static const int Event_Failure_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, agent_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, status_),
  };
  Event_Failure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Failure_descriptor_,
      Event_Failure::default_instance_,
      Event_Failure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Failure));
  Event_Error_descriptor_ = Event_descriptor_->nested_type(6);
  static const int Event_Error_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Error, message_),
  };
  Event_Error_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Error_descriptor_,
      Event_Error::default_instance_,
      Event_Error_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Error, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Error, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Error));
  Event_Type_descriptor_ = Event_descriptor_->enum_type(0);
  Call_descriptor_ = file->message_type(1);
  static const int Call_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, subscribe_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, accept_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, decline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, kill_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, shutdown_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, acknowledge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, reconcile_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, request_),
  };
  Call_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_descriptor_,
      Call::default_instance_,
      Call_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call));
  Call_Subscribe_descriptor_ = Call_descriptor_->nested_type(0);
  static const int Call_Subscribe_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Subscribe, framework_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Subscribe, force_),
  };
  Call_Subscribe_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Subscribe_descriptor_,
      Call_Subscribe::default_instance_,
      Call_Subscribe_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Subscribe, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Subscribe, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Subscribe));
  Call_Accept_descriptor_ = Call_descriptor_->nested_type(1);
  static const int Call_Accept_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, offer_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, operations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, filters_),
  };
  Call_Accept_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Accept_descriptor_,
      Call_Accept::default_instance_,
      Call_Accept_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Accept));
  Call_Decline_descriptor_ = Call_descriptor_->nested_type(2);
  static const int Call_Decline_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Decline, offer_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Decline, filters_),
  };
  Call_Decline_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Decline_descriptor_,
      Call_Decline::default_instance_,
      Call_Decline_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Decline, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Decline, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Decline));
  Call_Kill_descriptor_ = Call_descriptor_->nested_type(3);
  static const int Call_Kill_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, agent_id_),
  };
  Call_Kill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Kill_descriptor_,
      Call_Kill::default_instance_,
      Call_Kill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Kill));
  Call_Shutdown_descriptor_ = Call_descriptor_->nested_type(4);
  static const int Call_Shutdown_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Shutdown, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Shutdown, agent_id_),
  };
  Call_Shutdown_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Shutdown_descriptor_,
      Call_Shutdown::default_instance_,
      Call_Shutdown_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Shutdown, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Shutdown, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Shutdown));
  Call_Acknowledge_descriptor_ = Call_descriptor_->nested_type(5);
  static const int Call_Acknowledge_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, agent_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, uuid_),
  };
  Call_Acknowledge_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Acknowledge_descriptor_,
      Call_Acknowledge::default_instance_,
      Call_Acknowledge_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Acknowledge));
  Call_Reconcile_descriptor_ = Call_descriptor_->nested_type(6);
  static const int Call_Reconcile_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile, tasks_),
  };
  Call_Reconcile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Reconcile_descriptor_,
      Call_Reconcile::default_instance_,
      Call_Reconcile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Reconcile));
  Call_Reconcile_Task_descriptor_ = Call_Reconcile_descriptor_->nested_type(0);
  static const int Call_Reconcile_Task_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile_Task, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile_Task, agent_id_),
  };
  Call_Reconcile_Task_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Reconcile_Task_descriptor_,
      Call_Reconcile_Task::default_instance_,
      Call_Reconcile_Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile_Task, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile_Task, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Reconcile_Task));
  Call_Message_descriptor_ = Call_descriptor_->nested_type(7);
  static const int Call_Message_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, agent_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, data_),
  };
  Call_Message_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Message_descriptor_,
      Call_Message::default_instance_,
      Call_Message_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Message));
  Call_Request_descriptor_ = Call_descriptor_->nested_type(8);
  static const int Call_Request_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Request, requests_),
  };
  Call_Request_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Request_descriptor_,
      Call_Request::default_instance_,
      Call_Request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Request, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Request, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Request));
  Call_Type_descriptor_ = Call_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_descriptor_, &Event::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Subscribed_descriptor_, &Event_Subscribed::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Offers_descriptor_, &Event_Offers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Rescind_descriptor_, &Event_Rescind::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Update_descriptor_, &Event_Update::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Message_descriptor_, &Event_Message::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Failure_descriptor_, &Event_Failure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Error_descriptor_, &Event_Error::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_descriptor_, &Call::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Subscribe_descriptor_, &Call_Subscribe::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Accept_descriptor_, &Call_Accept::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Decline_descriptor_, &Call_Decline::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Kill_descriptor_, &Call_Kill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Shutdown_descriptor_, &Call_Shutdown::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Acknowledge_descriptor_, &Call_Acknowledge::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Reconcile_descriptor_, &Call_Reconcile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Reconcile_Task_descriptor_, &Call_Reconcile_Task::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Message_descriptor_, &Call_Message::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Request_descriptor_, &Call_Request::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_mesos_2fv1_2fscheduler_2fscheduler_2eproto() {
  delete Event::default_instance_;
  delete Event_reflection_;
  delete Event_Subscribed::default_instance_;
  delete Event_Subscribed_reflection_;
  delete Event_Offers::default_instance_;
  delete Event_Offers_reflection_;
  delete Event_Rescind::default_instance_;
  delete Event_Rescind_reflection_;
  delete Event_Update::default_instance_;
  delete Event_Update_reflection_;
  delete Event_Message::default_instance_;
  delete Event_Message_reflection_;
  delete Event_Failure::default_instance_;
  delete Event_Failure_reflection_;
  delete Event_Error::default_instance_;
  delete Event_Error_reflection_;
  delete Call::default_instance_;
  delete Call_reflection_;
  delete Call_Subscribe::default_instance_;
  delete Call_Subscribe_reflection_;
  delete Call_Accept::default_instance_;
  delete Call_Accept_reflection_;
  delete Call_Decline::default_instance_;
  delete Call_Decline_reflection_;
  delete Call_Kill::default_instance_;
  delete Call_Kill_reflection_;
  delete Call_Shutdown::default_instance_;
  delete Call_Shutdown_reflection_;
  delete Call_Acknowledge::default_instance_;
  delete Call_Acknowledge_reflection_;
  delete Call_Reconcile::default_instance_;
  delete Call_Reconcile_reflection_;
  delete Call_Reconcile_Task::default_instance_;
  delete Call_Reconcile_Task_reflection_;
  delete Call_Message::default_instance_;
  delete Call_Message_reflection_;
  delete Call_Request::default_instance_;
  delete Call_Request_reflection_;
}

void protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mesos::v1::protobuf_AddDesc_mesos_2fv1_2fmesos_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\"mesos/v1/scheduler/scheduler.proto\022\022me"
    "sos.v1.scheduler\032\024mesos/v1/mesos.proto\"\230"
    "\010\n\005Event\022,\n\004type\030\001 \002(\0162\036.mesos.v1.schedu"
    "ler.Event.Type\0228\n\nsubscribed\030\002 \001(\0132$.mes"
    "os.v1.scheduler.Event.Subscribed\0220\n\006offe"
    "rs\030\003 \001(\0132 .mesos.v1.scheduler.Event.Offe"
    "rs\0222\n\007rescind\030\004 \001(\0132!.mesos.v1.scheduler"
    ".Event.Rescind\0220\n\006update\030\005 \001(\0132 .mesos.v"
    "1.scheduler.Event.Update\0222\n\007message\030\006 \001("
    "\0132!.mesos.v1.scheduler.Event.Message\0222\n\007"
    "failure\030\007 \001(\0132!.mesos.v1.scheduler.Event"
    ".Failure\022.\n\005error\030\010 \001(\0132\037.mesos.v1.sched"
    "uler.Event.Error\032]\n\nSubscribed\022+\n\014framew"
    "ork_id\030\001 \002(\0132\025.mesos.v1.FrameworkID\022\"\n\032h"
    "eartbeat_interval_seconds\030\002 \001(\001\032Y\n\006Offer"
    "s\022\037\n\006offers\030\001 \003(\0132\017.mesos.v1.Offer\022.\n\016in"
    "verse_offers\030\002 \003(\0132\026.mesos.v1.InverseOff"
    "er\032.\n\007Rescind\022#\n\010offer_id\030\001 \002(\0132\021.mesos."
    "v1.OfferID\032.\n\006Update\022$\n\006status\030\001 \002(\0132\024.m"
    "esos.v1.TaskStatus\032g\n\007Message\022#\n\010agent_i"
    "d\030\001 \002(\0132\021.mesos.v1.AgentID\022)\n\013executor_i"
    "d\030\002 \002(\0132\024.mesos.v1.ExecutorID\022\014\n\004data\030\003 "
    "\002(\014\032i\n\007Failure\022#\n\010agent_id\030\001 \001(\0132\021.mesos"
    ".v1.AgentID\022)\n\013executor_id\030\002 \001(\0132\024.mesos"
    ".v1.ExecutorID\022\016\n\006status\030\003 \001(\005\032\030\n\005Error\022"
    "\017\n\007message\030\001 \002(\t\"o\n\004Type\022\016\n\nSUBSCRIBED\020\001"
    "\022\n\n\006OFFERS\020\002\022\013\n\007RESCIND\020\003\022\n\n\006UPDATE\020\004\022\013\n"
    "\007MESSAGE\020\005\022\013\n\007FAILURE\020\006\022\t\n\005ERROR\020\007\022\r\n\tHE"
    "ARTBEAT\020\010\"\306\014\n\004Call\022+\n\014framework_id\030\001 \001(\013"
    "2\025.mesos.v1.FrameworkID\022+\n\004type\030\002 \002(\0162\035."
    "mesos.v1.scheduler.Call.Type\0225\n\tsubscrib"
    "e\030\003 \001(\0132\".mesos.v1.scheduler.Call.Subscr"
    "ibe\022/\n\006accept\030\004 \001(\0132\037.mesos.v1.scheduler"
    ".Call.Accept\0221\n\007decline\030\005 \001(\0132 .mesos.v1"
    ".scheduler.Call.Decline\022+\n\004kill\030\006 \001(\0132\035."
    "mesos.v1.scheduler.Call.Kill\0223\n\010shutdown"
    "\030\007 \001(\0132!.mesos.v1.scheduler.Call.Shutdow"
    "n\0229\n\013acknowledge\030\010 \001(\0132$.mesos.v1.schedu"
    "ler.Call.Acknowledge\0225\n\treconcile\030\t \001(\0132"
    "\".mesos.v1.scheduler.Call.Reconcile\0221\n\007m"
    "essage\030\n \001(\0132 .mesos.v1.scheduler.Call.M"
    "essage\0221\n\007request\030\013 \001(\0132 .mesos.v1.sched"
    "uler.Call.Request\032K\n\tSubscribe\022/\n\016framew"
    "ork_info\030\001 \002(\0132\027.mesos.v1.FrameworkInfo\022"
    "\r\n\005force\030\002 \001(\010\032\201\001\n\006Accept\022$\n\toffer_ids\030\001"
    " \003(\0132\021.mesos.v1.OfferID\022-\n\noperations\030\002 "
    "\003(\0132\031.mesos.v1.Offer.Operation\022\"\n\007filter"
    "s\030\003 \001(\0132\021.mesos.v1.Filters\032S\n\007Decline\022$\n"
    "\toffer_ids\030\001 \003(\0132\021.mesos.v1.OfferID\022\"\n\007f"
    "ilters\030\002 \001(\0132\021.mesos.v1.Filters\032N\n\004Kill\022"
    "!\n\007task_id\030\001 \002(\0132\020.mesos.v1.TaskID\022#\n\010ag"
    "ent_id\030\002 \001(\0132\021.mesos.v1.AgentID\032Z\n\010Shutd"
    "own\022)\n\013executor_id\030\001 \002(\0132\024.mesos.v1.Exec"
    "utorID\022#\n\010agent_id\030\002 \002(\0132\021.mesos.v1.Agen"
    "tID\032c\n\013Acknowledge\022#\n\010agent_id\030\001 \002(\0132\021.m"
    "esos.v1.AgentID\022!\n\007task_id\030\002 \002(\0132\020.mesos"
    ".v1.TaskID\022\014\n\004uuid\030\003 \002(\014\032\223\001\n\tReconcile\0226"
    "\n\005tasks\030\001 \003(\0132\'.mesos.v1.scheduler.Call."
    "Reconcile.Task\032N\n\004Task\022!\n\007task_id\030\001 \002(\0132"
    "\020.mesos.v1.TaskID\022#\n\010agent_id\030\002 \001(\0132\021.me"
    "sos.v1.AgentID\032g\n\007Message\022#\n\010agent_id\030\001 "
    "\002(\0132\021.mesos.v1.AgentID\022)\n\013executor_id\030\002 "
    "\002(\0132\024.mesos.v1.ExecutorID\022\014\n\004data\030\003 \002(\014\032"
    ".\n\007Request\022#\n\010requests\030\001 \003(\0132\021.mesos.v1."
    "Request\"\250\001\n\004Type\022\r\n\tSUBSCRIBE\020\001\022\014\n\010TEARD"
    "OWN\020\002\022\n\n\006ACCEPT\020\003\022\013\n\007DECLINE\020\004\022\n\n\006REVIVE"
    "\020\005\022\010\n\004KILL\020\006\022\014\n\010SHUTDOWN\020\007\022\017\n\013ACKNOWLEDG"
    "E\020\010\022\r\n\tRECONCILE\020\t\022\013\n\007MESSAGE\020\n\022\013\n\007REQUE"
    "ST\020\013\022\014\n\010SUPPRESS\020\014B\'\n\035org.apache.mesos.v"
    "1.schedulerB\006Protos", 2779);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "mesos/v1/scheduler/scheduler.proto", &protobuf_RegisterTypes);
  Event::default_instance_ = new Event();
  Event_Subscribed::default_instance_ = new Event_Subscribed();
  Event_Offers::default_instance_ = new Event_Offers();
  Event_Rescind::default_instance_ = new Event_Rescind();
  Event_Update::default_instance_ = new Event_Update();
  Event_Message::default_instance_ = new Event_Message();
  Event_Failure::default_instance_ = new Event_Failure();
  Event_Error::default_instance_ = new Event_Error();
  Call::default_instance_ = new Call();
  Call_Subscribe::default_instance_ = new Call_Subscribe();
  Call_Accept::default_instance_ = new Call_Accept();
  Call_Decline::default_instance_ = new Call_Decline();
  Call_Kill::default_instance_ = new Call_Kill();
  Call_Shutdown::default_instance_ = new Call_Shutdown();
  Call_Acknowledge::default_instance_ = new Call_Acknowledge();
  Call_Reconcile::default_instance_ = new Call_Reconcile();
  Call_Reconcile_Task::default_instance_ = new Call_Reconcile_Task();
  Call_Message::default_instance_ = new Call_Message();
  Call_Request::default_instance_ = new Call_Request();
  Event::default_instance_->InitAsDefaultInstance();
  Event_Subscribed::default_instance_->InitAsDefaultInstance();
  Event_Offers::default_instance_->InitAsDefaultInstance();
  Event_Rescind::default_instance_->InitAsDefaultInstance();
  Event_Update::default_instance_->InitAsDefaultInstance();
  Event_Message::default_instance_->InitAsDefaultInstance();
  Event_Failure::default_instance_->InitAsDefaultInstance();
  Event_Error::default_instance_->InitAsDefaultInstance();
  Call::default_instance_->InitAsDefaultInstance();
  Call_Subscribe::default_instance_->InitAsDefaultInstance();
  Call_Accept::default_instance_->InitAsDefaultInstance();
  Call_Decline::default_instance_->InitAsDefaultInstance();
  Call_Kill::default_instance_->InitAsDefaultInstance();
  Call_Shutdown::default_instance_->InitAsDefaultInstance();
  Call_Acknowledge::default_instance_->InitAsDefaultInstance();
  Call_Reconcile::default_instance_->InitAsDefaultInstance();
  Call_Reconcile_Task::default_instance_->InitAsDefaultInstance();
  Call_Message::default_instance_->InitAsDefaultInstance();
  Call_Request::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mesos_2fv1_2fscheduler_2fscheduler_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mesos_2fv1_2fscheduler_2fscheduler_2eproto {
  StaticDescriptorInitializer_mesos_2fv1_2fscheduler_2fscheduler_2eproto() {
    protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  }
} static_descriptor_initializer_mesos_2fv1_2fscheduler_2fscheduler_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Event_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Type_descriptor_;
}
bool Event_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Event_Type Event::SUBSCRIBED;
const Event_Type Event::OFFERS;
const Event_Type Event::RESCIND;
const Event_Type Event::UPDATE;
const Event_Type Event::MESSAGE;
const Event_Type Event::FAILURE;
const Event_Type Event::ERROR;
const Event_Type Event::HEARTBEAT;
const Event_Type Event::Type_MIN;
const Event_Type Event::Type_MAX;
const int Event::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Event_Subscribed::kFrameworkIdFieldNumber;
const int Event_Subscribed::kHeartbeatIntervalSecondsFieldNumber;
#endif  // !_MSC_VER

Event_Subscribed::Event_Subscribed()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event_Subscribed::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::v1::FrameworkID*>(&::mesos::v1::FrameworkID::default_instance());
}

Event_Subscribed::Event_Subscribed(const Event_Subscribed& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event_Subscribed::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  heartbeat_interval_seconds_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Subscribed::~Event_Subscribed() {
  SharedDtor();
}

void Event_Subscribed::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void Event_Subscribed::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Subscribed::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Subscribed_descriptor_;
}

const Event_Subscribed& Event_Subscribed::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Event_Subscribed* Event_Subscribed::default_instance_ = NULL;

Event_Subscribed* Event_Subscribed::New() const {
  return new Event_Subscribed;
}

void Event_Subscribed::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::v1::FrameworkID::Clear();
    }
    heartbeat_interval_seconds_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Subscribed::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_heartbeat_interval_seconds;
        break;
      }

      // optional double heartbeat_interval_seconds = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_heartbeat_interval_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heartbeat_interval_seconds_)));
          set_has_heartbeat_interval_seconds();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event_Subscribed::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // optional double heartbeat_interval_seconds = 2;
  if (has_heartbeat_interval_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->heartbeat_interval_seconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event_Subscribed::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // optional double heartbeat_interval_seconds = 2;
  if (has_heartbeat_interval_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->heartbeat_interval_seconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event_Subscribed::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional double heartbeat_interval_seconds = 2;
    if (has_heartbeat_interval_seconds()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Subscribed::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Subscribed* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Subscribed*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Subscribed::MergeFrom(const Event_Subscribed& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::v1::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_heartbeat_interval_seconds()) {
      set_heartbeat_interval_seconds(from.heartbeat_interval_seconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Subscribed::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Subscribed::CopyFrom(const Event_Subscribed& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Subscribed::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void Event_Subscribed::Swap(Event_Subscribed* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(heartbeat_interval_seconds_, other->heartbeat_interval_seconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Subscribed::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Subscribed_descriptor_;
  metadata.reflection = Event_Subscribed_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Offers::kOffersFieldNumber;
const int Event_Offers::kInverseOffersFieldNumber;
#endif  // !_MSC_VER

Event_Offers::Event_Offers()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event_Offers::InitAsDefaultInstance() {
}

Event_Offers::Event_Offers(const Event_Offers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event_Offers::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Offers::~Event_Offers() {
  SharedDtor();
}

void Event_Offers::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Event_Offers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Offers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Offers_descriptor_;
}

const Event_Offers& Event_Offers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Event_Offers* Event_Offers::default_instance_ = NULL;

Event_Offers* Event_Offers::New() const {
  return new Event_Offers;
}

void Event_Offers::Clear() {
  offers_.Clear();
  inverse_offers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Offers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.v1.Offer offers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_offers;
        if (input->ExpectTag(18)) goto parse_inverse_offers;
        break;
      }

      // repeated .mesos.v1.InverseOffer inverse_offers = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inverse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inverse_offers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_inverse_offers;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event_Offers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.v1.Offer offers = 1;
  for (int i = 0; i < this->offers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offers(i), output);
  }

  // repeated .mesos.v1.InverseOffer inverse_offers = 2;
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->inverse_offers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event_Offers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.v1.Offer offers = 1;
  for (int i = 0; i < this->offers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offers(i), target);
  }

  // repeated .mesos.v1.InverseOffer inverse_offers = 2;
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->inverse_offers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event_Offers::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.v1.Offer offers = 1;
  total_size += 1 * this->offers_size();
  for (int i = 0; i < this->offers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offers(i));
  }

  // repeated .mesos.v1.InverseOffer inverse_offers = 2;
  total_size += 1 * this->inverse_offers_size();
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inverse_offers(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Offers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Offers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Offers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Offers::MergeFrom(const Event_Offers& from) {
  GOOGLE_CHECK_NE(&from, this);
  offers_.MergeFrom(from.offers_);
  inverse_offers_.MergeFrom(from.inverse_offers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Offers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Offers::CopyFrom(const Event_Offers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Offers::IsInitialized() const {

  for (int i = 0; i < offers_size(); i++) {
    if (!this->offers(i).IsInitialized()) return false;
  }
  for (int i = 0; i < inverse_offers_size(); i++) {
    if (!this->inverse_offers(i).IsInitialized()) return false;
  }
  return true;
}

void Event_Offers::Swap(Event_Offers* other) {
  if (other != this) {
    offers_.Swap(&other->offers_);
    inverse_offers_.Swap(&other->inverse_offers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Offers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Offers_descriptor_;
  metadata.reflection = Event_Offers_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Rescind::kOfferIdFieldNumber;
#endif  // !_MSC_VER

Event_Rescind::Event_Rescind()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event_Rescind::InitAsDefaultInstance() {
  offer_id_ = const_cast< ::mesos::v1::OfferID*>(&::mesos::v1::OfferID::default_instance());
}

Event_Rescind::Event_Rescind(const Event_Rescind& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event_Rescind::SharedCtor() {
  _cached_size_ = 0;
  offer_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Rescind::~Event_Rescind() {
  SharedDtor();
}

void Event_Rescind::SharedDtor() {
  if (this != default_instance_) {
    delete offer_id_;
  }
}

void Event_Rescind::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Rescind::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Rescind_descriptor_;
}

const Event_Rescind& Event_Rescind::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Event_Rescind* Event_Rescind::default_instance_ = NULL;

Event_Rescind* Event_Rescind::New() const {
  return new Event_Rescind;
}

void Event_Rescind::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_offer_id()) {
      if (offer_id_ != NULL) offer_id_->::mesos::v1::OfferID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Rescind::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.OfferID offer_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event_Rescind::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.OfferID offer_id = 1;
  if (has_offer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offer_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event_Rescind::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.OfferID offer_id = 1;
  if (has_offer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offer_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event_Rescind::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.OfferID offer_id = 1;
    if (has_offer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->offer_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Rescind::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Rescind* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Rescind*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Rescind::MergeFrom(const Event_Rescind& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offer_id()) {
      mutable_offer_id()->::mesos::v1::OfferID::MergeFrom(from.offer_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Rescind::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Rescind::CopyFrom(const Event_Rescind& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Rescind::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_offer_id()) {
    if (!this->offer_id().IsInitialized()) return false;
  }
  return true;
}

void Event_Rescind::Swap(Event_Rescind* other) {
  if (other != this) {
    std::swap(offer_id_, other->offer_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Rescind::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Rescind_descriptor_;
  metadata.reflection = Event_Rescind_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Update::kStatusFieldNumber;
#endif  // !_MSC_VER

Event_Update::Event_Update()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event_Update::InitAsDefaultInstance() {
  status_ = const_cast< ::mesos::v1::TaskStatus*>(&::mesos::v1::TaskStatus::default_instance());
}

Event_Update::Event_Update(const Event_Update& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event_Update::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Update::~Event_Update() {
  SharedDtor();
}

void Event_Update::SharedDtor() {
  if (this != default_instance_) {
    delete status_;
  }
}

void Event_Update::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Update::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Update_descriptor_;
}

const Event_Update& Event_Update::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Event_Update* Event_Update::default_instance_ = NULL;

Event_Update* Event_Update::New() const {
  return new Event_Update;
}

void Event_Update::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != NULL) status_->::mesos::v1::TaskStatus::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Update::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.TaskStatus status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event_Update::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.TaskStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event_Update::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.TaskStatus status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event_Update::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.TaskStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Update::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Update* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Update*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Update::MergeFrom(const Event_Update& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::mesos::v1::TaskStatus::MergeFrom(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Update::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Update::CopyFrom(const Event_Update& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void Event_Update::Swap(Event_Update* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Update::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Update_descriptor_;
  metadata.reflection = Event_Update_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Message::kAgentIdFieldNumber;
const int Event_Message::kExecutorIdFieldNumber;
const int Event_Message::kDataFieldNumber;
#endif  // !_MSC_VER

Event_Message::Event_Message()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event_Message::InitAsDefaultInstance() {
  agent_id_ = const_cast< ::mesos::v1::AgentID*>(&::mesos::v1::AgentID::default_instance());
  executor_id_ = const_cast< ::mesos::v1::ExecutorID*>(&::mesos::v1::ExecutorID::default_instance());
}

Event_Message::Event_Message(const Event_Message& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event_Message::SharedCtor() {
  _cached_size_ = 0;
  agent_id_ = NULL;
  executor_id_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Message::~Event_Message() {
  SharedDtor();
}

void Event_Message::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
    delete agent_id_;
    delete executor_id_;
  }
}

void Event_Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Message_descriptor_;
}

const Event_Message& Event_Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Event_Message* Event_Message::default_instance_ = NULL;

Event_Message* Event_Message::New() const {
  return new Event_Message;
}

void Event_Message::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agent_id()) {
      if (agent_id_ != NULL) agent_id_->::mesos::v1::AgentID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::v1::ExecutorID::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.AgentID agent_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agent_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // required .mesos.v1.ExecutorID executor_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event_Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.AgentID agent_id = 1;
  if (has_agent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->agent_id(), output);
  }

  // required .mesos.v1.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event_Message::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.AgentID agent_id = 1;
  if (has_agent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->agent_id(), target);
  }

  // required .mesos.v1.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  // required bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event_Message::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.AgentID agent_id = 1;
    if (has_agent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agent_id());
    }

    // required .mesos.v1.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Message::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Message* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Message*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Message::MergeFrom(const Event_Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agent_id()) {
      mutable_agent_id()->::mesos::v1::AgentID::MergeFrom(from.agent_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::v1::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Message::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Message::CopyFrom(const Event_Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Message::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_agent_id()) {
    if (!this->agent_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void Event_Message::Swap(Event_Message* other) {
  if (other != this) {
    std::swap(agent_id_, other->agent_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Message_descriptor_;
  metadata.reflection = Event_Message_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Failure::kAgentIdFieldNumber;
const int Event_Failure::kExecutorIdFieldNumber;
const int Event_Failure::kStatusFieldNumber;
#endif  // !_MSC_VER

Event_Failure::Event_Failure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event_Failure::InitAsDefaultInstance() {
  agent_id_ = const_cast< ::mesos::v1::AgentID*>(&::mesos::v1::AgentID::default_instance());
  executor_id_ = const_cast< ::mesos::v1::ExecutorID*>(&::mesos::v1::ExecutorID::default_instance());
}

Event_Failure::Event_Failure(const Event_Failure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event_Failure::SharedCtor() {
  _cached_size_ = 0;
  agent_id_ = NULL;
  executor_id_ = NULL;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Failure::~Event_Failure() {
  SharedDtor();
}

void Event_Failure::SharedDtor() {
  if (this != default_instance_) {
    delete agent_id_;
    delete executor_id_;
  }
}

void Event_Failure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Failure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Failure_descriptor_;
}

const Event_Failure& Event_Failure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Event_Failure* Event_Failure::default_instance_ = NULL;

Event_Failure* Event_Failure::New() const {
  return new Event_Failure;
}

void Event_Failure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agent_id()) {
      if (agent_id_ != NULL) agent_id_->::mesos::v1::AgentID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::v1::ExecutorID::Clear();
    }
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Failure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.v1.AgentID agent_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agent_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // optional .mesos.v1.ExecutorID executor_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // optional int32 status = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event_Failure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mesos.v1.AgentID agent_id = 1;
  if (has_agent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->agent_id(), output);
  }

  // optional .mesos.v1.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  // optional int32 status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event_Failure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mesos.v1.AgentID agent_id = 1;
  if (has_agent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->agent_id(), target);
  }

  // optional .mesos.v1.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  // optional int32 status = 3;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event_Failure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.v1.AgentID agent_id = 1;
    if (has_agent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agent_id());
    }

    // optional .mesos.v1.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // optional int32 status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Failure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Failure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Failure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Failure::MergeFrom(const Event_Failure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agent_id()) {
      mutable_agent_id()->::mesos::v1::AgentID::MergeFrom(from.agent_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::v1::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Failure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Failure::CopyFrom(const Event_Failure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Failure::IsInitialized() const {

  if (has_agent_id()) {
    if (!this->agent_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void Event_Failure::Swap(Event_Failure* other) {
  if (other != this) {
    std::swap(agent_id_, other->agent_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Failure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Failure_descriptor_;
  metadata.reflection = Event_Failure_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Error::kMessageFieldNumber;
#endif  // !_MSC_VER

Event_Error::Event_Error()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event_Error::InitAsDefaultInstance() {
}

Event_Error::Event_Error(const Event_Error& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event_Error::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Error::~Event_Error() {
  SharedDtor();
}

void Event_Error::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void Event_Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Error::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Error_descriptor_;
}

const Event_Error& Event_Error::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Event_Error* Event_Error::default_instance_ = NULL;

Event_Error* Event_Error::New() const {
  return new Event_Error;
}

void Event_Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event_Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event_Error::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event_Error::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Error::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Error* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Error*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Error::MergeFrom(const Event_Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Error::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Error::CopyFrom(const Event_Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Event_Error::Swap(Event_Error* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Error::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Error_descriptor_;
  metadata.reflection = Event_Error_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event::kTypeFieldNumber;
const int Event::kSubscribedFieldNumber;
const int Event::kOffersFieldNumber;
const int Event::kRescindFieldNumber;
const int Event::kUpdateFieldNumber;
const int Event::kMessageFieldNumber;
const int Event::kFailureFieldNumber;
const int Event::kErrorFieldNumber;
#endif  // !_MSC_VER

Event::Event()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event::InitAsDefaultInstance() {
  subscribed_ = const_cast< ::mesos::v1::scheduler::Event_Subscribed*>(&::mesos::v1::scheduler::Event_Subscribed::default_instance());
  offers_ = const_cast< ::mesos::v1::scheduler::Event_Offers*>(&::mesos::v1::scheduler::Event_Offers::default_instance());
  rescind_ = const_cast< ::mesos::v1::scheduler::Event_Rescind*>(&::mesos::v1::scheduler::Event_Rescind::default_instance());
  update_ = const_cast< ::mesos::v1::scheduler::Event_Update*>(&::mesos::v1::scheduler::Event_Update::default_instance());
  message_ = const_cast< ::mesos::v1::scheduler::Event_Message*>(&::mesos::v1::scheduler::Event_Message::default_instance());
  failure_ = const_cast< ::mesos::v1::scheduler::Event_Failure*>(&::mesos::v1::scheduler::Event_Failure::default_instance());
  error_ = const_cast< ::mesos::v1::scheduler::Event_Error*>(&::mesos::v1::scheduler::Event_Error::default_instance());
}

Event::Event(const Event& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  subscribed_ = NULL;
  offers_ = NULL;
  rescind_ = NULL;
  update_ = NULL;
  message_ = NULL;
  failure_ = NULL;
  error_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event::~Event() {
  SharedDtor();
}

void Event::SharedDtor() {
  if (this != default_instance_) {
    delete subscribed_;
    delete offers_;
    delete rescind_;
    delete update_;
    delete message_;
    delete failure_;
    delete error_;
  }
}

void Event::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_descriptor_;
}

const Event& Event::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Event* Event::default_instance_ = NULL;

Event* Event::New() const {
  return new Event;
}

void Event::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_subscribed()) {
      if (subscribed_ != NULL) subscribed_->::mesos::v1::scheduler::Event_Subscribed::Clear();
    }
    if (has_offers()) {
      if (offers_ != NULL) offers_->::mesos::v1::scheduler::Event_Offers::Clear();
    }
    if (has_rescind()) {
      if (rescind_ != NULL) rescind_->::mesos::v1::scheduler::Event_Rescind::Clear();
    }
    if (has_update()) {
      if (update_ != NULL) update_->::mesos::v1::scheduler::Event_Update::Clear();
    }
    if (has_message()) {
      if (message_ != NULL) message_->::mesos::v1::scheduler::Event_Message::Clear();
    }
    if (has_failure()) {
      if (failure_ != NULL) failure_->::mesos::v1::scheduler::Event_Failure::Clear();
    }
    if (has_error()) {
      if (error_ != NULL) error_->::mesos::v1::scheduler::Event_Error::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.scheduler.Event.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::v1::scheduler::Event_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::v1::scheduler::Event_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_subscribed;
        break;
      }

      // optional .mesos.v1.scheduler.Event.Subscribed subscribed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subscribed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_offers;
        break;
      }

      // optional .mesos.v1.scheduler.Event.Offers offers = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_rescind;
        break;
      }

      // optional .mesos.v1.scheduler.Event.Rescind rescind = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rescind:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rescind()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_update;
        break;
      }

      // optional .mesos.v1.scheduler.Event.Update update = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_update:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_update()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_message;
        break;
      }

      // optional .mesos.v1.scheduler.Event.Message message = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_failure;
        break;
      }

      // optional .mesos.v1.scheduler.Event.Failure failure = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_failure:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_failure()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_error;
        break;
      }

      // optional .mesos.v1.scheduler.Event.Error error = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.scheduler.Event.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.v1.scheduler.Event.Subscribed subscribed = 2;
  if (has_subscribed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->subscribed(), output);
  }

  // optional .mesos.v1.scheduler.Event.Offers offers = 3;
  if (has_offers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->offers(), output);
  }

  // optional .mesos.v1.scheduler.Event.Rescind rescind = 4;
  if (has_rescind()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->rescind(), output);
  }

  // optional .mesos.v1.scheduler.Event.Update update = 5;
  if (has_update()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->update(), output);
  }

  // optional .mesos.v1.scheduler.Event.Message message = 6;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->message(), output);
  }

  // optional .mesos.v1.scheduler.Event.Failure failure = 7;
  if (has_failure()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->failure(), output);
  }

  // optional .mesos.v1.scheduler.Event.Error error = 8;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->error(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.scheduler.Event.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.v1.scheduler.Event.Subscribed subscribed = 2;
  if (has_subscribed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->subscribed(), target);
  }

  // optional .mesos.v1.scheduler.Event.Offers offers = 3;
  if (has_offers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->offers(), target);
  }

  // optional .mesos.v1.scheduler.Event.Rescind rescind = 4;
  if (has_rescind()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->rescind(), target);
  }

  // optional .mesos.v1.scheduler.Event.Update update = 5;
  if (has_update()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->update(), target);
  }

  // optional .mesos.v1.scheduler.Event.Message message = 6;
  if (has_message()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->message(), target);
  }

  // optional .mesos.v1.scheduler.Event.Failure failure = 7;
  if (has_failure()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->failure(), target);
  }

  // optional .mesos.v1.scheduler.Event.Error error = 8;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->error(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.scheduler.Event.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.v1.scheduler.Event.Subscribed subscribed = 2;
    if (has_subscribed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->subscribed());
    }

    // optional .mesos.v1.scheduler.Event.Offers offers = 3;
    if (has_offers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->offers());
    }

    // optional .mesos.v1.scheduler.Event.Rescind rescind = 4;
    if (has_rescind()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rescind());
    }

    // optional .mesos.v1.scheduler.Event.Update update = 5;
    if (has_update()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->update());
    }

    // optional .mesos.v1.scheduler.Event.Message message = 6;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

    // optional .mesos.v1.scheduler.Event.Failure failure = 7;
    if (has_failure()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->failure());
    }

    // optional .mesos.v1.scheduler.Event.Error error = 8;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event::MergeFrom(const Event& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_subscribed()) {
      mutable_subscribed()->::mesos::v1::scheduler::Event_Subscribed::MergeFrom(from.subscribed());
    }
    if (from.has_offers()) {
      mutable_offers()->::mesos::v1::scheduler::Event_Offers::MergeFrom(from.offers());
    }
    if (from.has_rescind()) {
      mutable_rescind()->::mesos::v1::scheduler::Event_Rescind::MergeFrom(from.rescind());
    }
    if (from.has_update()) {
      mutable_update()->::mesos::v1::scheduler::Event_Update::MergeFrom(from.update());
    }
    if (from.has_message()) {
      mutable_message()->::mesos::v1::scheduler::Event_Message::MergeFrom(from.message());
    }
    if (from.has_failure()) {
      mutable_failure()->::mesos::v1::scheduler::Event_Failure::MergeFrom(from.failure());
    }
    if (from.has_error()) {
      mutable_error()->::mesos::v1::scheduler::Event_Error::MergeFrom(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event::CopyFrom(const Event& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_subscribed()) {
    if (!this->subscribed().IsInitialized()) return false;
  }
  if (has_offers()) {
    if (!this->offers().IsInitialized()) return false;
  }
  if (has_rescind()) {
    if (!this->rescind().IsInitialized()) return false;
  }
  if (has_update()) {
    if (!this->update().IsInitialized()) return false;
  }
  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  if (has_failure()) {
    if (!this->failure().IsInitialized()) return false;
  }
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

void Event::Swap(Event* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(subscribed_, other->subscribed_);
    std::swap(offers_, other->offers_);
    std::swap(rescind_, other->rescind_);
    std::swap(update_, other->update_);
    std::swap(message_, other->message_);
    std::swap(failure_, other->failure_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_descriptor_;
  metadata.reflection = Event_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Call_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Type_descriptor_;
}
bool Call_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Call_Type Call::SUBSCRIBE;
const Call_Type Call::TEARDOWN;
const Call_Type Call::ACCEPT;
const Call_Type Call::DECLINE;
const Call_Type Call::REVIVE;
const Call_Type Call::KILL;
const Call_Type Call::SHUTDOWN;
const Call_Type Call::ACKNOWLEDGE;
const Call_Type Call::RECONCILE;
const Call_Type Call::MESSAGE;
const Call_Type Call::REQUEST;
const Call_Type Call::SUPPRESS;
const Call_Type Call::Type_MIN;
const Call_Type Call::Type_MAX;
const int Call::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Call_Subscribe::kFrameworkInfoFieldNumber;
const int Call_Subscribe::kForceFieldNumber;
#endif  // !_MSC_VER

Call_Subscribe::Call_Subscribe()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Subscribe::InitAsDefaultInstance() {
  framework_info_ = const_cast< ::mesos::v1::FrameworkInfo*>(&::mesos::v1::FrameworkInfo::default_instance());
}

Call_Subscribe::Call_Subscribe(const Call_Subscribe& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Subscribe::SharedCtor() {
  _cached_size_ = 0;
  framework_info_ = NULL;
  force_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Subscribe::~Call_Subscribe() {
  SharedDtor();
}

void Call_Subscribe::SharedDtor() {
  if (this != default_instance_) {
    delete framework_info_;
  }
}

void Call_Subscribe::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Subscribe::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Subscribe_descriptor_;
}

const Call_Subscribe& Call_Subscribe::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Subscribe* Call_Subscribe::default_instance_ = NULL;

Call_Subscribe* Call_Subscribe::New() const {
  return new Call_Subscribe;
}

void Call_Subscribe::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_info()) {
      if (framework_info_ != NULL) framework_info_->::mesos::v1::FrameworkInfo::Clear();
    }
    force_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Subscribe::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.FrameworkInfo framework_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_force;
        break;
      }

      // optional bool force = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_force:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &force_)));
          set_has_force();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Subscribe::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.FrameworkInfo framework_info = 1;
  if (has_framework_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_info(), output);
  }

  // optional bool force = 2;
  if (has_force()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->force(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Subscribe::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.FrameworkInfo framework_info = 1;
  if (has_framework_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_info(), target);
  }

  // optional bool force = 2;
  if (has_force()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->force(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Subscribe::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.FrameworkInfo framework_info = 1;
    if (has_framework_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_info());
    }

    // optional bool force = 2;
    if (has_force()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Subscribe::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Subscribe* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Subscribe*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Subscribe::MergeFrom(const Call_Subscribe& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_info()) {
      mutable_framework_info()->::mesos::v1::FrameworkInfo::MergeFrom(from.framework_info());
    }
    if (from.has_force()) {
      set_force(from.force());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Subscribe::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Subscribe::CopyFrom(const Call_Subscribe& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Subscribe::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_info()) {
    if (!this->framework_info().IsInitialized()) return false;
  }
  return true;
}

void Call_Subscribe::Swap(Call_Subscribe* other) {
  if (other != this) {
    std::swap(framework_info_, other->framework_info_);
    std::swap(force_, other->force_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Subscribe::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Subscribe_descriptor_;
  metadata.reflection = Call_Subscribe_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Accept::kOfferIdsFieldNumber;
const int Call_Accept::kOperationsFieldNumber;
const int Call_Accept::kFiltersFieldNumber;
#endif  // !_MSC_VER

Call_Accept::Call_Accept()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Accept::InitAsDefaultInstance() {
  filters_ = const_cast< ::mesos::v1::Filters*>(&::mesos::v1::Filters::default_instance());
}

Call_Accept::Call_Accept(const Call_Accept& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Accept::SharedCtor() {
  _cached_size_ = 0;
  filters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Accept::~Call_Accept() {
  SharedDtor();
}

void Call_Accept::SharedDtor() {
  if (this != default_instance_) {
    delete filters_;
  }
}

void Call_Accept::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Accept::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Accept_descriptor_;
}

const Call_Accept& Call_Accept::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Accept* Call_Accept::default_instance_ = NULL;

Call_Accept* Call_Accept::New() const {
  return new Call_Accept;
}

void Call_Accept::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (has_filters()) {
      if (filters_ != NULL) filters_->::mesos::v1::Filters::Clear();
    }
  }
  offer_ids_.Clear();
  operations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Accept::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.v1.OfferID offer_ids = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offer_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offer_ids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_offer_ids;
        if (input->ExpectTag(18)) goto parse_operations;
        break;
      }

      // repeated .mesos.v1.Offer.Operation operations = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_operations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_operations;
        if (input->ExpectTag(26)) goto parse_filters;
        break;
      }

      // optional .mesos.v1.Filters filters = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Accept::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.v1.OfferID offer_ids = 1;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offer_ids(i), output);
  }

  // repeated .mesos.v1.Offer.Operation operations = 2;
  for (int i = 0; i < this->operations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->operations(i), output);
  }

  // optional .mesos.v1.Filters filters = 3;
  if (has_filters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->filters(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Accept::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.v1.OfferID offer_ids = 1;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offer_ids(i), target);
  }

  // repeated .mesos.v1.Offer.Operation operations = 2;
  for (int i = 0; i < this->operations_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->operations(i), target);
  }

  // optional .mesos.v1.Filters filters = 3;
  if (has_filters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->filters(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Accept::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional .mesos.v1.Filters filters = 3;
    if (has_filters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filters());
    }

  }
  // repeated .mesos.v1.OfferID offer_ids = 1;
  total_size += 1 * this->offer_ids_size();
  for (int i = 0; i < this->offer_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offer_ids(i));
  }

  // repeated .mesos.v1.Offer.Operation operations = 2;
  total_size += 1 * this->operations_size();
  for (int i = 0; i < this->operations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->operations(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Accept::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Accept* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Accept*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Accept::MergeFrom(const Call_Accept& from) {
  GOOGLE_CHECK_NE(&from, this);
  offer_ids_.MergeFrom(from.offer_ids_);
  operations_.MergeFrom(from.operations_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_filters()) {
      mutable_filters()->::mesos::v1::Filters::MergeFrom(from.filters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Accept::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Accept::CopyFrom(const Call_Accept& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Accept::IsInitialized() const {

  for (int i = 0; i < offer_ids_size(); i++) {
    if (!this->offer_ids(i).IsInitialized()) return false;
  }
  for (int i = 0; i < operations_size(); i++) {
    if (!this->operations(i).IsInitialized()) return false;
  }
  return true;
}

void Call_Accept::Swap(Call_Accept* other) {
  if (other != this) {
    offer_ids_.Swap(&other->offer_ids_);
    operations_.Swap(&other->operations_);
    std::swap(filters_, other->filters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Accept::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Accept_descriptor_;
  metadata.reflection = Call_Accept_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Decline::kOfferIdsFieldNumber;
const int Call_Decline::kFiltersFieldNumber;
#endif  // !_MSC_VER

Call_Decline::Call_Decline()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Decline::InitAsDefaultInstance() {
  filters_ = const_cast< ::mesos::v1::Filters*>(&::mesos::v1::Filters::default_instance());
}

Call_Decline::Call_Decline(const Call_Decline& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Decline::SharedCtor() {
  _cached_size_ = 0;
  filters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Decline::~Call_Decline() {
  SharedDtor();
}

void Call_Decline::SharedDtor() {
  if (this != default_instance_) {
    delete filters_;
  }
}

void Call_Decline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Decline::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Decline_descriptor_;
}

const Call_Decline& Call_Decline::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Decline* Call_Decline::default_instance_ = NULL;

Call_Decline* Call_Decline::New() const {
  return new Call_Decline;
}

void Call_Decline::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_filters()) {
      if (filters_ != NULL) filters_->::mesos::v1::Filters::Clear();
    }
  }
  offer_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Decline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.v1.OfferID offer_ids = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offer_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offer_ids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_offer_ids;
        if (input->ExpectTag(18)) goto parse_filters;
        break;
      }

      // optional .mesos.v1.Filters filters = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Decline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.v1.OfferID offer_ids = 1;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offer_ids(i), output);
  }

  // optional .mesos.v1.Filters filters = 2;
  if (has_filters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->filters(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Decline::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.v1.OfferID offer_ids = 1;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offer_ids(i), target);
  }

  // optional .mesos.v1.Filters filters = 2;
  if (has_filters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->filters(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Decline::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .mesos.v1.Filters filters = 2;
    if (has_filters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filters());
    }

  }
  // repeated .mesos.v1.OfferID offer_ids = 1;
  total_size += 1 * this->offer_ids_size();
  for (int i = 0; i < this->offer_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offer_ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Decline::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Decline* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Decline*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Decline::MergeFrom(const Call_Decline& from) {
  GOOGLE_CHECK_NE(&from, this);
  offer_ids_.MergeFrom(from.offer_ids_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_filters()) {
      mutable_filters()->::mesos::v1::Filters::MergeFrom(from.filters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Decline::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Decline::CopyFrom(const Call_Decline& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Decline::IsInitialized() const {

  for (int i = 0; i < offer_ids_size(); i++) {
    if (!this->offer_ids(i).IsInitialized()) return false;
  }
  return true;
}

void Call_Decline::Swap(Call_Decline* other) {
  if (other != this) {
    offer_ids_.Swap(&other->offer_ids_);
    std::swap(filters_, other->filters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Decline::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Decline_descriptor_;
  metadata.reflection = Call_Decline_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Kill::kTaskIdFieldNumber;
const int Call_Kill::kAgentIdFieldNumber;
#endif  // !_MSC_VER

Call_Kill::Call_Kill()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Kill::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::v1::TaskID*>(&::mesos::v1::TaskID::default_instance());
  agent_id_ = const_cast< ::mesos::v1::AgentID*>(&::mesos::v1::AgentID::default_instance());
}

Call_Kill::Call_Kill(const Call_Kill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Kill::SharedCtor() {
  _cached_size_ = 0;
  task_id_ = NULL;
  agent_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Kill::~Call_Kill() {
  SharedDtor();
}

void Call_Kill::SharedDtor() {
  if (this != default_instance_) {
    delete task_id_;
    delete agent_id_;
  }
}

void Call_Kill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Kill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Kill_descriptor_;
}

const Call_Kill& Call_Kill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Kill* Call_Kill::default_instance_ = NULL;

Call_Kill* Call_Kill::New() const {
  return new Call_Kill;
}

void Call_Kill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::v1::TaskID::Clear();
    }
    if (has_agent_id()) {
      if (agent_id_ != NULL) agent_id_->::mesos::v1::AgentID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Kill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.TaskID task_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_agent_id;
        break;
      }

      // optional .mesos.v1.AgentID agent_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agent_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agent_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Kill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.TaskID task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_id(), output);
  }

  // optional .mesos.v1.AgentID agent_id = 2;
  if (has_agent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->agent_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Kill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.TaskID task_id = 1;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->task_id(), target);
  }

  // optional .mesos.v1.AgentID agent_id = 2;
  if (has_agent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->agent_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Kill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.TaskID task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // optional .mesos.v1.AgentID agent_id = 2;
    if (has_agent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agent_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Kill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Kill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Kill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Kill::MergeFrom(const Call_Kill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::v1::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_agent_id()) {
      mutable_agent_id()->::mesos::v1::AgentID::MergeFrom(from.agent_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Kill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Kill::CopyFrom(const Call_Kill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Kill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_agent_id()) {
    if (!this->agent_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Kill::Swap(Call_Kill* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(agent_id_, other->agent_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Kill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Kill_descriptor_;
  metadata.reflection = Call_Kill_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Shutdown::kExecutorIdFieldNumber;
const int Call_Shutdown::kAgentIdFieldNumber;
#endif  // !_MSC_VER

Call_Shutdown::Call_Shutdown()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Shutdown::InitAsDefaultInstance() {
  executor_id_ = const_cast< ::mesos::v1::ExecutorID*>(&::mesos::v1::ExecutorID::default_instance());
  agent_id_ = const_cast< ::mesos::v1::AgentID*>(&::mesos::v1::AgentID::default_instance());
}

Call_Shutdown::Call_Shutdown(const Call_Shutdown& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Shutdown::SharedCtor() {
  _cached_size_ = 0;
  executor_id_ = NULL;
  agent_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Shutdown::~Call_Shutdown() {
  SharedDtor();
}

void Call_Shutdown::SharedDtor() {
  if (this != default_instance_) {
    delete executor_id_;
    delete agent_id_;
  }
}

void Call_Shutdown::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Shutdown::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Shutdown_descriptor_;
}

const Call_Shutdown& Call_Shutdown::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Shutdown* Call_Shutdown::default_instance_ = NULL;

Call_Shutdown* Call_Shutdown::New() const {
  return new Call_Shutdown;
}

void Call_Shutdown::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::v1::ExecutorID::Clear();
    }
    if (has_agent_id()) {
      if (agent_id_ != NULL) agent_id_->::mesos::v1::AgentID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Shutdown::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.ExecutorID executor_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_agent_id;
        break;
      }

      // required .mesos.v1.AgentID agent_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agent_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agent_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Shutdown::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_id(), output);
  }

  // required .mesos.v1.AgentID agent_id = 2;
  if (has_agent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->agent_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Shutdown::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_id(), target);
  }

  // required .mesos.v1.AgentID agent_id = 2;
  if (has_agent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->agent_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Shutdown::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.ExecutorID executor_id = 1;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required .mesos.v1.AgentID agent_id = 2;
    if (has_agent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agent_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Shutdown::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Shutdown* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Shutdown*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Shutdown::MergeFrom(const Call_Shutdown& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::v1::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_agent_id()) {
      mutable_agent_id()->::mesos::v1::AgentID::MergeFrom(from.agent_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Shutdown::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Shutdown::CopyFrom(const Call_Shutdown& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Shutdown::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_agent_id()) {
    if (!this->agent_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Shutdown::Swap(Call_Shutdown* other) {
  if (other != this) {
    std::swap(executor_id_, other->executor_id_);
    std::swap(agent_id_, other->agent_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Shutdown::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Shutdown_descriptor_;
  metadata.reflection = Call_Shutdown_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Acknowledge::kAgentIdFieldNumber;
const int Call_Acknowledge::kTaskIdFieldNumber;
const int Call_Acknowledge::kUuidFieldNumber;
#endif  // !_MSC_VER

Call_Acknowledge::Call_Acknowledge()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Acknowledge::InitAsDefaultInstance() {
  agent_id_ = const_cast< ::mesos::v1::AgentID*>(&::mesos::v1::AgentID::default_instance());
  task_id_ = const_cast< ::mesos::v1::TaskID*>(&::mesos::v1::TaskID::default_instance());
}

Call_Acknowledge::Call_Acknowledge(const Call_Acknowledge& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Acknowledge::SharedCtor() {
  _cached_size_ = 0;
  agent_id_ = NULL;
  task_id_ = NULL;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Acknowledge::~Call_Acknowledge() {
  SharedDtor();
}

void Call_Acknowledge::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete agent_id_;
    delete task_id_;
  }
}

void Call_Acknowledge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Acknowledge::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Acknowledge_descriptor_;
}

const Call_Acknowledge& Call_Acknowledge::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Acknowledge* Call_Acknowledge::default_instance_ = NULL;

Call_Acknowledge* Call_Acknowledge::New() const {
  return new Call_Acknowledge;
}

void Call_Acknowledge::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agent_id()) {
      if (agent_id_ != NULL) agent_id_->::mesos::v1::AgentID::Clear();
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::v1::TaskID::Clear();
    }
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Acknowledge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.AgentID agent_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agent_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.v1.TaskID task_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_uuid;
        break;
      }

      // required bytes uuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Acknowledge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.AgentID agent_id = 1;
  if (has_agent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->agent_id(), output);
  }

  // required .mesos.v1.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_id(), output);
  }

  // required bytes uuid = 3;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Acknowledge::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.AgentID agent_id = 1;
  if (has_agent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->agent_id(), target);
  }

  // required .mesos.v1.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_id(), target);
  }

  // required bytes uuid = 3;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Acknowledge::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.AgentID agent_id = 1;
    if (has_agent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agent_id());
    }

    // required .mesos.v1.TaskID task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required bytes uuid = 3;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Acknowledge::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Acknowledge* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Acknowledge*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Acknowledge::MergeFrom(const Call_Acknowledge& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agent_id()) {
      mutable_agent_id()->::mesos::v1::AgentID::MergeFrom(from.agent_id());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::v1::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Acknowledge::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Acknowledge::CopyFrom(const Call_Acknowledge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Acknowledge::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_agent_id()) {
    if (!this->agent_id().IsInitialized()) return false;
  }
  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Acknowledge::Swap(Call_Acknowledge* other) {
  if (other != this) {
    std::swap(agent_id_, other->agent_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Acknowledge::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Acknowledge_descriptor_;
  metadata.reflection = Call_Acknowledge_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Reconcile_Task::kTaskIdFieldNumber;
const int Call_Reconcile_Task::kAgentIdFieldNumber;
#endif  // !_MSC_VER

Call_Reconcile_Task::Call_Reconcile_Task()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Reconcile_Task::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::v1::TaskID*>(&::mesos::v1::TaskID::default_instance());
  agent_id_ = const_cast< ::mesos::v1::AgentID*>(&::mesos::v1::AgentID::default_instance());
}

Call_Reconcile_Task::Call_Reconcile_Task(const Call_Reconcile_Task& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Reconcile_Task::SharedCtor() {
  _cached_size_ = 0;
  task_id_ = NULL;
  agent_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Reconcile_Task::~Call_Reconcile_Task() {
  SharedDtor();
}

void Call_Reconcile_Task::SharedDtor() {
  if (this != default_instance_) {
    delete task_id_;
    delete agent_id_;
  }
}

void Call_Reconcile_Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Reconcile_Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Reconcile_Task_descriptor_;
}

const Call_Reconcile_Task& Call_Reconcile_Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Reconcile_Task* Call_Reconcile_Task::default_instance_ = NULL;

Call_Reconcile_Task* Call_Reconcile_Task::New() const {
  return new Call_Reconcile_Task;
}

void Call_Reconcile_Task::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::v1::TaskID::Clear();
    }
    if (has_agent_id()) {
      if (agent_id_ != NULL) agent_id_->::mesos::v1::AgentID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Reconcile_Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.TaskID task_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_agent_id;
        break;
      }

      // optional .mesos.v1.AgentID agent_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agent_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agent_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Reconcile_Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.TaskID task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_id(), output);
  }

  // optional .mesos.v1.AgentID agent_id = 2;
  if (has_agent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->agent_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Reconcile_Task::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.TaskID task_id = 1;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->task_id(), target);
  }

  // optional .mesos.v1.AgentID agent_id = 2;
  if (has_agent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->agent_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Reconcile_Task::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.TaskID task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // optional .mesos.v1.AgentID agent_id = 2;
    if (has_agent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agent_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Reconcile_Task::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Reconcile_Task* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Reconcile_Task*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Reconcile_Task::MergeFrom(const Call_Reconcile_Task& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::v1::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_agent_id()) {
      mutable_agent_id()->::mesos::v1::AgentID::MergeFrom(from.agent_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Reconcile_Task::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Reconcile_Task::CopyFrom(const Call_Reconcile_Task& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Reconcile_Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_agent_id()) {
    if (!this->agent_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Reconcile_Task::Swap(Call_Reconcile_Task* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(agent_id_, other->agent_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Reconcile_Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Reconcile_Task_descriptor_;
  metadata.reflection = Call_Reconcile_Task_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Reconcile::kTasksFieldNumber;
#endif  // !_MSC_VER

Call_Reconcile::Call_Reconcile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Reconcile::InitAsDefaultInstance() {
}

Call_Reconcile::Call_Reconcile(const Call_Reconcile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Reconcile::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Reconcile::~Call_Reconcile() {
  SharedDtor();
}

void Call_Reconcile::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Call_Reconcile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Reconcile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Reconcile_descriptor_;
}

const Call_Reconcile& Call_Reconcile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Reconcile* Call_Reconcile::default_instance_ = NULL;

Call_Reconcile* Call_Reconcile::New() const {
  return new Call_Reconcile;
}

void Call_Reconcile::Clear() {
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Reconcile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.v1.scheduler.Call.Reconcile.Task tasks = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_tasks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Reconcile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.v1.scheduler.Call.Reconcile.Task tasks = 1;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tasks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Reconcile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.v1.scheduler.Call.Reconcile.Task tasks = 1;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tasks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Reconcile::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.v1.scheduler.Call.Reconcile.Task tasks = 1;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Reconcile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Reconcile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Reconcile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Reconcile::MergeFrom(const Call_Reconcile& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Reconcile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Reconcile::CopyFrom(const Call_Reconcile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Reconcile::IsInitialized() const {

  for (int i = 0; i < tasks_size(); i++) {
    if (!this->tasks(i).IsInitialized()) return false;
  }
  return true;
}

void Call_Reconcile::Swap(Call_Reconcile* other) {
  if (other != this) {
    tasks_.Swap(&other->tasks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Reconcile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Reconcile_descriptor_;
  metadata.reflection = Call_Reconcile_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Message::kAgentIdFieldNumber;
const int Call_Message::kExecutorIdFieldNumber;
const int Call_Message::kDataFieldNumber;
#endif  // !_MSC_VER

Call_Message::Call_Message()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Message::InitAsDefaultInstance() {
  agent_id_ = const_cast< ::mesos::v1::AgentID*>(&::mesos::v1::AgentID::default_instance());
  executor_id_ = const_cast< ::mesos::v1::ExecutorID*>(&::mesos::v1::ExecutorID::default_instance());
}

Call_Message::Call_Message(const Call_Message& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Message::SharedCtor() {
  _cached_size_ = 0;
  agent_id_ = NULL;
  executor_id_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Message::~Call_Message() {
  SharedDtor();
}

void Call_Message::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
    delete agent_id_;
    delete executor_id_;
  }
}

void Call_Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Message_descriptor_;
}

const Call_Message& Call_Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Message* Call_Message::default_instance_ = NULL;

Call_Message* Call_Message::New() const {
  return new Call_Message;
}

void Call_Message::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agent_id()) {
      if (agent_id_ != NULL) agent_id_->::mesos::v1::AgentID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::v1::ExecutorID::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.v1.AgentID agent_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agent_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // required .mesos.v1.ExecutorID executor_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.v1.AgentID agent_id = 1;
  if (has_agent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->agent_id(), output);
  }

  // required .mesos.v1.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Message::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.v1.AgentID agent_id = 1;
  if (has_agent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->agent_id(), target);
  }

  // required .mesos.v1.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  // required bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Message::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.v1.AgentID agent_id = 1;
    if (has_agent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agent_id());
    }

    // required .mesos.v1.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Message::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Message* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Message*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Message::MergeFrom(const Call_Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agent_id()) {
      mutable_agent_id()->::mesos::v1::AgentID::MergeFrom(from.agent_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::v1::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Message::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Message::CopyFrom(const Call_Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Message::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_agent_id()) {
    if (!this->agent_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Message::Swap(Call_Message* other) {
  if (other != this) {
    std::swap(agent_id_, other->agent_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Message_descriptor_;
  metadata.reflection = Call_Message_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Request::kRequestsFieldNumber;
#endif  // !_MSC_VER

Call_Request::Call_Request()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call_Request::InitAsDefaultInstance() {
}

Call_Request::Call_Request(const Call_Request& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call_Request::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Request::~Call_Request() {
  SharedDtor();
}

void Call_Request::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Call_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Request_descriptor_;
}

const Call_Request& Call_Request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call_Request* Call_Request::default_instance_ = NULL;

Call_Request* Call_Request::New() const {
  return new Call_Request;
}

void Call_Request::Clear() {
  requests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.v1.Request requests = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_requests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_requests()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_requests;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.v1.Request requests = 1;
  for (int i = 0; i < this->requests_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->requests(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call_Request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.v1.Request requests = 1;
  for (int i = 0; i < this->requests_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->requests(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call_Request::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.v1.Request requests = 1;
  total_size += 1 * this->requests_size();
  for (int i = 0; i < this->requests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->requests(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Request::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Request* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Request*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Request::MergeFrom(const Call_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  requests_.MergeFrom(from.requests_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Request::CopyFrom(const Call_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Request::IsInitialized() const {

  for (int i = 0; i < requests_size(); i++) {
    if (!this->requests(i).IsInitialized()) return false;
  }
  return true;
}

void Call_Request::Swap(Call_Request* other) {
  if (other != this) {
    requests_.Swap(&other->requests_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Request_descriptor_;
  metadata.reflection = Call_Request_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call::kFrameworkIdFieldNumber;
const int Call::kTypeFieldNumber;
const int Call::kSubscribeFieldNumber;
const int Call::kAcceptFieldNumber;
const int Call::kDeclineFieldNumber;
const int Call::kKillFieldNumber;
const int Call::kShutdownFieldNumber;
const int Call::kAcknowledgeFieldNumber;
const int Call::kReconcileFieldNumber;
const int Call::kMessageFieldNumber;
const int Call::kRequestFieldNumber;
#endif  // !_MSC_VER

Call::Call()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::v1::FrameworkID*>(&::mesos::v1::FrameworkID::default_instance());
  subscribe_ = const_cast< ::mesos::v1::scheduler::Call_Subscribe*>(&::mesos::v1::scheduler::Call_Subscribe::default_instance());
  accept_ = const_cast< ::mesos::v1::scheduler::Call_Accept*>(&::mesos::v1::scheduler::Call_Accept::default_instance());
  decline_ = const_cast< ::mesos::v1::scheduler::Call_Decline*>(&::mesos::v1::scheduler::Call_Decline::default_instance());
  kill_ = const_cast< ::mesos::v1::scheduler::Call_Kill*>(&::mesos::v1::scheduler::Call_Kill::default_instance());
  shutdown_ = const_cast< ::mesos::v1::scheduler::Call_Shutdown*>(&::mesos::v1::scheduler::Call_Shutdown::default_instance());
  acknowledge_ = const_cast< ::mesos::v1::scheduler::Call_Acknowledge*>(&::mesos::v1::scheduler::Call_Acknowledge::default_instance());
  reconcile_ = const_cast< ::mesos::v1::scheduler::Call_Reconcile*>(&::mesos::v1::scheduler::Call_Reconcile::default_instance());
  message_ = const_cast< ::mesos::v1::scheduler::Call_Message*>(&::mesos::v1::scheduler::Call_Message::default_instance());
  request_ = const_cast< ::mesos::v1::scheduler::Call_Request*>(&::mesos::v1::scheduler::Call_Request::default_instance());
}

Call::Call(const Call& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  type_ = 1;
  subscribe_ = NULL;
  accept_ = NULL;
  decline_ = NULL;
  kill_ = NULL;
  shutdown_ = NULL;
  acknowledge_ = NULL;
  reconcile_ = NULL;
  message_ = NULL;
  request_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call::~Call() {
  SharedDtor();
}

void Call::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete subscribe_;
    delete accept_;
    delete decline_;
    delete kill_;
    delete shutdown_;
    delete acknowledge_;
    delete reconcile_;
    delete message_;
    delete request_;
  }
}

void Call::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_descriptor_;
}

const Call& Call::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2fv1_2fscheduler_2fscheduler_2eproto();
  return *default_instance_;
}

Call* Call::default_instance_ = NULL;

Call* Call::New() const {
  return new Call;
}

void Call::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::v1::FrameworkID::Clear();
    }
    type_ = 1;
    if (has_subscribe()) {
      if (subscribe_ != NULL) subscribe_->::mesos::v1::scheduler::Call_Subscribe::Clear();
    }
    if (has_accept()) {
      if (accept_ != NULL) accept_->::mesos::v1::scheduler::Call_Accept::Clear();
    }
    if (has_decline()) {
      if (decline_ != NULL) decline_->::mesos::v1::scheduler::Call_Decline::Clear();
    }
    if (has_kill()) {
      if (kill_ != NULL) kill_->::mesos::v1::scheduler::Call_Kill::Clear();
    }
    if (has_shutdown()) {
      if (shutdown_ != NULL) shutdown_->::mesos::v1::scheduler::Call_Shutdown::Clear();
    }
    if (has_acknowledge()) {
      if (acknowledge_ != NULL) acknowledge_->::mesos::v1::scheduler::Call_Acknowledge::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_reconcile()) {
      if (reconcile_ != NULL) reconcile_->::mesos::v1::scheduler::Call_Reconcile::Clear();
    }
    if (has_message()) {
      if (message_ != NULL) message_->::mesos::v1::scheduler::Call_Message::Clear();
    }
    if (has_request()) {
      if (request_ != NULL) request_->::mesos::v1::scheduler::Call_Request::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.v1.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .mesos.v1.scheduler.Call.Type type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::v1::scheduler::Call_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::v1::scheduler::Call_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_subscribe;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Subscribe subscribe = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subscribe:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribe()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_accept;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Accept accept = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_accept:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_accept()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_decline;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Decline decline = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_decline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_decline()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_kill;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Kill kill = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_kill:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kill()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_shutdown;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Shutdown shutdown = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shutdown:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shutdown()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_acknowledge;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Acknowledge acknowledge = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_acknowledge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_acknowledge()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_reconcile;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Reconcile reconcile = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reconcile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reconcile()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_message;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Message message = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_request;
        break;
      }

      // optional .mesos.v1.scheduler.Call.Request request = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mesos.v1.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.v1.scheduler.Call.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .mesos.v1.scheduler.Call.Subscribe subscribe = 3;
  if (has_subscribe()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->subscribe(), output);
  }

  // optional .mesos.v1.scheduler.Call.Accept accept = 4;
  if (has_accept()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->accept(), output);
  }

  // optional .mesos.v1.scheduler.Call.Decline decline = 5;
  if (has_decline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->decline(), output);
  }

  // optional .mesos.v1.scheduler.Call.Kill kill = 6;
  if (has_kill()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->kill(), output);
  }

  // optional .mesos.v1.scheduler.Call.Shutdown shutdown = 7;
  if (has_shutdown()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->shutdown(), output);
  }

  // optional .mesos.v1.scheduler.Call.Acknowledge acknowledge = 8;
  if (has_acknowledge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->acknowledge(), output);
  }

  // optional .mesos.v1.scheduler.Call.Reconcile reconcile = 9;
  if (has_reconcile()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->reconcile(), output);
  }

  // optional .mesos.v1.scheduler.Call.Message message = 10;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->message(), output);
  }

  // optional .mesos.v1.scheduler.Call.Request request = 11;
  if (has_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->request(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mesos.v1.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.v1.scheduler.Call.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .mesos.v1.scheduler.Call.Subscribe subscribe = 3;
  if (has_subscribe()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->subscribe(), target);
  }

  // optional .mesos.v1.scheduler.Call.Accept accept = 4;
  if (has_accept()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->accept(), target);
  }

  // optional .mesos.v1.scheduler.Call.Decline decline = 5;
  if (has_decline()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->decline(), target);
  }

  // optional .mesos.v1.scheduler.Call.Kill kill = 6;
  if (has_kill()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->kill(), target);
  }

  // optional .mesos.v1.scheduler.Call.Shutdown shutdown = 7;
  if (has_shutdown()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->shutdown(), target);
  }

  // optional .mesos.v1.scheduler.Call.Acknowledge acknowledge = 8;
  if (has_acknowledge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->acknowledge(), target);
  }

  // optional .mesos.v1.scheduler.Call.Reconcile reconcile = 9;
  if (has_reconcile()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->reconcile(), target);
  }

  // optional .mesos.v1.scheduler.Call.Message message = 10;
  if (has_message()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->message(), target);
  }

  // optional .mesos.v1.scheduler.Call.Request request = 11;
  if (has_request()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->request(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.v1.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.v1.scheduler.Call.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.v1.scheduler.Call.Subscribe subscribe = 3;
    if (has_subscribe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->subscribe());
    }

    // optional .mesos.v1.scheduler.Call.Accept accept = 4;
    if (has_accept()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->accept());
    }

    // optional .mesos.v1.scheduler.Call.Decline decline = 5;
    if (has_decline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->decline());
    }

    // optional .mesos.v1.scheduler.Call.Kill kill = 6;
    if (has_kill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kill());
    }

    // optional .mesos.v1.scheduler.Call.Shutdown shutdown = 7;
    if (has_shutdown()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shutdown());
    }

    // optional .mesos.v1.scheduler.Call.Acknowledge acknowledge = 8;
    if (has_acknowledge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->acknowledge());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.v1.scheduler.Call.Reconcile reconcile = 9;
    if (has_reconcile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reconcile());
    }

    // optional .mesos.v1.scheduler.Call.Message message = 10;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

    // optional .mesos.v1.scheduler.Call.Request request = 11;
    if (has_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->request());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call::MergeFrom(const Call& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::v1::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_subscribe()) {
      mutable_subscribe()->::mesos::v1::scheduler::Call_Subscribe::MergeFrom(from.subscribe());
    }
    if (from.has_accept()) {
      mutable_accept()->::mesos::v1::scheduler::Call_Accept::MergeFrom(from.accept());
    }
    if (from.has_decline()) {
      mutable_decline()->::mesos::v1::scheduler::Call_Decline::MergeFrom(from.decline());
    }
    if (from.has_kill()) {
      mutable_kill()->::mesos::v1::scheduler::Call_Kill::MergeFrom(from.kill());
    }
    if (from.has_shutdown()) {
      mutable_shutdown()->::mesos::v1::scheduler::Call_Shutdown::MergeFrom(from.shutdown());
    }
    if (from.has_acknowledge()) {
      mutable_acknowledge()->::mesos::v1::scheduler::Call_Acknowledge::MergeFrom(from.acknowledge());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_reconcile()) {
      mutable_reconcile()->::mesos::v1::scheduler::Call_Reconcile::MergeFrom(from.reconcile());
    }
    if (from.has_message()) {
      mutable_message()->::mesos::v1::scheduler::Call_Message::MergeFrom(from.message());
    }
    if (from.has_request()) {
      mutable_request()->::mesos::v1::scheduler::Call_Request::MergeFrom(from.request());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call::CopyFrom(const Call& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_subscribe()) {
    if (!this->subscribe().IsInitialized()) return false;
  }
  if (has_accept()) {
    if (!this->accept().IsInitialized()) return false;
  }
  if (has_decline()) {
    if (!this->decline().IsInitialized()) return false;
  }
  if (has_kill()) {
    if (!this->kill().IsInitialized()) return false;
  }
  if (has_shutdown()) {
    if (!this->shutdown().IsInitialized()) return false;
  }
  if (has_acknowledge()) {
    if (!this->acknowledge().IsInitialized()) return false;
  }
  if (has_reconcile()) {
    if (!this->reconcile().IsInitialized()) return false;
  }
  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  if (has_request()) {
    if (!this->request().IsInitialized()) return false;
  }
  return true;
}

void Call::Swap(Call* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(type_, other->type_);
    std::swap(subscribe_, other->subscribe_);
    std::swap(accept_, other->accept_);
    std::swap(decline_, other->decline_);
    std::swap(kill_, other->kill_);
    std::swap(shutdown_, other->shutdown_);
    std::swap(acknowledge_, other->acknowledge_);
    std::swap(reconcile_, other->reconcile_);
    std::swap(message_, other->message_);
    std::swap(request_, other->request_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_descriptor_;
  metadata.reflection = Call_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace scheduler
}  // namespace v1
}  // namespace mesos

// @@protoc_insertion_point(global_scope)
