// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: slave/containerizer/provisioner/docker/message.proto

#ifndef PROTOBUF_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto__INCLUDED
#define PROTOBUF_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace mesos {
namespace internal {
namespace slave {
namespace docker {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

class Image;
class Image_Name;
class Images;
class DockerImageManifest;
class DockerImageManifest_FsLayers;
class DockerImageManifest_History;
class DockerImageManifest_History_V1Compatibility;
class DockerImageManifest_Signatures;
class DockerImageManifest_Signatures_Header;
class DockerImageManifest_Signatures_Header_Jwk;

// ===================================================================

class Image_Name : public ::google::protobuf::Message {
 public:
  Image_Name();
  virtual ~Image_Name();

  Image_Name(const Image_Name& from);

  inline Image_Name& operator=(const Image_Name& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image_Name& default_instance();

  void Swap(Image_Name* other);

  // implements Message ----------------------------------------------

  Image_Name* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image_Name& from);
  void MergeFrom(const Image_Name& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string registry = 1;
  inline bool has_registry() const;
  inline void clear_registry();
  static const int kRegistryFieldNumber = 1;
  inline const ::std::string& registry() const;
  inline void set_registry(const ::std::string& value);
  inline void set_registry(const char* value);
  inline void set_registry(const char* value, size_t size);
  inline ::std::string* mutable_registry();
  inline ::std::string* release_registry();
  inline void set_allocated_registry(::std::string* registry);

  // required string repository = 2;
  inline bool has_repository() const;
  inline void clear_repository();
  static const int kRepositoryFieldNumber = 2;
  inline const ::std::string& repository() const;
  inline void set_repository(const ::std::string& value);
  inline void set_repository(const char* value);
  inline void set_repository(const char* value, size_t size);
  inline ::std::string* mutable_repository();
  inline ::std::string* release_repository();
  inline void set_allocated_repository(::std::string* repository);

  // required string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.Image.Name)
 private:
  inline void set_has_registry();
  inline void clear_has_registry();
  inline void set_has_repository();
  inline void clear_has_repository();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* registry_;
  ::std::string* repository_;
  ::std::string* tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static Image_Name* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  Image* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Image_Name Name;

  // accessors -------------------------------------------------------

  // required .mesos.internal.slave.docker.Image.Name name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::mesos::internal::slave::docker::Image_Name& name() const;
  inline ::mesos::internal::slave::docker::Image_Name* mutable_name();
  inline ::mesos::internal::slave::docker::Image_Name* release_name();
  inline void set_allocated_name(::mesos::internal::slave::docker::Image_Name* name);

  // repeated string layer_ids = 2;
  inline int layer_ids_size() const;
  inline void clear_layer_ids();
  static const int kLayerIdsFieldNumber = 2;
  inline const ::std::string& layer_ids(int index) const;
  inline ::std::string* mutable_layer_ids(int index);
  inline void set_layer_ids(int index, const ::std::string& value);
  inline void set_layer_ids(int index, const char* value);
  inline void set_layer_ids(int index, const char* value, size_t size);
  inline ::std::string* add_layer_ids();
  inline void add_layer_ids(const ::std::string& value);
  inline void add_layer_ids(const char* value);
  inline void add_layer_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& layer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_layer_ids();

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.Image)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::internal::slave::docker::Image_Name* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> layer_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class Images : public ::google::protobuf::Message {
 public:
  Images();
  virtual ~Images();

  Images(const Images& from);

  inline Images& operator=(const Images& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Images& default_instance();

  void Swap(Images* other);

  // implements Message ----------------------------------------------

  Images* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Images& from);
  void MergeFrom(const Images& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.internal.slave.docker.Image images = 1;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 1;
  inline const ::mesos::internal::slave::docker::Image& images(int index) const;
  inline ::mesos::internal::slave::docker::Image* mutable_images(int index);
  inline ::mesos::internal::slave::docker::Image* add_images();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::Image >&
      images() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::Image >*
      mutable_images();

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.Images)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::Image > images_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static Images* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageManifest_FsLayers : public ::google::protobuf::Message {
 public:
  DockerImageManifest_FsLayers();
  virtual ~DockerImageManifest_FsLayers();

  DockerImageManifest_FsLayers(const DockerImageManifest_FsLayers& from);

  inline DockerImageManifest_FsLayers& operator=(const DockerImageManifest_FsLayers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageManifest_FsLayers& default_instance();

  void Swap(DockerImageManifest_FsLayers* other);

  // implements Message ----------------------------------------------

  DockerImageManifest_FsLayers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageManifest_FsLayers& from);
  void MergeFrom(const DockerImageManifest_FsLayers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string blobSum = 1;
  inline bool has_blobsum() const;
  inline void clear_blobsum();
  static const int kBlobSumFieldNumber = 1;
  inline const ::std::string& blobsum() const;
  inline void set_blobsum(const ::std::string& value);
  inline void set_blobsum(const char* value);
  inline void set_blobsum(const char* value, size_t size);
  inline ::std::string* mutable_blobsum();
  inline ::std::string* release_blobsum();
  inline void set_allocated_blobsum(::std::string* blobsum);

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.DockerImageManifest.FsLayers)
 private:
  inline void set_has_blobsum();
  inline void clear_has_blobsum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* blobsum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static DockerImageManifest_FsLayers* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageManifest_History_V1Compatibility : public ::google::protobuf::Message {
 public:
  DockerImageManifest_History_V1Compatibility();
  virtual ~DockerImageManifest_History_V1Compatibility();

  DockerImageManifest_History_V1Compatibility(const DockerImageManifest_History_V1Compatibility& from);

  inline DockerImageManifest_History_V1Compatibility& operator=(const DockerImageManifest_History_V1Compatibility& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageManifest_History_V1Compatibility& default_instance();

  void Swap(DockerImageManifest_History_V1Compatibility* other);

  // implements Message ----------------------------------------------

  DockerImageManifest_History_V1Compatibility* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageManifest_History_V1Compatibility& from);
  void MergeFrom(const DockerImageManifest_History_V1Compatibility& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline const ::std::string& parent() const;
  inline void set_parent(const ::std::string& value);
  inline void set_parent(const char* value);
  inline void set_parent(const char* value, size_t size);
  inline ::std::string* mutable_parent();
  inline ::std::string* release_parent();
  inline void set_allocated_parent(::std::string* parent);

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.DockerImageManifest.History.V1Compatibility)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* parent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static DockerImageManifest_History_V1Compatibility* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageManifest_History : public ::google::protobuf::Message {
 public:
  DockerImageManifest_History();
  virtual ~DockerImageManifest_History();

  DockerImageManifest_History(const DockerImageManifest_History& from);

  inline DockerImageManifest_History& operator=(const DockerImageManifest_History& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageManifest_History& default_instance();

  void Swap(DockerImageManifest_History* other);

  // implements Message ----------------------------------------------

  DockerImageManifest_History* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageManifest_History& from);
  void MergeFrom(const DockerImageManifest_History& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DockerImageManifest_History_V1Compatibility V1Compatibility;

  // accessors -------------------------------------------------------

  // required .mesos.internal.slave.docker.DockerImageManifest.History.V1Compatibility v1Compatibility = 1;
  inline bool has_v1compatibility() const;
  inline void clear_v1compatibility();
  static const int kV1CompatibilityFieldNumber = 1;
  inline const ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility& v1compatibility() const;
  inline ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility* mutable_v1compatibility();
  inline ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility* release_v1compatibility();
  inline void set_allocated_v1compatibility(::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility* v1compatibility);

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.DockerImageManifest.History)
 private:
  inline void set_has_v1compatibility();
  inline void clear_has_v1compatibility();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility* v1compatibility_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static DockerImageManifest_History* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageManifest_Signatures_Header_Jwk : public ::google::protobuf::Message {
 public:
  DockerImageManifest_Signatures_Header_Jwk();
  virtual ~DockerImageManifest_Signatures_Header_Jwk();

  DockerImageManifest_Signatures_Header_Jwk(const DockerImageManifest_Signatures_Header_Jwk& from);

  inline DockerImageManifest_Signatures_Header_Jwk& operator=(const DockerImageManifest_Signatures_Header_Jwk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageManifest_Signatures_Header_Jwk& default_instance();

  void Swap(DockerImageManifest_Signatures_Header_Jwk* other);

  // implements Message ----------------------------------------------

  DockerImageManifest_Signatures_Header_Jwk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageManifest_Signatures_Header_Jwk& from);
  void MergeFrom(const DockerImageManifest_Signatures_Header_Jwk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string crv = 1;
  inline bool has_crv() const;
  inline void clear_crv();
  static const int kCrvFieldNumber = 1;
  inline const ::std::string& crv() const;
  inline void set_crv(const ::std::string& value);
  inline void set_crv(const char* value);
  inline void set_crv(const char* value, size_t size);
  inline ::std::string* mutable_crv();
  inline ::std::string* release_crv();
  inline void set_allocated_crv(::std::string* crv);

  // required string kid = 2;
  inline bool has_kid() const;
  inline void clear_kid();
  static const int kKidFieldNumber = 2;
  inline const ::std::string& kid() const;
  inline void set_kid(const ::std::string& value);
  inline void set_kid(const char* value);
  inline void set_kid(const char* value, size_t size);
  inline ::std::string* mutable_kid();
  inline ::std::string* release_kid();
  inline void set_allocated_kid(::std::string* kid);

  // required string kty = 3;
  inline bool has_kty() const;
  inline void clear_kty();
  static const int kKtyFieldNumber = 3;
  inline const ::std::string& kty() const;
  inline void set_kty(const ::std::string& value);
  inline void set_kty(const char* value);
  inline void set_kty(const char* value, size_t size);
  inline ::std::string* mutable_kty();
  inline ::std::string* release_kty();
  inline void set_allocated_kty(::std::string* kty);

  // required string x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline const ::std::string& x() const;
  inline void set_x(const ::std::string& value);
  inline void set_x(const char* value);
  inline void set_x(const char* value, size_t size);
  inline ::std::string* mutable_x();
  inline ::std::string* release_x();
  inline void set_allocated_x(::std::string* x);

  // required string y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline const ::std::string& y() const;
  inline void set_y(const ::std::string& value);
  inline void set_y(const char* value);
  inline void set_y(const char* value, size_t size);
  inline ::std::string* mutable_y();
  inline ::std::string* release_y();
  inline void set_allocated_y(::std::string* y);

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.DockerImageManifest.Signatures.Header.Jwk)
 private:
  inline void set_has_crv();
  inline void clear_has_crv();
  inline void set_has_kid();
  inline void clear_has_kid();
  inline void set_has_kty();
  inline void clear_has_kty();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crv_;
  ::std::string* kid_;
  ::std::string* kty_;
  ::std::string* x_;
  ::std::string* y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static DockerImageManifest_Signatures_Header_Jwk* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageManifest_Signatures_Header : public ::google::protobuf::Message {
 public:
  DockerImageManifest_Signatures_Header();
  virtual ~DockerImageManifest_Signatures_Header();

  DockerImageManifest_Signatures_Header(const DockerImageManifest_Signatures_Header& from);

  inline DockerImageManifest_Signatures_Header& operator=(const DockerImageManifest_Signatures_Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageManifest_Signatures_Header& default_instance();

  void Swap(DockerImageManifest_Signatures_Header* other);

  // implements Message ----------------------------------------------

  DockerImageManifest_Signatures_Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageManifest_Signatures_Header& from);
  void MergeFrom(const DockerImageManifest_Signatures_Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DockerImageManifest_Signatures_Header_Jwk Jwk;

  // accessors -------------------------------------------------------

  // optional .mesos.internal.slave.docker.DockerImageManifest.Signatures.Header.Jwk jwk = 1;
  inline bool has_jwk() const;
  inline void clear_jwk();
  static const int kJwkFieldNumber = 1;
  inline const ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk& jwk() const;
  inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk* mutable_jwk();
  inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk* release_jwk();
  inline void set_allocated_jwk(::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk* jwk);

  // required string alg = 2;
  inline bool has_alg() const;
  inline void clear_alg();
  static const int kAlgFieldNumber = 2;
  inline const ::std::string& alg() const;
  inline void set_alg(const ::std::string& value);
  inline void set_alg(const char* value);
  inline void set_alg(const char* value, size_t size);
  inline ::std::string* mutable_alg();
  inline ::std::string* release_alg();
  inline void set_allocated_alg(::std::string* alg);

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.DockerImageManifest.Signatures.Header)
 private:
  inline void set_has_jwk();
  inline void clear_has_jwk();
  inline void set_has_alg();
  inline void clear_has_alg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk* jwk_;
  ::std::string* alg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static DockerImageManifest_Signatures_Header* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageManifest_Signatures : public ::google::protobuf::Message {
 public:
  DockerImageManifest_Signatures();
  virtual ~DockerImageManifest_Signatures();

  DockerImageManifest_Signatures(const DockerImageManifest_Signatures& from);

  inline DockerImageManifest_Signatures& operator=(const DockerImageManifest_Signatures& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageManifest_Signatures& default_instance();

  void Swap(DockerImageManifest_Signatures* other);

  // implements Message ----------------------------------------------

  DockerImageManifest_Signatures* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageManifest_Signatures& from);
  void MergeFrom(const DockerImageManifest_Signatures& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DockerImageManifest_Signatures_Header Header;

  // accessors -------------------------------------------------------

  // required .mesos.internal.slave.docker.DockerImageManifest.Signatures.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header& header() const;
  inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header* mutable_header();
  inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header* release_header();
  inline void set_allocated_header(::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header* header);

  // required string signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // required string protected = 3;
  inline bool has_protected_() const;
  inline void clear_protected_();
  static const int kProtectedFieldNumber = 3;
  inline const ::std::string& protected_() const;
  inline void set_protected_(const ::std::string& value);
  inline void set_protected_(const char* value);
  inline void set_protected_(const char* value, size_t size);
  inline ::std::string* mutable_protected_();
  inline ::std::string* release_protected_();
  inline void set_allocated_protected_(::std::string* protected_);

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.DockerImageManifest.Signatures)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_protected_();
  inline void clear_has_protected_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header* header_;
  ::std::string* signature_;
  ::std::string* protected__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static DockerImageManifest_Signatures* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageManifest : public ::google::protobuf::Message {
 public:
  DockerImageManifest();
  virtual ~DockerImageManifest();

  DockerImageManifest(const DockerImageManifest& from);

  inline DockerImageManifest& operator=(const DockerImageManifest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageManifest& default_instance();

  void Swap(DockerImageManifest* other);

  // implements Message ----------------------------------------------

  DockerImageManifest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageManifest& from);
  void MergeFrom(const DockerImageManifest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DockerImageManifest_FsLayers FsLayers;
  typedef DockerImageManifest_History History;
  typedef DockerImageManifest_Signatures Signatures;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // required string architecture = 3;
  inline bool has_architecture() const;
  inline void clear_architecture();
  static const int kArchitectureFieldNumber = 3;
  inline const ::std::string& architecture() const;
  inline void set_architecture(const ::std::string& value);
  inline void set_architecture(const char* value);
  inline void set_architecture(const char* value, size_t size);
  inline ::std::string* mutable_architecture();
  inline ::std::string* release_architecture();
  inline void set_allocated_architecture(::std::string* architecture);

  // repeated .mesos.internal.slave.docker.DockerImageManifest.FsLayers fsLayers = 4;
  inline int fslayers_size() const;
  inline void clear_fslayers();
  static const int kFsLayersFieldNumber = 4;
  inline const ::mesos::internal::slave::docker::DockerImageManifest_FsLayers& fslayers(int index) const;
  inline ::mesos::internal::slave::docker::DockerImageManifest_FsLayers* mutable_fslayers(int index);
  inline ::mesos::internal::slave::docker::DockerImageManifest_FsLayers* add_fslayers();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_FsLayers >&
      fslayers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_FsLayers >*
      mutable_fslayers();

  // repeated .mesos.internal.slave.docker.DockerImageManifest.History history = 5;
  inline int history_size() const;
  inline void clear_history();
  static const int kHistoryFieldNumber = 5;
  inline const ::mesos::internal::slave::docker::DockerImageManifest_History& history(int index) const;
  inline ::mesos::internal::slave::docker::DockerImageManifest_History* mutable_history(int index);
  inline ::mesos::internal::slave::docker::DockerImageManifest_History* add_history();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_History >&
      history() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_History >*
      mutable_history();

  // required uint32 schemaVersion = 6;
  inline bool has_schemaversion() const;
  inline void clear_schemaversion();
  static const int kSchemaVersionFieldNumber = 6;
  inline ::google::protobuf::uint32 schemaversion() const;
  inline void set_schemaversion(::google::protobuf::uint32 value);

  // repeated .mesos.internal.slave.docker.DockerImageManifest.Signatures signatures = 7;
  inline int signatures_size() const;
  inline void clear_signatures();
  static const int kSignaturesFieldNumber = 7;
  inline const ::mesos::internal::slave::docker::DockerImageManifest_Signatures& signatures(int index) const;
  inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures* mutable_signatures(int index);
  inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures* add_signatures();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_Signatures >&
      signatures() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_Signatures >*
      mutable_signatures();

  // @@protoc_insertion_point(class_scope:mesos.internal.slave.docker.DockerImageManifest)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_architecture();
  inline void clear_has_architecture();
  inline void set_has_schemaversion();
  inline void clear_has_schemaversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* tag_;
  ::std::string* architecture_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_FsLayers > fslayers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_History > history_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_Signatures > signatures_;
  ::google::protobuf::uint32 schemaversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_AssignDesc_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();
  friend void protobuf_ShutdownFile_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto();

  void InitAsDefaultInstance();
  static DockerImageManifest* default_instance_;
};
// ===================================================================


// ===================================================================

// Image_Name

// optional string registry = 1;
inline bool Image_Name::has_registry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image_Name::set_has_registry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image_Name::clear_has_registry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image_Name::clear_registry() {
  if (registry_ != &::google::protobuf::internal::kEmptyString) {
    registry_->clear();
  }
  clear_has_registry();
}
inline const ::std::string& Image_Name::registry() const {
  return *registry_;
}
inline void Image_Name::set_registry(const ::std::string& value) {
  set_has_registry();
  if (registry_ == &::google::protobuf::internal::kEmptyString) {
    registry_ = new ::std::string;
  }
  registry_->assign(value);
}
inline void Image_Name::set_registry(const char* value) {
  set_has_registry();
  if (registry_ == &::google::protobuf::internal::kEmptyString) {
    registry_ = new ::std::string;
  }
  registry_->assign(value);
}
inline void Image_Name::set_registry(const char* value, size_t size) {
  set_has_registry();
  if (registry_ == &::google::protobuf::internal::kEmptyString) {
    registry_ = new ::std::string;
  }
  registry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image_Name::mutable_registry() {
  set_has_registry();
  if (registry_ == &::google::protobuf::internal::kEmptyString) {
    registry_ = new ::std::string;
  }
  return registry_;
}
inline ::std::string* Image_Name::release_registry() {
  clear_has_registry();
  if (registry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = registry_;
    registry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image_Name::set_allocated_registry(::std::string* registry) {
  if (registry_ != &::google::protobuf::internal::kEmptyString) {
    delete registry_;
  }
  if (registry) {
    set_has_registry();
    registry_ = registry;
  } else {
    clear_has_registry();
    registry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string repository = 2;
inline bool Image_Name::has_repository() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image_Name::set_has_repository() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image_Name::clear_has_repository() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image_Name::clear_repository() {
  if (repository_ != &::google::protobuf::internal::kEmptyString) {
    repository_->clear();
  }
  clear_has_repository();
}
inline const ::std::string& Image_Name::repository() const {
  return *repository_;
}
inline void Image_Name::set_repository(const ::std::string& value) {
  set_has_repository();
  if (repository_ == &::google::protobuf::internal::kEmptyString) {
    repository_ = new ::std::string;
  }
  repository_->assign(value);
}
inline void Image_Name::set_repository(const char* value) {
  set_has_repository();
  if (repository_ == &::google::protobuf::internal::kEmptyString) {
    repository_ = new ::std::string;
  }
  repository_->assign(value);
}
inline void Image_Name::set_repository(const char* value, size_t size) {
  set_has_repository();
  if (repository_ == &::google::protobuf::internal::kEmptyString) {
    repository_ = new ::std::string;
  }
  repository_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image_Name::mutable_repository() {
  set_has_repository();
  if (repository_ == &::google::protobuf::internal::kEmptyString) {
    repository_ = new ::std::string;
  }
  return repository_;
}
inline ::std::string* Image_Name::release_repository() {
  clear_has_repository();
  if (repository_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = repository_;
    repository_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image_Name::set_allocated_repository(::std::string* repository) {
  if (repository_ != &::google::protobuf::internal::kEmptyString) {
    delete repository_;
  }
  if (repository) {
    set_has_repository();
    repository_ = repository;
  } else {
    clear_has_repository();
    repository_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string tag = 3;
inline bool Image_Name::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image_Name::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image_Name::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image_Name::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Image_Name::tag() const {
  return *tag_;
}
inline void Image_Name::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Image_Name::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Image_Name::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image_Name::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* Image_Name::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image_Name::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Image

// required .mesos.internal.slave.docker.Image.Name name = 1;
inline bool Image::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_name() {
  if (name_ != NULL) name_->::mesos::internal::slave::docker::Image_Name::Clear();
  clear_has_name();
}
inline const ::mesos::internal::slave::docker::Image_Name& Image::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::mesos::internal::slave::docker::Image_Name* Image::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::mesos::internal::slave::docker::Image_Name;
  return name_;
}
inline ::mesos::internal::slave::docker::Image_Name* Image::release_name() {
  clear_has_name();
  ::mesos::internal::slave::docker::Image_Name* temp = name_;
  name_ = NULL;
  return temp;
}
inline void Image::set_allocated_name(::mesos::internal::slave::docker::Image_Name* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// repeated string layer_ids = 2;
inline int Image::layer_ids_size() const {
  return layer_ids_.size();
}
inline void Image::clear_layer_ids() {
  layer_ids_.Clear();
}
inline const ::std::string& Image::layer_ids(int index) const {
  return layer_ids_.Get(index);
}
inline ::std::string* Image::mutable_layer_ids(int index) {
  return layer_ids_.Mutable(index);
}
inline void Image::set_layer_ids(int index, const ::std::string& value) {
  layer_ids_.Mutable(index)->assign(value);
}
inline void Image::set_layer_ids(int index, const char* value) {
  layer_ids_.Mutable(index)->assign(value);
}
inline void Image::set_layer_ids(int index, const char* value, size_t size) {
  layer_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::add_layer_ids() {
  return layer_ids_.Add();
}
inline void Image::add_layer_ids(const ::std::string& value) {
  layer_ids_.Add()->assign(value);
}
inline void Image::add_layer_ids(const char* value) {
  layer_ids_.Add()->assign(value);
}
inline void Image::add_layer_ids(const char* value, size_t size) {
  layer_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Image::layer_ids() const {
  return layer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Image::mutable_layer_ids() {
  return &layer_ids_;
}

// -------------------------------------------------------------------

// Images

// repeated .mesos.internal.slave.docker.Image images = 1;
inline int Images::images_size() const {
  return images_.size();
}
inline void Images::clear_images() {
  images_.Clear();
}
inline const ::mesos::internal::slave::docker::Image& Images::images(int index) const {
  return images_.Get(index);
}
inline ::mesos::internal::slave::docker::Image* Images::mutable_images(int index) {
  return images_.Mutable(index);
}
inline ::mesos::internal::slave::docker::Image* Images::add_images() {
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::Image >&
Images::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::Image >*
Images::mutable_images() {
  return &images_;
}

// -------------------------------------------------------------------

// DockerImageManifest_FsLayers

// required string blobSum = 1;
inline bool DockerImageManifest_FsLayers::has_blobsum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageManifest_FsLayers::set_has_blobsum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageManifest_FsLayers::clear_has_blobsum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageManifest_FsLayers::clear_blobsum() {
  if (blobsum_ != &::google::protobuf::internal::kEmptyString) {
    blobsum_->clear();
  }
  clear_has_blobsum();
}
inline const ::std::string& DockerImageManifest_FsLayers::blobsum() const {
  return *blobsum_;
}
inline void DockerImageManifest_FsLayers::set_blobsum(const ::std::string& value) {
  set_has_blobsum();
  if (blobsum_ == &::google::protobuf::internal::kEmptyString) {
    blobsum_ = new ::std::string;
  }
  blobsum_->assign(value);
}
inline void DockerImageManifest_FsLayers::set_blobsum(const char* value) {
  set_has_blobsum();
  if (blobsum_ == &::google::protobuf::internal::kEmptyString) {
    blobsum_ = new ::std::string;
  }
  blobsum_->assign(value);
}
inline void DockerImageManifest_FsLayers::set_blobsum(const char* value, size_t size) {
  set_has_blobsum();
  if (blobsum_ == &::google::protobuf::internal::kEmptyString) {
    blobsum_ = new ::std::string;
  }
  blobsum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_FsLayers::mutable_blobsum() {
  set_has_blobsum();
  if (blobsum_ == &::google::protobuf::internal::kEmptyString) {
    blobsum_ = new ::std::string;
  }
  return blobsum_;
}
inline ::std::string* DockerImageManifest_FsLayers::release_blobsum() {
  clear_has_blobsum();
  if (blobsum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = blobsum_;
    blobsum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_FsLayers::set_allocated_blobsum(::std::string* blobsum) {
  if (blobsum_ != &::google::protobuf::internal::kEmptyString) {
    delete blobsum_;
  }
  if (blobsum) {
    set_has_blobsum();
    blobsum_ = blobsum;
  } else {
    clear_has_blobsum();
    blobsum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DockerImageManifest_History_V1Compatibility

// required string id = 1;
inline bool DockerImageManifest_History_V1Compatibility::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageManifest_History_V1Compatibility::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageManifest_History_V1Compatibility::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageManifest_History_V1Compatibility::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& DockerImageManifest_History_V1Compatibility::id() const {
  return *id_;
}
inline void DockerImageManifest_History_V1Compatibility::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DockerImageManifest_History_V1Compatibility::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DockerImageManifest_History_V1Compatibility::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_History_V1Compatibility::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* DockerImageManifest_History_V1Compatibility::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_History_V1Compatibility::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string parent = 2;
inline bool DockerImageManifest_History_V1Compatibility::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DockerImageManifest_History_V1Compatibility::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DockerImageManifest_History_V1Compatibility::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DockerImageManifest_History_V1Compatibility::clear_parent() {
  if (parent_ != &::google::protobuf::internal::kEmptyString) {
    parent_->clear();
  }
  clear_has_parent();
}
inline const ::std::string& DockerImageManifest_History_V1Compatibility::parent() const {
  return *parent_;
}
inline void DockerImageManifest_History_V1Compatibility::set_parent(const ::std::string& value) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    parent_ = new ::std::string;
  }
  parent_->assign(value);
}
inline void DockerImageManifest_History_V1Compatibility::set_parent(const char* value) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    parent_ = new ::std::string;
  }
  parent_->assign(value);
}
inline void DockerImageManifest_History_V1Compatibility::set_parent(const char* value, size_t size) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    parent_ = new ::std::string;
  }
  parent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_History_V1Compatibility::mutable_parent() {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    parent_ = new ::std::string;
  }
  return parent_;
}
inline ::std::string* DockerImageManifest_History_V1Compatibility::release_parent() {
  clear_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parent_;
    parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_History_V1Compatibility::set_allocated_parent(::std::string* parent) {
  if (parent_ != &::google::protobuf::internal::kEmptyString) {
    delete parent_;
  }
  if (parent) {
    set_has_parent();
    parent_ = parent;
  } else {
    clear_has_parent();
    parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DockerImageManifest_History

// required .mesos.internal.slave.docker.DockerImageManifest.History.V1Compatibility v1Compatibility = 1;
inline bool DockerImageManifest_History::has_v1compatibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageManifest_History::set_has_v1compatibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageManifest_History::clear_has_v1compatibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageManifest_History::clear_v1compatibility() {
  if (v1compatibility_ != NULL) v1compatibility_->::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility::Clear();
  clear_has_v1compatibility();
}
inline const ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility& DockerImageManifest_History::v1compatibility() const {
  return v1compatibility_ != NULL ? *v1compatibility_ : *default_instance_->v1compatibility_;
}
inline ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility* DockerImageManifest_History::mutable_v1compatibility() {
  set_has_v1compatibility();
  if (v1compatibility_ == NULL) v1compatibility_ = new ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility;
  return v1compatibility_;
}
inline ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility* DockerImageManifest_History::release_v1compatibility() {
  clear_has_v1compatibility();
  ::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility* temp = v1compatibility_;
  v1compatibility_ = NULL;
  return temp;
}
inline void DockerImageManifest_History::set_allocated_v1compatibility(::mesos::internal::slave::docker::DockerImageManifest_History_V1Compatibility* v1compatibility) {
  delete v1compatibility_;
  v1compatibility_ = v1compatibility;
  if (v1compatibility) {
    set_has_v1compatibility();
  } else {
    clear_has_v1compatibility();
  }
}

// -------------------------------------------------------------------

// DockerImageManifest_Signatures_Header_Jwk

// required string crv = 1;
inline bool DockerImageManifest_Signatures_Header_Jwk::has_crv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_has_crv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_has_crv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_crv() {
  if (crv_ != &::google::protobuf::internal::kEmptyString) {
    crv_->clear();
  }
  clear_has_crv();
}
inline const ::std::string& DockerImageManifest_Signatures_Header_Jwk::crv() const {
  return *crv_;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_crv(const ::std::string& value) {
  set_has_crv();
  if (crv_ == &::google::protobuf::internal::kEmptyString) {
    crv_ = new ::std::string;
  }
  crv_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_crv(const char* value) {
  set_has_crv();
  if (crv_ == &::google::protobuf::internal::kEmptyString) {
    crv_ = new ::std::string;
  }
  crv_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_crv(const char* value, size_t size) {
  set_has_crv();
  if (crv_ == &::google::protobuf::internal::kEmptyString) {
    crv_ = new ::std::string;
  }
  crv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::mutable_crv() {
  set_has_crv();
  if (crv_ == &::google::protobuf::internal::kEmptyString) {
    crv_ = new ::std::string;
  }
  return crv_;
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::release_crv() {
  clear_has_crv();
  if (crv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crv_;
    crv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_allocated_crv(::std::string* crv) {
  if (crv_ != &::google::protobuf::internal::kEmptyString) {
    delete crv_;
  }
  if (crv) {
    set_has_crv();
    crv_ = crv;
  } else {
    clear_has_crv();
    crv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string kid = 2;
inline bool DockerImageManifest_Signatures_Header_Jwk::has_kid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_has_kid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_has_kid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_kid() {
  if (kid_ != &::google::protobuf::internal::kEmptyString) {
    kid_->clear();
  }
  clear_has_kid();
}
inline const ::std::string& DockerImageManifest_Signatures_Header_Jwk::kid() const {
  return *kid_;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_kid(const ::std::string& value) {
  set_has_kid();
  if (kid_ == &::google::protobuf::internal::kEmptyString) {
    kid_ = new ::std::string;
  }
  kid_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_kid(const char* value) {
  set_has_kid();
  if (kid_ == &::google::protobuf::internal::kEmptyString) {
    kid_ = new ::std::string;
  }
  kid_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_kid(const char* value, size_t size) {
  set_has_kid();
  if (kid_ == &::google::protobuf::internal::kEmptyString) {
    kid_ = new ::std::string;
  }
  kid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::mutable_kid() {
  set_has_kid();
  if (kid_ == &::google::protobuf::internal::kEmptyString) {
    kid_ = new ::std::string;
  }
  return kid_;
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::release_kid() {
  clear_has_kid();
  if (kid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kid_;
    kid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_allocated_kid(::std::string* kid) {
  if (kid_ != &::google::protobuf::internal::kEmptyString) {
    delete kid_;
  }
  if (kid) {
    set_has_kid();
    kid_ = kid;
  } else {
    clear_has_kid();
    kid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string kty = 3;
inline bool DockerImageManifest_Signatures_Header_Jwk::has_kty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_has_kty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_has_kty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_kty() {
  if (kty_ != &::google::protobuf::internal::kEmptyString) {
    kty_->clear();
  }
  clear_has_kty();
}
inline const ::std::string& DockerImageManifest_Signatures_Header_Jwk::kty() const {
  return *kty_;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_kty(const ::std::string& value) {
  set_has_kty();
  if (kty_ == &::google::protobuf::internal::kEmptyString) {
    kty_ = new ::std::string;
  }
  kty_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_kty(const char* value) {
  set_has_kty();
  if (kty_ == &::google::protobuf::internal::kEmptyString) {
    kty_ = new ::std::string;
  }
  kty_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_kty(const char* value, size_t size) {
  set_has_kty();
  if (kty_ == &::google::protobuf::internal::kEmptyString) {
    kty_ = new ::std::string;
  }
  kty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::mutable_kty() {
  set_has_kty();
  if (kty_ == &::google::protobuf::internal::kEmptyString) {
    kty_ = new ::std::string;
  }
  return kty_;
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::release_kty() {
  clear_has_kty();
  if (kty_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kty_;
    kty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_allocated_kty(::std::string* kty) {
  if (kty_ != &::google::protobuf::internal::kEmptyString) {
    delete kty_;
  }
  if (kty) {
    set_has_kty();
    kty_ = kty;
  } else {
    clear_has_kty();
    kty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string x = 4;
inline bool DockerImageManifest_Signatures_Header_Jwk::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_x() {
  if (x_ != &::google::protobuf::internal::kEmptyString) {
    x_->clear();
  }
  clear_has_x();
}
inline const ::std::string& DockerImageManifest_Signatures_Header_Jwk::x() const {
  return *x_;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_x(const ::std::string& value) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_x(const char* value) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_x(const char* value, size_t size) {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  x_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::mutable_x() {
  set_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    x_ = new ::std::string;
  }
  return x_;
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::release_x() {
  clear_has_x();
  if (x_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = x_;
    x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_allocated_x(::std::string* x) {
  if (x_ != &::google::protobuf::internal::kEmptyString) {
    delete x_;
  }
  if (x) {
    set_has_x();
    x_ = x;
  } else {
    clear_has_x();
    x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string y = 5;
inline bool DockerImageManifest_Signatures_Header_Jwk::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DockerImageManifest_Signatures_Header_Jwk::clear_y() {
  if (y_ != &::google::protobuf::internal::kEmptyString) {
    y_->clear();
  }
  clear_has_y();
}
inline const ::std::string& DockerImageManifest_Signatures_Header_Jwk::y() const {
  return *y_;
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_y(const ::std::string& value) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_y(const char* value) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(value);
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_y(const char* value, size_t size) {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  y_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::mutable_y() {
  set_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    y_ = new ::std::string;
  }
  return y_;
}
inline ::std::string* DockerImageManifest_Signatures_Header_Jwk::release_y() {
  clear_has_y();
  if (y_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = y_;
    y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_Signatures_Header_Jwk::set_allocated_y(::std::string* y) {
  if (y_ != &::google::protobuf::internal::kEmptyString) {
    delete y_;
  }
  if (y) {
    set_has_y();
    y_ = y;
  } else {
    clear_has_y();
    y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DockerImageManifest_Signatures_Header

// optional .mesos.internal.slave.docker.DockerImageManifest.Signatures.Header.Jwk jwk = 1;
inline bool DockerImageManifest_Signatures_Header::has_jwk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageManifest_Signatures_Header::set_has_jwk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageManifest_Signatures_Header::clear_has_jwk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageManifest_Signatures_Header::clear_jwk() {
  if (jwk_ != NULL) jwk_->::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk::Clear();
  clear_has_jwk();
}
inline const ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk& DockerImageManifest_Signatures_Header::jwk() const {
  return jwk_ != NULL ? *jwk_ : *default_instance_->jwk_;
}
inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk* DockerImageManifest_Signatures_Header::mutable_jwk() {
  set_has_jwk();
  if (jwk_ == NULL) jwk_ = new ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk;
  return jwk_;
}
inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk* DockerImageManifest_Signatures_Header::release_jwk() {
  clear_has_jwk();
  ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk* temp = jwk_;
  jwk_ = NULL;
  return temp;
}
inline void DockerImageManifest_Signatures_Header::set_allocated_jwk(::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header_Jwk* jwk) {
  delete jwk_;
  jwk_ = jwk;
  if (jwk) {
    set_has_jwk();
  } else {
    clear_has_jwk();
  }
}

// required string alg = 2;
inline bool DockerImageManifest_Signatures_Header::has_alg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DockerImageManifest_Signatures_Header::set_has_alg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DockerImageManifest_Signatures_Header::clear_has_alg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DockerImageManifest_Signatures_Header::clear_alg() {
  if (alg_ != &::google::protobuf::internal::kEmptyString) {
    alg_->clear();
  }
  clear_has_alg();
}
inline const ::std::string& DockerImageManifest_Signatures_Header::alg() const {
  return *alg_;
}
inline void DockerImageManifest_Signatures_Header::set_alg(const ::std::string& value) {
  set_has_alg();
  if (alg_ == &::google::protobuf::internal::kEmptyString) {
    alg_ = new ::std::string;
  }
  alg_->assign(value);
}
inline void DockerImageManifest_Signatures_Header::set_alg(const char* value) {
  set_has_alg();
  if (alg_ == &::google::protobuf::internal::kEmptyString) {
    alg_ = new ::std::string;
  }
  alg_->assign(value);
}
inline void DockerImageManifest_Signatures_Header::set_alg(const char* value, size_t size) {
  set_has_alg();
  if (alg_ == &::google::protobuf::internal::kEmptyString) {
    alg_ = new ::std::string;
  }
  alg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_Signatures_Header::mutable_alg() {
  set_has_alg();
  if (alg_ == &::google::protobuf::internal::kEmptyString) {
    alg_ = new ::std::string;
  }
  return alg_;
}
inline ::std::string* DockerImageManifest_Signatures_Header::release_alg() {
  clear_has_alg();
  if (alg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alg_;
    alg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_Signatures_Header::set_allocated_alg(::std::string* alg) {
  if (alg_ != &::google::protobuf::internal::kEmptyString) {
    delete alg_;
  }
  if (alg) {
    set_has_alg();
    alg_ = alg;
  } else {
    clear_has_alg();
    alg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DockerImageManifest_Signatures

// required .mesos.internal.slave.docker.DockerImageManifest.Signatures.Header header = 1;
inline bool DockerImageManifest_Signatures::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageManifest_Signatures::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageManifest_Signatures::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageManifest_Signatures::clear_header() {
  if (header_ != NULL) header_->::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header::Clear();
  clear_has_header();
}
inline const ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header& DockerImageManifest_Signatures::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header* DockerImageManifest_Signatures::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header;
  return header_;
}
inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header* DockerImageManifest_Signatures::release_header() {
  clear_has_header();
  ::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DockerImageManifest_Signatures::set_allocated_header(::mesos::internal::slave::docker::DockerImageManifest_Signatures_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required string signature = 2;
inline bool DockerImageManifest_Signatures::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DockerImageManifest_Signatures::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DockerImageManifest_Signatures::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DockerImageManifest_Signatures::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& DockerImageManifest_Signatures::signature() const {
  return *signature_;
}
inline void DockerImageManifest_Signatures::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void DockerImageManifest_Signatures::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void DockerImageManifest_Signatures::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_Signatures::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* DockerImageManifest_Signatures::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_Signatures::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string protected = 3;
inline bool DockerImageManifest_Signatures::has_protected_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DockerImageManifest_Signatures::set_has_protected_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DockerImageManifest_Signatures::clear_has_protected_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DockerImageManifest_Signatures::clear_protected_() {
  if (protected__ != &::google::protobuf::internal::kEmptyString) {
    protected__->clear();
  }
  clear_has_protected_();
}
inline const ::std::string& DockerImageManifest_Signatures::protected_() const {
  return *protected__;
}
inline void DockerImageManifest_Signatures::set_protected_(const ::std::string& value) {
  set_has_protected_();
  if (protected__ == &::google::protobuf::internal::kEmptyString) {
    protected__ = new ::std::string;
  }
  protected__->assign(value);
}
inline void DockerImageManifest_Signatures::set_protected_(const char* value) {
  set_has_protected_();
  if (protected__ == &::google::protobuf::internal::kEmptyString) {
    protected__ = new ::std::string;
  }
  protected__->assign(value);
}
inline void DockerImageManifest_Signatures::set_protected_(const char* value, size_t size) {
  set_has_protected_();
  if (protected__ == &::google::protobuf::internal::kEmptyString) {
    protected__ = new ::std::string;
  }
  protected__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest_Signatures::mutable_protected_() {
  set_has_protected_();
  if (protected__ == &::google::protobuf::internal::kEmptyString) {
    protected__ = new ::std::string;
  }
  return protected__;
}
inline ::std::string* DockerImageManifest_Signatures::release_protected_() {
  clear_has_protected_();
  if (protected__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protected__;
    protected__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest_Signatures::set_allocated_protected_(::std::string* protected_) {
  if (protected__ != &::google::protobuf::internal::kEmptyString) {
    delete protected__;
  }
  if (protected_) {
    set_has_protected_();
    protected__ = protected_;
  } else {
    clear_has_protected_();
    protected__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DockerImageManifest

// required string name = 1;
inline bool DockerImageManifest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageManifest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageManifest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageManifest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DockerImageManifest::name() const {
  return *name_;
}
inline void DockerImageManifest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DockerImageManifest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DockerImageManifest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DockerImageManifest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string tag = 2;
inline bool DockerImageManifest::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DockerImageManifest::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DockerImageManifest::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DockerImageManifest::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& DockerImageManifest::tag() const {
  return *tag_;
}
inline void DockerImageManifest::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void DockerImageManifest::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void DockerImageManifest::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* DockerImageManifest::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string architecture = 3;
inline bool DockerImageManifest::has_architecture() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DockerImageManifest::set_has_architecture() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DockerImageManifest::clear_has_architecture() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DockerImageManifest::clear_architecture() {
  if (architecture_ != &::google::protobuf::internal::kEmptyString) {
    architecture_->clear();
  }
  clear_has_architecture();
}
inline const ::std::string& DockerImageManifest::architecture() const {
  return *architecture_;
}
inline void DockerImageManifest::set_architecture(const ::std::string& value) {
  set_has_architecture();
  if (architecture_ == &::google::protobuf::internal::kEmptyString) {
    architecture_ = new ::std::string;
  }
  architecture_->assign(value);
}
inline void DockerImageManifest::set_architecture(const char* value) {
  set_has_architecture();
  if (architecture_ == &::google::protobuf::internal::kEmptyString) {
    architecture_ = new ::std::string;
  }
  architecture_->assign(value);
}
inline void DockerImageManifest::set_architecture(const char* value, size_t size) {
  set_has_architecture();
  if (architecture_ == &::google::protobuf::internal::kEmptyString) {
    architecture_ = new ::std::string;
  }
  architecture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageManifest::mutable_architecture() {
  set_has_architecture();
  if (architecture_ == &::google::protobuf::internal::kEmptyString) {
    architecture_ = new ::std::string;
  }
  return architecture_;
}
inline ::std::string* DockerImageManifest::release_architecture() {
  clear_has_architecture();
  if (architecture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = architecture_;
    architecture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DockerImageManifest::set_allocated_architecture(::std::string* architecture) {
  if (architecture_ != &::google::protobuf::internal::kEmptyString) {
    delete architecture_;
  }
  if (architecture) {
    set_has_architecture();
    architecture_ = architecture;
  } else {
    clear_has_architecture();
    architecture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mesos.internal.slave.docker.DockerImageManifest.FsLayers fsLayers = 4;
inline int DockerImageManifest::fslayers_size() const {
  return fslayers_.size();
}
inline void DockerImageManifest::clear_fslayers() {
  fslayers_.Clear();
}
inline const ::mesos::internal::slave::docker::DockerImageManifest_FsLayers& DockerImageManifest::fslayers(int index) const {
  return fslayers_.Get(index);
}
inline ::mesos::internal::slave::docker::DockerImageManifest_FsLayers* DockerImageManifest::mutable_fslayers(int index) {
  return fslayers_.Mutable(index);
}
inline ::mesos::internal::slave::docker::DockerImageManifest_FsLayers* DockerImageManifest::add_fslayers() {
  return fslayers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_FsLayers >&
DockerImageManifest::fslayers() const {
  return fslayers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_FsLayers >*
DockerImageManifest::mutable_fslayers() {
  return &fslayers_;
}

// repeated .mesos.internal.slave.docker.DockerImageManifest.History history = 5;
inline int DockerImageManifest::history_size() const {
  return history_.size();
}
inline void DockerImageManifest::clear_history() {
  history_.Clear();
}
inline const ::mesos::internal::slave::docker::DockerImageManifest_History& DockerImageManifest::history(int index) const {
  return history_.Get(index);
}
inline ::mesos::internal::slave::docker::DockerImageManifest_History* DockerImageManifest::mutable_history(int index) {
  return history_.Mutable(index);
}
inline ::mesos::internal::slave::docker::DockerImageManifest_History* DockerImageManifest::add_history() {
  return history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_History >&
DockerImageManifest::history() const {
  return history_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_History >*
DockerImageManifest::mutable_history() {
  return &history_;
}

// required uint32 schemaVersion = 6;
inline bool DockerImageManifest::has_schemaversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DockerImageManifest::set_has_schemaversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DockerImageManifest::clear_has_schemaversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DockerImageManifest::clear_schemaversion() {
  schemaversion_ = 0u;
  clear_has_schemaversion();
}
inline ::google::protobuf::uint32 DockerImageManifest::schemaversion() const {
  return schemaversion_;
}
inline void DockerImageManifest::set_schemaversion(::google::protobuf::uint32 value) {
  set_has_schemaversion();
  schemaversion_ = value;
}

// repeated .mesos.internal.slave.docker.DockerImageManifest.Signatures signatures = 7;
inline int DockerImageManifest::signatures_size() const {
  return signatures_.size();
}
inline void DockerImageManifest::clear_signatures() {
  signatures_.Clear();
}
inline const ::mesos::internal::slave::docker::DockerImageManifest_Signatures& DockerImageManifest::signatures(int index) const {
  return signatures_.Get(index);
}
inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures* DockerImageManifest::mutable_signatures(int index) {
  return signatures_.Mutable(index);
}
inline ::mesos::internal::slave::docker::DockerImageManifest_Signatures* DockerImageManifest::add_signatures() {
  return signatures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_Signatures >&
DockerImageManifest::signatures() const {
  return signatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::slave::docker::DockerImageManifest_Signatures >*
DockerImageManifest::mutable_signatures() {
  return &signatures_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace docker
}  // namespace slave
}  // namespace internal
}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_slave_2fcontainerizer_2fprovisioner_2fdocker_2fmessage_2eproto__INCLUDED
