// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: master/registry.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "master/registry.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mesos {
namespace internal {

namespace {

const ::google::protobuf::Descriptor* Registry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Registry_reflection_ = NULL;
const ::google::protobuf::Descriptor* Registry_Master_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Registry_Master_reflection_ = NULL;
const ::google::protobuf::Descriptor* Registry_Slave_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Registry_Slave_reflection_ = NULL;
const ::google::protobuf::Descriptor* Registry_Slaves_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Registry_Slaves_reflection_ = NULL;
const ::google::protobuf::Descriptor* Registry_Machine_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Registry_Machine_reflection_ = NULL;
const ::google::protobuf::Descriptor* Registry_Machines_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Registry_Machines_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_master_2fregistry_2eproto() {
  protobuf_AddDesc_master_2fregistry_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "master/registry.proto");
  GOOGLE_CHECK(file != NULL);
  Registry_descriptor_ = file->message_type(0);
  static const int Registry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry, master_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry, slaves_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry, machines_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry, schedules_),
  };
  Registry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Registry_descriptor_,
      Registry::default_instance_,
      Registry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Registry));
  Registry_Master_descriptor_ = Registry_descriptor_->nested_type(0);
  static const int Registry_Master_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Master, info_),
  };
  Registry_Master_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Registry_Master_descriptor_,
      Registry_Master::default_instance_,
      Registry_Master_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Master, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Master, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Registry_Master));
  Registry_Slave_descriptor_ = Registry_descriptor_->nested_type(1);
  static const int Registry_Slave_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Slave, info_),
  };
  Registry_Slave_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Registry_Slave_descriptor_,
      Registry_Slave::default_instance_,
      Registry_Slave_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Slave, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Slave, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Registry_Slave));
  Registry_Slaves_descriptor_ = Registry_descriptor_->nested_type(2);
  static const int Registry_Slaves_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Slaves, slaves_),
  };
  Registry_Slaves_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Registry_Slaves_descriptor_,
      Registry_Slaves::default_instance_,
      Registry_Slaves_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Slaves, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Slaves, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Registry_Slaves));
  Registry_Machine_descriptor_ = Registry_descriptor_->nested_type(3);
  static const int Registry_Machine_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Machine, info_),
  };
  Registry_Machine_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Registry_Machine_descriptor_,
      Registry_Machine::default_instance_,
      Registry_Machine_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Machine, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Machine, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Registry_Machine));
  Registry_Machines_descriptor_ = Registry_descriptor_->nested_type(4);
  static const int Registry_Machines_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Machines, machines_),
  };
  Registry_Machines_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Registry_Machines_descriptor_,
      Registry_Machines::default_instance_,
      Registry_Machines_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Machines, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Registry_Machines, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Registry_Machines));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_master_2fregistry_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Registry_descriptor_, &Registry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Registry_Master_descriptor_, &Registry_Master::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Registry_Slave_descriptor_, &Registry_Slave::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Registry_Slaves_descriptor_, &Registry_Slaves::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Registry_Machine_descriptor_, &Registry_Machine::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Registry_Machines_descriptor_, &Registry_Machines::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_master_2fregistry_2eproto() {
  delete Registry::default_instance_;
  delete Registry_reflection_;
  delete Registry_Master::default_instance_;
  delete Registry_Master_reflection_;
  delete Registry_Slave::default_instance_;
  delete Registry_Slave_reflection_;
  delete Registry_Slaves::default_instance_;
  delete Registry_Slaves_reflection_;
  delete Registry_Machine::default_instance_;
  delete Registry_Machine_reflection_;
  delete Registry_Machines::default_instance_;
  delete Registry_Machines_reflection_;
}

void protobuf_AddDesc_master_2fregistry_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mesos::protobuf_AddDesc_mesos_2fmesos_2eproto();
  ::mesos::maintenance::protobuf_AddDesc_mesos_2fmaintenance_2fmaintenance_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\025master/registry.proto\022\016mesos.internal\032"
    "\021mesos/mesos.proto\032#mesos/maintenance/ma"
    "intenance.proto\"\314\003\n\010Registry\022/\n\006master\030\001"
    " \001(\0132\037.mesos.internal.Registry.Master\022/\n"
    "\006slaves\030\002 \001(\0132\037.mesos.internal.Registry."
    "Slaves\0223\n\010machines\030\003 \001(\0132!.mesos.interna"
    "l.Registry.Machines\022.\n\tschedules\030\004 \003(\0132\033"
    ".mesos.maintenance.Schedule\032)\n\006Master\022\037\n"
    "\004info\030\001 \002(\0132\021.mesos.MasterInfo\032\'\n\005Slave\022"
    "\036\n\004info\030\001 \002(\0132\020.mesos.SlaveInfo\0328\n\006Slave"
    "s\022.\n\006slaves\030\001 \003(\0132\036.mesos.internal.Regis"
    "try.Slave\032+\n\007Machine\022 \n\004info\030\001 \002(\0132\022.mes"
    "os.MachineInfo\032>\n\010Machines\0222\n\010machines\030\001"
    " \003(\0132 .mesos.internal.Registry.Machine", 558);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "master/registry.proto", &protobuf_RegisterTypes);
  Registry::default_instance_ = new Registry();
  Registry_Master::default_instance_ = new Registry_Master();
  Registry_Slave::default_instance_ = new Registry_Slave();
  Registry_Slaves::default_instance_ = new Registry_Slaves();
  Registry_Machine::default_instance_ = new Registry_Machine();
  Registry_Machines::default_instance_ = new Registry_Machines();
  Registry::default_instance_->InitAsDefaultInstance();
  Registry_Master::default_instance_->InitAsDefaultInstance();
  Registry_Slave::default_instance_->InitAsDefaultInstance();
  Registry_Slaves::default_instance_->InitAsDefaultInstance();
  Registry_Machine::default_instance_->InitAsDefaultInstance();
  Registry_Machines::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_master_2fregistry_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_master_2fregistry_2eproto {
  StaticDescriptorInitializer_master_2fregistry_2eproto() {
    protobuf_AddDesc_master_2fregistry_2eproto();
  }
} static_descriptor_initializer_master_2fregistry_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Registry_Master::kInfoFieldNumber;
#endif  // !_MSC_VER

Registry_Master::Registry_Master()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Registry_Master::InitAsDefaultInstance() {
  info_ = const_cast< ::mesos::MasterInfo*>(&::mesos::MasterInfo::default_instance());
}

Registry_Master::Registry_Master(const Registry_Master& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Registry_Master::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Registry_Master::~Registry_Master() {
  SharedDtor();
}

void Registry_Master::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void Registry_Master::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Registry_Master::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Registry_Master_descriptor_;
}

const Registry_Master& Registry_Master::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_master_2fregistry_2eproto();
  return *default_instance_;
}

Registry_Master* Registry_Master::default_instance_ = NULL;

Registry_Master* Registry_Master::New() const {
  return new Registry_Master;
}

void Registry_Master::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_info()) {
      if (info_ != NULL) info_->::mesos::MasterInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Registry_Master::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.MasterInfo info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Registry_Master::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.MasterInfo info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Registry_Master::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.MasterInfo info = 1;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Registry_Master::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.MasterInfo info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Registry_Master::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Registry_Master* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Registry_Master*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Registry_Master::MergeFrom(const Registry_Master& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::mesos::MasterInfo::MergeFrom(from.info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Registry_Master::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Registry_Master::CopyFrom(const Registry_Master& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Registry_Master::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void Registry_Master::Swap(Registry_Master* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Registry_Master::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Registry_Master_descriptor_;
  metadata.reflection = Registry_Master_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Registry_Slave::kInfoFieldNumber;
#endif  // !_MSC_VER

Registry_Slave::Registry_Slave()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Registry_Slave::InitAsDefaultInstance() {
  info_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

Registry_Slave::Registry_Slave(const Registry_Slave& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Registry_Slave::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Registry_Slave::~Registry_Slave() {
  SharedDtor();
}

void Registry_Slave::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void Registry_Slave::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Registry_Slave::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Registry_Slave_descriptor_;
}

const Registry_Slave& Registry_Slave::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_master_2fregistry_2eproto();
  return *default_instance_;
}

Registry_Slave* Registry_Slave::default_instance_ = NULL;

Registry_Slave* Registry_Slave::New() const {
  return new Registry_Slave;
}

void Registry_Slave::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_info()) {
      if (info_ != NULL) info_->::mesos::SlaveInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Registry_Slave::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveInfo info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Registry_Slave::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveInfo info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Registry_Slave::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveInfo info = 1;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Registry_Slave::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveInfo info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Registry_Slave::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Registry_Slave* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Registry_Slave*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Registry_Slave::MergeFrom(const Registry_Slave& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::mesos::SlaveInfo::MergeFrom(from.info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Registry_Slave::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Registry_Slave::CopyFrom(const Registry_Slave& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Registry_Slave::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void Registry_Slave::Swap(Registry_Slave* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Registry_Slave::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Registry_Slave_descriptor_;
  metadata.reflection = Registry_Slave_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Registry_Slaves::kSlavesFieldNumber;
#endif  // !_MSC_VER

Registry_Slaves::Registry_Slaves()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Registry_Slaves::InitAsDefaultInstance() {
}

Registry_Slaves::Registry_Slaves(const Registry_Slaves& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Registry_Slaves::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Registry_Slaves::~Registry_Slaves() {
  SharedDtor();
}

void Registry_Slaves::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Registry_Slaves::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Registry_Slaves::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Registry_Slaves_descriptor_;
}

const Registry_Slaves& Registry_Slaves::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_master_2fregistry_2eproto();
  return *default_instance_;
}

Registry_Slaves* Registry_Slaves::default_instance_ = NULL;

Registry_Slaves* Registry_Slaves::New() const {
  return new Registry_Slaves;
}

void Registry_Slaves::Clear() {
  slaves_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Registry_Slaves::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.internal.Registry.Slave slaves = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slaves:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_slaves()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_slaves;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Registry_Slaves::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.internal.Registry.Slave slaves = 1;
  for (int i = 0; i < this->slaves_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slaves(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Registry_Slaves::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.internal.Registry.Slave slaves = 1;
  for (int i = 0; i < this->slaves_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slaves(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Registry_Slaves::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.internal.Registry.Slave slaves = 1;
  total_size += 1 * this->slaves_size();
  for (int i = 0; i < this->slaves_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->slaves(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Registry_Slaves::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Registry_Slaves* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Registry_Slaves*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Registry_Slaves::MergeFrom(const Registry_Slaves& from) {
  GOOGLE_CHECK_NE(&from, this);
  slaves_.MergeFrom(from.slaves_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Registry_Slaves::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Registry_Slaves::CopyFrom(const Registry_Slaves& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Registry_Slaves::IsInitialized() const {

  for (int i = 0; i < slaves_size(); i++) {
    if (!this->slaves(i).IsInitialized()) return false;
  }
  return true;
}

void Registry_Slaves::Swap(Registry_Slaves* other) {
  if (other != this) {
    slaves_.Swap(&other->slaves_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Registry_Slaves::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Registry_Slaves_descriptor_;
  metadata.reflection = Registry_Slaves_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Registry_Machine::kInfoFieldNumber;
#endif  // !_MSC_VER

Registry_Machine::Registry_Machine()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Registry_Machine::InitAsDefaultInstance() {
  info_ = const_cast< ::mesos::MachineInfo*>(&::mesos::MachineInfo::default_instance());
}

Registry_Machine::Registry_Machine(const Registry_Machine& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Registry_Machine::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Registry_Machine::~Registry_Machine() {
  SharedDtor();
}

void Registry_Machine::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void Registry_Machine::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Registry_Machine::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Registry_Machine_descriptor_;
}

const Registry_Machine& Registry_Machine::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_master_2fregistry_2eproto();
  return *default_instance_;
}

Registry_Machine* Registry_Machine::default_instance_ = NULL;

Registry_Machine* Registry_Machine::New() const {
  return new Registry_Machine;
}

void Registry_Machine::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_info()) {
      if (info_ != NULL) info_->::mesos::MachineInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Registry_Machine::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.MachineInfo info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Registry_Machine::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.MachineInfo info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Registry_Machine::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.MachineInfo info = 1;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Registry_Machine::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.MachineInfo info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Registry_Machine::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Registry_Machine* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Registry_Machine*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Registry_Machine::MergeFrom(const Registry_Machine& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::mesos::MachineInfo::MergeFrom(from.info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Registry_Machine::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Registry_Machine::CopyFrom(const Registry_Machine& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Registry_Machine::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void Registry_Machine::Swap(Registry_Machine* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Registry_Machine::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Registry_Machine_descriptor_;
  metadata.reflection = Registry_Machine_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Registry_Machines::kMachinesFieldNumber;
#endif  // !_MSC_VER

Registry_Machines::Registry_Machines()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Registry_Machines::InitAsDefaultInstance() {
}

Registry_Machines::Registry_Machines(const Registry_Machines& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Registry_Machines::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Registry_Machines::~Registry_Machines() {
  SharedDtor();
}

void Registry_Machines::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Registry_Machines::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Registry_Machines::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Registry_Machines_descriptor_;
}

const Registry_Machines& Registry_Machines::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_master_2fregistry_2eproto();
  return *default_instance_;
}

Registry_Machines* Registry_Machines::default_instance_ = NULL;

Registry_Machines* Registry_Machines::New() const {
  return new Registry_Machines;
}

void Registry_Machines::Clear() {
  machines_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Registry_Machines::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.internal.Registry.Machine machines = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_machines:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_machines()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_machines;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Registry_Machines::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.internal.Registry.Machine machines = 1;
  for (int i = 0; i < this->machines_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->machines(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Registry_Machines::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.internal.Registry.Machine machines = 1;
  for (int i = 0; i < this->machines_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->machines(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Registry_Machines::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.internal.Registry.Machine machines = 1;
  total_size += 1 * this->machines_size();
  for (int i = 0; i < this->machines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->machines(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Registry_Machines::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Registry_Machines* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Registry_Machines*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Registry_Machines::MergeFrom(const Registry_Machines& from) {
  GOOGLE_CHECK_NE(&from, this);
  machines_.MergeFrom(from.machines_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Registry_Machines::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Registry_Machines::CopyFrom(const Registry_Machines& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Registry_Machines::IsInitialized() const {

  for (int i = 0; i < machines_size(); i++) {
    if (!this->machines(i).IsInitialized()) return false;
  }
  return true;
}

void Registry_Machines::Swap(Registry_Machines* other) {
  if (other != this) {
    machines_.Swap(&other->machines_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Registry_Machines::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Registry_Machines_descriptor_;
  metadata.reflection = Registry_Machines_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Registry::kMasterFieldNumber;
const int Registry::kSlavesFieldNumber;
const int Registry::kMachinesFieldNumber;
const int Registry::kSchedulesFieldNumber;
#endif  // !_MSC_VER

Registry::Registry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Registry::InitAsDefaultInstance() {
  master_ = const_cast< ::mesos::internal::Registry_Master*>(&::mesos::internal::Registry_Master::default_instance());
  slaves_ = const_cast< ::mesos::internal::Registry_Slaves*>(&::mesos::internal::Registry_Slaves::default_instance());
  machines_ = const_cast< ::mesos::internal::Registry_Machines*>(&::mesos::internal::Registry_Machines::default_instance());
}

Registry::Registry(const Registry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Registry::SharedCtor() {
  _cached_size_ = 0;
  master_ = NULL;
  slaves_ = NULL;
  machines_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Registry::~Registry() {
  SharedDtor();
}

void Registry::SharedDtor() {
  if (this != default_instance_) {
    delete master_;
    delete slaves_;
    delete machines_;
  }
}

void Registry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Registry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Registry_descriptor_;
}

const Registry& Registry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_master_2fregistry_2eproto();
  return *default_instance_;
}

Registry* Registry::default_instance_ = NULL;

Registry* Registry::New() const {
  return new Registry;
}

void Registry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_master()) {
      if (master_ != NULL) master_->::mesos::internal::Registry_Master::Clear();
    }
    if (has_slaves()) {
      if (slaves_ != NULL) slaves_->::mesos::internal::Registry_Slaves::Clear();
    }
    if (has_machines()) {
      if (machines_ != NULL) machines_->::mesos::internal::Registry_Machines::Clear();
    }
  }
  schedules_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Registry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.internal.Registry.Master master = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slaves;
        break;
      }

      // optional .mesos.internal.Registry.Slaves slaves = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slaves:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slaves()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_machines;
        break;
      }

      // optional .mesos.internal.Registry.Machines machines = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_machines:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_machines()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_schedules;
        break;
      }

      // repeated .mesos.maintenance.Schedule schedules = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_schedules:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_schedules()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_schedules;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Registry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mesos.internal.Registry.Master master = 1;
  if (has_master()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->master(), output);
  }

  // optional .mesos.internal.Registry.Slaves slaves = 2;
  if (has_slaves()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slaves(), output);
  }

  // optional .mesos.internal.Registry.Machines machines = 3;
  if (has_machines()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->machines(), output);
  }

  // repeated .mesos.maintenance.Schedule schedules = 4;
  for (int i = 0; i < this->schedules_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->schedules(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Registry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mesos.internal.Registry.Master master = 1;
  if (has_master()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->master(), target);
  }

  // optional .mesos.internal.Registry.Slaves slaves = 2;
  if (has_slaves()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slaves(), target);
  }

  // optional .mesos.internal.Registry.Machines machines = 3;
  if (has_machines()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->machines(), target);
  }

  // repeated .mesos.maintenance.Schedule schedules = 4;
  for (int i = 0; i < this->schedules_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->schedules(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Registry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.internal.Registry.Master master = 1;
    if (has_master()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master());
    }

    // optional .mesos.internal.Registry.Slaves slaves = 2;
    if (has_slaves()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slaves());
    }

    // optional .mesos.internal.Registry.Machines machines = 3;
    if (has_machines()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->machines());
    }

  }
  // repeated .mesos.maintenance.Schedule schedules = 4;
  total_size += 1 * this->schedules_size();
  for (int i = 0; i < this->schedules_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->schedules(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Registry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Registry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Registry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Registry::MergeFrom(const Registry& from) {
  GOOGLE_CHECK_NE(&from, this);
  schedules_.MergeFrom(from.schedules_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_master()) {
      mutable_master()->::mesos::internal::Registry_Master::MergeFrom(from.master());
    }
    if (from.has_slaves()) {
      mutable_slaves()->::mesos::internal::Registry_Slaves::MergeFrom(from.slaves());
    }
    if (from.has_machines()) {
      mutable_machines()->::mesos::internal::Registry_Machines::MergeFrom(from.machines());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Registry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Registry::CopyFrom(const Registry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Registry::IsInitialized() const {

  if (has_master()) {
    if (!this->master().IsInitialized()) return false;
  }
  if (has_slaves()) {
    if (!this->slaves().IsInitialized()) return false;
  }
  if (has_machines()) {
    if (!this->machines().IsInitialized()) return false;
  }
  for (int i = 0; i < schedules_size(); i++) {
    if (!this->schedules(i).IsInitialized()) return false;
  }
  return true;
}

void Registry::Swap(Registry* other) {
  if (other != this) {
    std::swap(master_, other->master_);
    std::swap(slaves_, other->slaves_);
    std::swap(machines_, other->machines_);
    schedules_.Swap(&other->schedules_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Registry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Registry_descriptor_;
  metadata.reflection = Registry_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace internal
}  // namespace mesos

// @@protoc_insertion_point(global_scope)
