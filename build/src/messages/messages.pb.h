// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages/messages.proto

#ifndef PROTOBUF_messages_2fmessages_2eproto__INCLUDED
#define PROTOBUF_messages_2fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace mesos {
namespace internal {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2fmessages_2eproto();
void protobuf_AssignDesc_messages_2fmessages_2eproto();
void protobuf_ShutdownFile_messages_2fmessages_2eproto();

class Task;
class StatusUpdate;
class StatusUpdateRecord;
class SubmitSchedulerRequest;
class SubmitSchedulerResponse;
class ExecutorToFrameworkMessage;
class FrameworkToExecutorMessage;
class RegisterFrameworkMessage;
class ReregisterFrameworkMessage;
class FrameworkRegisteredMessage;
class FrameworkReregisteredMessage;
class UnregisterFrameworkMessage;
class DeactivateFrameworkMessage;
class ResourceRequestMessage;
class ResourceOffersMessage;
class LaunchTasksMessage;
class RescindResourceOfferMessage;
class ReviveOffersMessage;
class RunTaskMessage;
class KillTaskMessage;
class StatusUpdateMessage;
class StatusUpdateAcknowledgementMessage;
class LostSlaveMessage;
class ReconcileTasksMessage;
class FrameworkErrorMessage;
class RegisterSlaveMessage;
class ReregisterSlaveMessage;
class SlaveRegisteredMessage;
class SlaveReregisteredMessage;
class UnregisterSlaveMessage;
class MasterSlaveConnection;
class PingSlaveMessage;
class PongSlaveMessage;
class ShutdownFrameworkMessage;
class ShutdownExecutorMessage;
class UpdateFrameworkMessage;
class CheckpointResourcesMessage;
class UpdateSlaveMessage;
class RegisterExecutorMessage;
class ExecutorRegisteredMessage;
class ExecutorReregisteredMessage;
class ExitedExecutorMessage;
class ReconnectExecutorMessage;
class ReregisterExecutorMessage;
class ShutdownMessage;
class Archive;
class Archive_Framework;
class TaskHealthStatus;
class HookExecuted;

enum StatusUpdateRecord_Type {
  StatusUpdateRecord_Type_UPDATE = 0,
  StatusUpdateRecord_Type_ACK = 1
};
bool StatusUpdateRecord_Type_IsValid(int value);
const StatusUpdateRecord_Type StatusUpdateRecord_Type_Type_MIN = StatusUpdateRecord_Type_UPDATE;
const StatusUpdateRecord_Type StatusUpdateRecord_Type_Type_MAX = StatusUpdateRecord_Type_ACK;
const int StatusUpdateRecord_Type_Type_ARRAYSIZE = StatusUpdateRecord_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusUpdateRecord_Type_descriptor();
inline const ::std::string& StatusUpdateRecord_Type_Name(StatusUpdateRecord_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusUpdateRecord_Type_descriptor(), value);
}
inline bool StatusUpdateRecord_Type_Parse(
    const ::std::string& name, StatusUpdateRecord_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusUpdateRecord_Type>(
    StatusUpdateRecord_Type_descriptor(), name, value);
}
// ===================================================================

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required .mesos.FrameworkID framework_id = 3;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.ExecutorID executor_id = 4;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 4;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required .mesos.SlaveID slave_id = 5;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.TaskState state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::mesos::TaskState state() const;
  inline void set_state(::mesos::TaskState value);

  // repeated .mesos.Resource resources = 7;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 7;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated .mesos.TaskStatus statuses = 8;
  inline int statuses_size() const;
  inline void clear_statuses();
  static const int kStatusesFieldNumber = 8;
  inline const ::mesos::TaskStatus& statuses(int index) const;
  inline ::mesos::TaskStatus* mutable_statuses(int index);
  inline ::mesos::TaskStatus* add_statuses();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
      statuses() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
      mutable_statuses();

  // optional .mesos.TaskState status_update_state = 9;
  inline bool has_status_update_state() const;
  inline void clear_status_update_state();
  static const int kStatusUpdateStateFieldNumber = 9;
  inline ::mesos::TaskState status_update_state() const;
  inline void set_status_update_state(::mesos::TaskState value);

  // optional bytes status_update_uuid = 10;
  inline bool has_status_update_uuid() const;
  inline void clear_status_update_uuid();
  static const int kStatusUpdateUuidFieldNumber = 10;
  inline const ::std::string& status_update_uuid() const;
  inline void set_status_update_uuid(const ::std::string& value);
  inline void set_status_update_uuid(const char* value);
  inline void set_status_update_uuid(const void* value, size_t size);
  inline ::std::string* mutable_status_update_uuid();
  inline ::std::string* release_status_update_uuid();
  inline void set_allocated_status_update_uuid(::std::string* status_update_uuid);

  // optional .mesos.Labels labels = 11;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 11;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // optional .mesos.DiscoveryInfo discovery = 12;
  inline bool has_discovery() const;
  inline void clear_discovery();
  static const int kDiscoveryFieldNumber = 12;
  inline const ::mesos::DiscoveryInfo& discovery() const;
  inline ::mesos::DiscoveryInfo* mutable_discovery();
  inline ::mesos::DiscoveryInfo* release_discovery();
  inline void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);

  // @@protoc_insertion_point(class_scope:mesos.internal.Task)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_status_update_state();
  inline void clear_has_status_update_state();
  inline void set_has_status_update_uuid();
  inline void clear_has_status_update_uuid();
  inline void set_has_labels();
  inline void clear_has_labels();
  inline void set_has_discovery();
  inline void clear_has_discovery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::mesos::TaskID* task_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  int state_;
  int status_update_state_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus > statuses_;
  ::std::string* status_update_uuid_;
  ::mesos::Labels* labels_;
  ::mesos::DiscoveryInfo* discovery_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class StatusUpdate : public ::google::protobuf::Message {
 public:
  StatusUpdate();
  virtual ~StatusUpdate();

  StatusUpdate(const StatusUpdate& from);

  inline StatusUpdate& operator=(const StatusUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUpdate& default_instance();

  void Swap(StatusUpdate* other);

  // implements Message ----------------------------------------------

  StatusUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusUpdate& from);
  void MergeFrom(const StatusUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.TaskStatus status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::mesos::TaskStatus& status() const;
  inline ::mesos::TaskStatus* mutable_status();
  inline ::mesos::TaskStatus* release_status();
  inline void set_allocated_status(::mesos::TaskStatus* status);

  // required double timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional bytes uuid = 6;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 6;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional .mesos.TaskState latest_state = 7;
  inline bool has_latest_state() const;
  inline void clear_latest_state();
  static const int kLatestStateFieldNumber = 7;
  inline ::mesos::TaskState latest_state() const;
  inline void set_latest_state(::mesos::TaskState value);

  // @@protoc_insertion_point(class_scope:mesos.internal.StatusUpdate)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_latest_state();
  inline void clear_has_latest_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::TaskStatus* status_;
  double timestamp_;
  ::std::string* uuid_;
  int latest_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static StatusUpdate* default_instance_;
};
// -------------------------------------------------------------------

class StatusUpdateRecord : public ::google::protobuf::Message {
 public:
  StatusUpdateRecord();
  virtual ~StatusUpdateRecord();

  StatusUpdateRecord(const StatusUpdateRecord& from);

  inline StatusUpdateRecord& operator=(const StatusUpdateRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUpdateRecord& default_instance();

  void Swap(StatusUpdateRecord* other);

  // implements Message ----------------------------------------------

  StatusUpdateRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusUpdateRecord& from);
  void MergeFrom(const StatusUpdateRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StatusUpdateRecord_Type Type;
  static const Type UPDATE = StatusUpdateRecord_Type_UPDATE;
  static const Type ACK = StatusUpdateRecord_Type_ACK;
  static inline bool Type_IsValid(int value) {
    return StatusUpdateRecord_Type_IsValid(value);
  }
  static const Type Type_MIN =
    StatusUpdateRecord_Type_Type_MIN;
  static const Type Type_MAX =
    StatusUpdateRecord_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    StatusUpdateRecord_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return StatusUpdateRecord_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return StatusUpdateRecord_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return StatusUpdateRecord_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.internal.StatusUpdateRecord.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::internal::StatusUpdateRecord_Type type() const;
  inline void set_type(::mesos::internal::StatusUpdateRecord_Type value);

  // optional .mesos.internal.StatusUpdate update = 2;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 2;
  inline const ::mesos::internal::StatusUpdate& update() const;
  inline ::mesos::internal::StatusUpdate* mutable_update();
  inline ::mesos::internal::StatusUpdate* release_update();
  inline void set_allocated_update(::mesos::internal::StatusUpdate* update);

  // optional bytes uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:mesos.internal.StatusUpdateRecord)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::internal::StatusUpdate* update_;
  ::std::string* uuid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static StatusUpdateRecord* default_instance_;
};
// -------------------------------------------------------------------

class SubmitSchedulerRequest : public ::google::protobuf::Message {
 public:
  SubmitSchedulerRequest();
  virtual ~SubmitSchedulerRequest();

  SubmitSchedulerRequest(const SubmitSchedulerRequest& from);

  inline SubmitSchedulerRequest& operator=(const SubmitSchedulerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitSchedulerRequest& default_instance();

  void Swap(SubmitSchedulerRequest* other);

  // implements Message ----------------------------------------------

  SubmitSchedulerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitSchedulerRequest& from);
  void MergeFrom(const SubmitSchedulerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mesos.internal.SubmitSchedulerRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SubmitSchedulerRequest* default_instance_;
};
// -------------------------------------------------------------------

class SubmitSchedulerResponse : public ::google::protobuf::Message {
 public:
  SubmitSchedulerResponse();
  virtual ~SubmitSchedulerResponse();

  SubmitSchedulerResponse(const SubmitSchedulerResponse& from);

  inline SubmitSchedulerResponse& operator=(const SubmitSchedulerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitSchedulerResponse& default_instance();

  void Swap(SubmitSchedulerResponse* other);

  // implements Message ----------------------------------------------

  SubmitSchedulerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitSchedulerResponse& from);
  void MergeFrom(const SubmitSchedulerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool okay = 1;
  inline bool has_okay() const;
  inline void clear_okay();
  static const int kOkayFieldNumber = 1;
  inline bool okay() const;
  inline void set_okay(bool value);

  // @@protoc_insertion_point(class_scope:mesos.internal.SubmitSchedulerResponse)
 private:
  inline void set_has_okay();
  inline void clear_has_okay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool okay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SubmitSchedulerResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorToFrameworkMessage : public ::google::protobuf::Message {
 public:
  ExecutorToFrameworkMessage();
  virtual ~ExecutorToFrameworkMessage();

  ExecutorToFrameworkMessage(const ExecutorToFrameworkMessage& from);

  inline ExecutorToFrameworkMessage& operator=(const ExecutorToFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorToFrameworkMessage& default_instance();

  void Swap(ExecutorToFrameworkMessage* other);

  // implements Message ----------------------------------------------

  ExecutorToFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorToFrameworkMessage& from);
  void MergeFrom(const ExecutorToFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.internal.ExecutorToFrameworkMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ExecutorToFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkToExecutorMessage : public ::google::protobuf::Message {
 public:
  FrameworkToExecutorMessage();
  virtual ~FrameworkToExecutorMessage();

  FrameworkToExecutorMessage(const FrameworkToExecutorMessage& from);

  inline FrameworkToExecutorMessage& operator=(const FrameworkToExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkToExecutorMessage& default_instance();

  void Swap(FrameworkToExecutorMessage* other);

  // implements Message ----------------------------------------------

  FrameworkToExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkToExecutorMessage& from);
  void MergeFrom(const FrameworkToExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkToExecutorMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static FrameworkToExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterFrameworkMessage : public ::google::protobuf::Message {
 public:
  RegisterFrameworkMessage();
  virtual ~RegisterFrameworkMessage();

  RegisterFrameworkMessage(const RegisterFrameworkMessage& from);

  inline RegisterFrameworkMessage& operator=(const RegisterFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterFrameworkMessage& default_instance();

  void Swap(RegisterFrameworkMessage* other);

  // implements Message ----------------------------------------------

  RegisterFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterFrameworkMessage& from);
  void MergeFrom(const RegisterFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkInfo framework = 1;
  inline bool has_framework() const;
  inline void clear_framework();
  static const int kFrameworkFieldNumber = 1;
  inline const ::mesos::FrameworkInfo& framework() const;
  inline ::mesos::FrameworkInfo* mutable_framework();
  inline ::mesos::FrameworkInfo* release_framework();
  inline void set_allocated_framework(::mesos::FrameworkInfo* framework);

  // @@protoc_insertion_point(class_scope:mesos.internal.RegisterFrameworkMessage)
 private:
  inline void set_has_framework();
  inline void clear_has_framework();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkInfo* framework_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReregisterFrameworkMessage : public ::google::protobuf::Message {
 public:
  ReregisterFrameworkMessage();
  virtual ~ReregisterFrameworkMessage();

  ReregisterFrameworkMessage(const ReregisterFrameworkMessage& from);

  inline ReregisterFrameworkMessage& operator=(const ReregisterFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReregisterFrameworkMessage& default_instance();

  void Swap(ReregisterFrameworkMessage* other);

  // implements Message ----------------------------------------------

  ReregisterFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReregisterFrameworkMessage& from);
  void MergeFrom(const ReregisterFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkInfo framework = 2;
  inline bool has_framework() const;
  inline void clear_framework();
  static const int kFrameworkFieldNumber = 2;
  inline const ::mesos::FrameworkInfo& framework() const;
  inline ::mesos::FrameworkInfo* mutable_framework();
  inline ::mesos::FrameworkInfo* release_framework();
  inline void set_allocated_framework(::mesos::FrameworkInfo* framework);

  // required bool failover = 3;
  inline bool has_failover() const;
  inline void clear_failover();
  static const int kFailoverFieldNumber = 3;
  inline bool failover() const;
  inline void set_failover(bool value);

  // @@protoc_insertion_point(class_scope:mesos.internal.ReregisterFrameworkMessage)
 private:
  inline void set_has_framework();
  inline void clear_has_framework();
  inline void set_has_failover();
  inline void clear_has_failover();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkInfo* framework_;
  bool failover_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ReregisterFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkRegisteredMessage : public ::google::protobuf::Message {
 public:
  FrameworkRegisteredMessage();
  virtual ~FrameworkRegisteredMessage();

  FrameworkRegisteredMessage(const FrameworkRegisteredMessage& from);

  inline FrameworkRegisteredMessage& operator=(const FrameworkRegisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkRegisteredMessage& default_instance();

  void Swap(FrameworkRegisteredMessage* other);

  // implements Message ----------------------------------------------

  FrameworkRegisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkRegisteredMessage& from);
  void MergeFrom(const FrameworkRegisteredMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.MasterInfo master_info = 2;
  inline bool has_master_info() const;
  inline void clear_master_info();
  static const int kMasterInfoFieldNumber = 2;
  inline const ::mesos::MasterInfo& master_info() const;
  inline ::mesos::MasterInfo* mutable_master_info();
  inline ::mesos::MasterInfo* release_master_info();
  inline void set_allocated_master_info(::mesos::MasterInfo* master_info);

  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkRegisteredMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_master_info();
  inline void clear_has_master_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::MasterInfo* master_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static FrameworkRegisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkReregisteredMessage : public ::google::protobuf::Message {
 public:
  FrameworkReregisteredMessage();
  virtual ~FrameworkReregisteredMessage();

  FrameworkReregisteredMessage(const FrameworkReregisteredMessage& from);

  inline FrameworkReregisteredMessage& operator=(const FrameworkReregisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkReregisteredMessage& default_instance();

  void Swap(FrameworkReregisteredMessage* other);

  // implements Message ----------------------------------------------

  FrameworkReregisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkReregisteredMessage& from);
  void MergeFrom(const FrameworkReregisteredMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.MasterInfo master_info = 2;
  inline bool has_master_info() const;
  inline void clear_master_info();
  static const int kMasterInfoFieldNumber = 2;
  inline const ::mesos::MasterInfo& master_info() const;
  inline ::mesos::MasterInfo* mutable_master_info();
  inline ::mesos::MasterInfo* release_master_info();
  inline void set_allocated_master_info(::mesos::MasterInfo* master_info);

  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkReregisteredMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_master_info();
  inline void clear_has_master_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::MasterInfo* master_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static FrameworkReregisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterFrameworkMessage : public ::google::protobuf::Message {
 public:
  UnregisterFrameworkMessage();
  virtual ~UnregisterFrameworkMessage();

  UnregisterFrameworkMessage(const UnregisterFrameworkMessage& from);

  inline UnregisterFrameworkMessage& operator=(const UnregisterFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnregisterFrameworkMessage& default_instance();

  void Swap(UnregisterFrameworkMessage* other);

  // implements Message ----------------------------------------------

  UnregisterFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnregisterFrameworkMessage& from);
  void MergeFrom(const UnregisterFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.UnregisterFrameworkMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static UnregisterFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class DeactivateFrameworkMessage : public ::google::protobuf::Message {
 public:
  DeactivateFrameworkMessage();
  virtual ~DeactivateFrameworkMessage();

  DeactivateFrameworkMessage(const DeactivateFrameworkMessage& from);

  inline DeactivateFrameworkMessage& operator=(const DeactivateFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeactivateFrameworkMessage& default_instance();

  void Swap(DeactivateFrameworkMessage* other);

  // implements Message ----------------------------------------------

  DeactivateFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeactivateFrameworkMessage& from);
  void MergeFrom(const DeactivateFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.DeactivateFrameworkMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DeactivateFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResourceRequestMessage : public ::google::protobuf::Message {
 public:
  ResourceRequestMessage();
  virtual ~ResourceRequestMessage();

  ResourceRequestMessage(const ResourceRequestMessage& from);

  inline ResourceRequestMessage& operator=(const ResourceRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceRequestMessage& default_instance();

  void Swap(ResourceRequestMessage* other);

  // implements Message ----------------------------------------------

  ResourceRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceRequestMessage& from);
  void MergeFrom(const ResourceRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // repeated .mesos.Request requests = 2;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 2;
  inline const ::mesos::Request& requests(int index) const;
  inline ::mesos::Request* mutable_requests(int index);
  inline ::mesos::Request* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Request >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Request >*
      mutable_requests();

  // @@protoc_insertion_point(class_scope:mesos.internal.ResourceRequestMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Request > requests_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ResourceRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResourceOffersMessage : public ::google::protobuf::Message {
 public:
  ResourceOffersMessage();
  virtual ~ResourceOffersMessage();

  ResourceOffersMessage(const ResourceOffersMessage& from);

  inline ResourceOffersMessage& operator=(const ResourceOffersMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceOffersMessage& default_instance();

  void Swap(ResourceOffersMessage* other);

  // implements Message ----------------------------------------------

  ResourceOffersMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceOffersMessage& from);
  void MergeFrom(const ResourceOffersMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Offer offers = 1;
  inline int offers_size() const;
  inline void clear_offers();
  static const int kOffersFieldNumber = 1;
  inline const ::mesos::Offer& offers(int index) const;
  inline ::mesos::Offer* mutable_offers(int index);
  inline ::mesos::Offer* add_offers();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
      offers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
      mutable_offers();

  // repeated string pids = 2;
  inline int pids_size() const;
  inline void clear_pids();
  static const int kPidsFieldNumber = 2;
  inline const ::std::string& pids(int index) const;
  inline ::std::string* mutable_pids(int index);
  inline void set_pids(int index, const ::std::string& value);
  inline void set_pids(int index, const char* value);
  inline void set_pids(int index, const char* value, size_t size);
  inline ::std::string* add_pids();
  inline void add_pids(const ::std::string& value);
  inline void add_pids(const char* value);
  inline void add_pids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pids();

  // repeated .mesos.InverseOffer inverse_offers = 3;
  inline int inverse_offers_size() const;
  inline void clear_inverse_offers();
  static const int kInverseOffersFieldNumber = 3;
  inline const ::mesos::InverseOffer& inverse_offers(int index) const;
  inline ::mesos::InverseOffer* mutable_inverse_offers(int index);
  inline ::mesos::InverseOffer* add_inverse_offers();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >&
      inverse_offers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >*
      mutable_inverse_offers();

  // @@protoc_insertion_point(class_scope:mesos.internal.ResourceOffersMessage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Offer > offers_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pids_;
  ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer > inverse_offers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ResourceOffersMessage* default_instance_;
};
// -------------------------------------------------------------------

class LaunchTasksMessage : public ::google::protobuf::Message {
 public:
  LaunchTasksMessage();
  virtual ~LaunchTasksMessage();

  LaunchTasksMessage(const LaunchTasksMessage& from);

  inline LaunchTasksMessage& operator=(const LaunchTasksMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaunchTasksMessage& default_instance();

  void Swap(LaunchTasksMessage* other);

  // implements Message ----------------------------------------------

  LaunchTasksMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaunchTasksMessage& from);
  void MergeFrom(const LaunchTasksMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // repeated .mesos.TaskInfo tasks = 3;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 3;
  inline const ::mesos::TaskInfo& tasks(int index) const;
  inline ::mesos::TaskInfo* mutable_tasks(int index);
  inline ::mesos::TaskInfo* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
      mutable_tasks();

  // required .mesos.Filters filters = 5;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 5;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  inline ::mesos::Filters* release_filters();
  inline void set_allocated_filters(::mesos::Filters* filters);

  // repeated .mesos.OfferID offer_ids = 6;
  inline int offer_ids_size() const;
  inline void clear_offer_ids();
  static const int kOfferIdsFieldNumber = 6;
  inline const ::mesos::OfferID& offer_ids(int index) const;
  inline ::mesos::OfferID* mutable_offer_ids(int index);
  inline ::mesos::OfferID* add_offer_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      offer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_offer_ids();

  // @@protoc_insertion_point(class_scope:mesos.internal.LaunchTasksMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo > tasks_;
  ::mesos::Filters* filters_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > offer_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static LaunchTasksMessage* default_instance_;
};
// -------------------------------------------------------------------

class RescindResourceOfferMessage : public ::google::protobuf::Message {
 public:
  RescindResourceOfferMessage();
  virtual ~RescindResourceOfferMessage();

  RescindResourceOfferMessage(const RescindResourceOfferMessage& from);

  inline RescindResourceOfferMessage& operator=(const RescindResourceOfferMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RescindResourceOfferMessage& default_instance();

  void Swap(RescindResourceOfferMessage* other);

  // implements Message ----------------------------------------------

  RescindResourceOfferMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RescindResourceOfferMessage& from);
  void MergeFrom(const RescindResourceOfferMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OfferID offer_id = 1;
  inline bool has_offer_id() const;
  inline void clear_offer_id();
  static const int kOfferIdFieldNumber = 1;
  inline const ::mesos::OfferID& offer_id() const;
  inline ::mesos::OfferID* mutable_offer_id();
  inline ::mesos::OfferID* release_offer_id();
  inline void set_allocated_offer_id(::mesos::OfferID* offer_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.RescindResourceOfferMessage)
 private:
  inline void set_has_offer_id();
  inline void clear_has_offer_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::OfferID* offer_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RescindResourceOfferMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReviveOffersMessage : public ::google::protobuf::Message {
 public:
  ReviveOffersMessage();
  virtual ~ReviveOffersMessage();

  ReviveOffersMessage(const ReviveOffersMessage& from);

  inline ReviveOffersMessage& operator=(const ReviveOffersMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReviveOffersMessage& default_instance();

  void Swap(ReviveOffersMessage* other);

  // implements Message ----------------------------------------------

  ReviveOffersMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReviveOffersMessage& from);
  void MergeFrom(const ReviveOffersMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.ReviveOffersMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ReviveOffersMessage* default_instance_;
};
// -------------------------------------------------------------------

class RunTaskMessage : public ::google::protobuf::Message {
 public:
  RunTaskMessage();
  virtual ~RunTaskMessage();

  RunTaskMessage(const RunTaskMessage& from);

  inline RunTaskMessage& operator=(const RunTaskMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunTaskMessage& default_instance();

  void Swap(RunTaskMessage* other);

  // implements Message ----------------------------------------------

  RunTaskMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunTaskMessage& from);
  void MergeFrom(const RunTaskMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
  inline bool has_framework_id() const PROTOBUF_DEPRECATED;
  inline void clear_framework_id() PROTOBUF_DEPRECATED;
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const PROTOBUF_DEPRECATED;
  inline ::mesos::FrameworkID* mutable_framework_id() PROTOBUF_DEPRECATED;
  inline ::mesos::FrameworkID* release_framework_id() PROTOBUF_DEPRECATED;
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id) PROTOBUF_DEPRECATED;

  // required .mesos.FrameworkInfo framework = 2;
  inline bool has_framework() const;
  inline void clear_framework();
  static const int kFrameworkFieldNumber = 2;
  inline const ::mesos::FrameworkInfo& framework() const;
  inline ::mesos::FrameworkInfo* mutable_framework();
  inline ::mesos::FrameworkInfo* release_framework();
  inline void set_allocated_framework(::mesos::FrameworkInfo* framework);

  // required .mesos.TaskInfo task = 4;
  inline bool has_task() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 4;
  inline const ::mesos::TaskInfo& task() const;
  inline ::mesos::TaskInfo* mutable_task();
  inline ::mesos::TaskInfo* release_task();
  inline void set_allocated_task(::mesos::TaskInfo* task);

  // optional string pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // @@protoc_insertion_point(class_scope:mesos.internal.RunTaskMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_framework();
  inline void clear_has_framework();
  inline void set_has_task();
  inline void clear_has_task();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::FrameworkInfo* framework_;
  ::mesos::TaskInfo* task_;
  ::std::string* pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RunTaskMessage* default_instance_;
};
// -------------------------------------------------------------------

class KillTaskMessage : public ::google::protobuf::Message {
 public:
  KillTaskMessage();
  virtual ~KillTaskMessage();

  KillTaskMessage(const KillTaskMessage& from);

  inline KillTaskMessage& operator=(const KillTaskMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KillTaskMessage& default_instance();

  void Swap(KillTaskMessage* other);

  // implements Message ----------------------------------------------

  KillTaskMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KillTaskMessage& from);
  void MergeFrom(const KillTaskMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.KillTaskMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::TaskID* task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static KillTaskMessage* default_instance_;
};
// -------------------------------------------------------------------

class StatusUpdateMessage : public ::google::protobuf::Message {
 public:
  StatusUpdateMessage();
  virtual ~StatusUpdateMessage();

  StatusUpdateMessage(const StatusUpdateMessage& from);

  inline StatusUpdateMessage& operator=(const StatusUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUpdateMessage& default_instance();

  void Swap(StatusUpdateMessage* other);

  // implements Message ----------------------------------------------

  StatusUpdateMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusUpdateMessage& from);
  void MergeFrom(const StatusUpdateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.internal.StatusUpdate update = 1;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 1;
  inline const ::mesos::internal::StatusUpdate& update() const;
  inline ::mesos::internal::StatusUpdate* mutable_update();
  inline ::mesos::internal::StatusUpdate* release_update();
  inline void set_allocated_update(::mesos::internal::StatusUpdate* update);

  // optional string pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // @@protoc_insertion_point(class_scope:mesos.internal.StatusUpdateMessage)
 private:
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::internal::StatusUpdate* update_;
  ::std::string* pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static StatusUpdateMessage* default_instance_;
};
// -------------------------------------------------------------------

class StatusUpdateAcknowledgementMessage : public ::google::protobuf::Message {
 public:
  StatusUpdateAcknowledgementMessage();
  virtual ~StatusUpdateAcknowledgementMessage();

  StatusUpdateAcknowledgementMessage(const StatusUpdateAcknowledgementMessage& from);

  inline StatusUpdateAcknowledgementMessage& operator=(const StatusUpdateAcknowledgementMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusUpdateAcknowledgementMessage& default_instance();

  void Swap(StatusUpdateAcknowledgementMessage* other);

  // implements Message ----------------------------------------------

  StatusUpdateAcknowledgementMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusUpdateAcknowledgementMessage& from);
  void MergeFrom(const StatusUpdateAcknowledgementMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.TaskID task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required bytes uuid = 4;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 4;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:mesos.internal.StatusUpdateAcknowledgementMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::TaskID* task_id_;
  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static StatusUpdateAcknowledgementMessage* default_instance_;
};
// -------------------------------------------------------------------

class LostSlaveMessage : public ::google::protobuf::Message {
 public:
  LostSlaveMessage();
  virtual ~LostSlaveMessage();

  LostSlaveMessage(const LostSlaveMessage& from);

  inline LostSlaveMessage& operator=(const LostSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LostSlaveMessage& default_instance();

  void Swap(LostSlaveMessage* other);

  // implements Message ----------------------------------------------

  LostSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LostSlaveMessage& from);
  void MergeFrom(const LostSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.LostSlaveMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static LostSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReconcileTasksMessage : public ::google::protobuf::Message {
 public:
  ReconcileTasksMessage();
  virtual ~ReconcileTasksMessage();

  ReconcileTasksMessage(const ReconcileTasksMessage& from);

  inline ReconcileTasksMessage& operator=(const ReconcileTasksMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReconcileTasksMessage& default_instance();

  void Swap(ReconcileTasksMessage* other);

  // implements Message ----------------------------------------------

  ReconcileTasksMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReconcileTasksMessage& from);
  void MergeFrom(const ReconcileTasksMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // repeated .mesos.TaskStatus statuses = 2;
  inline int statuses_size() const;
  inline void clear_statuses();
  static const int kStatusesFieldNumber = 2;
  inline const ::mesos::TaskStatus& statuses(int index) const;
  inline ::mesos::TaskStatus* mutable_statuses(int index);
  inline ::mesos::TaskStatus* add_statuses();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
      statuses() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
      mutable_statuses();

  // @@protoc_insertion_point(class_scope:mesos.internal.ReconcileTasksMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus > statuses_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ReconcileTasksMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkErrorMessage : public ::google::protobuf::Message {
 public:
  FrameworkErrorMessage();
  virtual ~FrameworkErrorMessage();

  FrameworkErrorMessage(const FrameworkErrorMessage& from);

  inline FrameworkErrorMessage& operator=(const FrameworkErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkErrorMessage& default_instance();

  void Swap(FrameworkErrorMessage* other);

  // implements Message ----------------------------------------------

  FrameworkErrorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkErrorMessage& from);
  void MergeFrom(const FrameworkErrorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:mesos.internal.FrameworkErrorMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static FrameworkErrorMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterSlaveMessage : public ::google::protobuf::Message {
 public:
  RegisterSlaveMessage();
  virtual ~RegisterSlaveMessage();

  RegisterSlaveMessage(const RegisterSlaveMessage& from);

  inline RegisterSlaveMessage& operator=(const RegisterSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterSlaveMessage& default_instance();

  void Swap(RegisterSlaveMessage* other);

  // implements Message ----------------------------------------------

  RegisterSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterSlaveMessage& from);
  void MergeFrom(const RegisterSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveInfo slave = 1;
  inline bool has_slave() const;
  inline void clear_slave();
  static const int kSlaveFieldNumber = 1;
  inline const ::mesos::SlaveInfo& slave() const;
  inline ::mesos::SlaveInfo* mutable_slave();
  inline ::mesos::SlaveInfo* release_slave();
  inline void set_allocated_slave(::mesos::SlaveInfo* slave);

  // repeated .mesos.Resource checkpointed_resources = 3;
  inline int checkpointed_resources_size() const;
  inline void clear_checkpointed_resources();
  static const int kCheckpointedResourcesFieldNumber = 3;
  inline const ::mesos::Resource& checkpointed_resources(int index) const;
  inline ::mesos::Resource* mutable_checkpointed_resources(int index);
  inline ::mesos::Resource* add_checkpointed_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      checkpointed_resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_checkpointed_resources();

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mesos.internal.RegisterSlaveMessage)
 private:
  inline void set_has_slave();
  inline void clear_has_slave();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveInfo* slave_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > checkpointed_resources_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReregisterSlaveMessage : public ::google::protobuf::Message {
 public:
  ReregisterSlaveMessage();
  virtual ~ReregisterSlaveMessage();

  ReregisterSlaveMessage(const ReregisterSlaveMessage& from);

  inline ReregisterSlaveMessage& operator=(const ReregisterSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReregisterSlaveMessage& default_instance();

  void Swap(ReregisterSlaveMessage* other);

  // implements Message ----------------------------------------------

  ReregisterSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReregisterSlaveMessage& from);
  void MergeFrom(const ReregisterSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveInfo slave = 2;
  inline bool has_slave() const;
  inline void clear_slave();
  static const int kSlaveFieldNumber = 2;
  inline const ::mesos::SlaveInfo& slave() const;
  inline ::mesos::SlaveInfo* mutable_slave();
  inline ::mesos::SlaveInfo* release_slave();
  inline void set_allocated_slave(::mesos::SlaveInfo* slave);

  // repeated .mesos.Resource checkpointed_resources = 7;
  inline int checkpointed_resources_size() const;
  inline void clear_checkpointed_resources();
  static const int kCheckpointedResourcesFieldNumber = 7;
  inline const ::mesos::Resource& checkpointed_resources(int index) const;
  inline ::mesos::Resource* mutable_checkpointed_resources(int index);
  inline ::mesos::Resource* add_checkpointed_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      checkpointed_resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_checkpointed_resources();

  // repeated .mesos.ExecutorInfo executor_infos = 4;
  inline int executor_infos_size() const;
  inline void clear_executor_infos();
  static const int kExecutorInfosFieldNumber = 4;
  inline const ::mesos::ExecutorInfo& executor_infos(int index) const;
  inline ::mesos::ExecutorInfo* mutable_executor_infos(int index);
  inline ::mesos::ExecutorInfo* add_executor_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo >&
      executor_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo >*
      mutable_executor_infos();

  // repeated .mesos.internal.Task tasks = 3;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 3;
  inline const ::mesos::internal::Task& tasks(int index) const;
  inline ::mesos::internal::Task* mutable_tasks(int index);
  inline ::mesos::internal::Task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >*
      mutable_tasks();

  // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
  inline int completed_frameworks_size() const;
  inline void clear_completed_frameworks();
  static const int kCompletedFrameworksFieldNumber = 5;
  inline const ::mesos::internal::Archive_Framework& completed_frameworks(int index) const;
  inline ::mesos::internal::Archive_Framework* mutable_completed_frameworks(int index);
  inline ::mesos::internal::Archive_Framework* add_completed_frameworks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework >&
      completed_frameworks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework >*
      mutable_completed_frameworks();

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mesos.internal.ReregisterSlaveMessage)
 private:
  inline void set_has_slave();
  inline void clear_has_slave();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveInfo* slave_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > checkpointed_resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo > executor_infos_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task > tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework > completed_frameworks_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ReregisterSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class SlaveRegisteredMessage : public ::google::protobuf::Message {
 public:
  SlaveRegisteredMessage();
  virtual ~SlaveRegisteredMessage();

  SlaveRegisteredMessage(const SlaveRegisteredMessage& from);

  inline SlaveRegisteredMessage& operator=(const SlaveRegisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveRegisteredMessage& default_instance();

  void Swap(SlaveRegisteredMessage* other);

  // implements Message ----------------------------------------------

  SlaveRegisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveRegisteredMessage& from);
  void MergeFrom(const SlaveRegisteredMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.internal.MasterSlaveConnection connection = 2;
  inline bool has_connection() const;
  inline void clear_connection();
  static const int kConnectionFieldNumber = 2;
  inline const ::mesos::internal::MasterSlaveConnection& connection() const;
  inline ::mesos::internal::MasterSlaveConnection* mutable_connection();
  inline ::mesos::internal::MasterSlaveConnection* release_connection();
  inline void set_allocated_connection(::mesos::internal::MasterSlaveConnection* connection);

  // @@protoc_insertion_point(class_scope:mesos.internal.SlaveRegisteredMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_connection();
  inline void clear_has_connection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::internal::MasterSlaveConnection* connection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SlaveRegisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class SlaveReregisteredMessage : public ::google::protobuf::Message {
 public:
  SlaveReregisteredMessage();
  virtual ~SlaveReregisteredMessage();

  SlaveReregisteredMessage(const SlaveReregisteredMessage& from);

  inline SlaveReregisteredMessage& operator=(const SlaveReregisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveReregisteredMessage& default_instance();

  void Swap(SlaveReregisteredMessage* other);

  // implements Message ----------------------------------------------

  SlaveReregisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveReregisteredMessage& from);
  void MergeFrom(const SlaveReregisteredMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
  inline int reconciliations_size() const;
  inline void clear_reconciliations();
  static const int kReconciliationsFieldNumber = 2;
  inline const ::mesos::internal::ReconcileTasksMessage& reconciliations(int index) const;
  inline ::mesos::internal::ReconcileTasksMessage* mutable_reconciliations(int index);
  inline ::mesos::internal::ReconcileTasksMessage* add_reconciliations();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::ReconcileTasksMessage >&
      reconciliations() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::ReconcileTasksMessage >*
      mutable_reconciliations();

  // optional .mesos.internal.MasterSlaveConnection connection = 3;
  inline bool has_connection() const;
  inline void clear_connection();
  static const int kConnectionFieldNumber = 3;
  inline const ::mesos::internal::MasterSlaveConnection& connection() const;
  inline ::mesos::internal::MasterSlaveConnection* mutable_connection();
  inline ::mesos::internal::MasterSlaveConnection* release_connection();
  inline void set_allocated_connection(::mesos::internal::MasterSlaveConnection* connection);

  // @@protoc_insertion_point(class_scope:mesos.internal.SlaveReregisteredMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_connection();
  inline void clear_has_connection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::ReconcileTasksMessage > reconciliations_;
  ::mesos::internal::MasterSlaveConnection* connection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SlaveReregisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterSlaveMessage : public ::google::protobuf::Message {
 public:
  UnregisterSlaveMessage();
  virtual ~UnregisterSlaveMessage();

  UnregisterSlaveMessage(const UnregisterSlaveMessage& from);

  inline UnregisterSlaveMessage& operator=(const UnregisterSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnregisterSlaveMessage& default_instance();

  void Swap(UnregisterSlaveMessage* other);

  // implements Message ----------------------------------------------

  UnregisterSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnregisterSlaveMessage& from);
  void MergeFrom(const UnregisterSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.UnregisterSlaveMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static UnregisterSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class MasterSlaveConnection : public ::google::protobuf::Message {
 public:
  MasterSlaveConnection();
  virtual ~MasterSlaveConnection();

  MasterSlaveConnection(const MasterSlaveConnection& from);

  inline MasterSlaveConnection& operator=(const MasterSlaveConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterSlaveConnection& default_instance();

  void Swap(MasterSlaveConnection* other);

  // implements Message ----------------------------------------------

  MasterSlaveConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterSlaveConnection& from);
  void MergeFrom(const MasterSlaveConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double total_ping_timeout_seconds = 1;
  inline bool has_total_ping_timeout_seconds() const;
  inline void clear_total_ping_timeout_seconds();
  static const int kTotalPingTimeoutSecondsFieldNumber = 1;
  inline double total_ping_timeout_seconds() const;
  inline void set_total_ping_timeout_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.internal.MasterSlaveConnection)
 private:
  inline void set_has_total_ping_timeout_seconds();
  inline void clear_has_total_ping_timeout_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double total_ping_timeout_seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static MasterSlaveConnection* default_instance_;
};
// -------------------------------------------------------------------

class PingSlaveMessage : public ::google::protobuf::Message {
 public:
  PingSlaveMessage();
  virtual ~PingSlaveMessage();

  PingSlaveMessage(const PingSlaveMessage& from);

  inline PingSlaveMessage& operator=(const PingSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingSlaveMessage& default_instance();

  void Swap(PingSlaveMessage* other);

  // implements Message ----------------------------------------------

  PingSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingSlaveMessage& from);
  void MergeFrom(const PingSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool connected = 1;
  inline bool has_connected() const;
  inline void clear_connected();
  static const int kConnectedFieldNumber = 1;
  inline bool connected() const;
  inline void set_connected(bool value);

  // @@protoc_insertion_point(class_scope:mesos.internal.PingSlaveMessage)
 private:
  inline void set_has_connected();
  inline void clear_has_connected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool connected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static PingSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class PongSlaveMessage : public ::google::protobuf::Message {
 public:
  PongSlaveMessage();
  virtual ~PongSlaveMessage();

  PongSlaveMessage(const PongSlaveMessage& from);

  inline PongSlaveMessage& operator=(const PongSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PongSlaveMessage& default_instance();

  void Swap(PongSlaveMessage* other);

  // implements Message ----------------------------------------------

  PongSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PongSlaveMessage& from);
  void MergeFrom(const PongSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.internal.PongSlaveMessage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static PongSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownFrameworkMessage : public ::google::protobuf::Message {
 public:
  ShutdownFrameworkMessage();
  virtual ~ShutdownFrameworkMessage();

  ShutdownFrameworkMessage(const ShutdownFrameworkMessage& from);

  inline ShutdownFrameworkMessage& operator=(const ShutdownFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownFrameworkMessage& default_instance();

  void Swap(ShutdownFrameworkMessage* other);

  // implements Message ----------------------------------------------

  ShutdownFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownFrameworkMessage& from);
  void MergeFrom(const ShutdownFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.ShutdownFrameworkMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ShutdownFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownExecutorMessage : public ::google::protobuf::Message {
 public:
  ShutdownExecutorMessage();
  virtual ~ShutdownExecutorMessage();

  ShutdownExecutorMessage(const ShutdownExecutorMessage& from);

  inline ShutdownExecutorMessage& operator=(const ShutdownExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownExecutorMessage& default_instance();

  void Swap(ShutdownExecutorMessage* other);

  // implements Message ----------------------------------------------

  ShutdownExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownExecutorMessage& from);
  void MergeFrom(const ShutdownExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.ExecutorID executor_id = 1;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.ShutdownExecutorMessage)
 private:
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ExecutorID* executor_id_;
  ::mesos::FrameworkID* framework_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ShutdownExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class UpdateFrameworkMessage : public ::google::protobuf::Message {
 public:
  UpdateFrameworkMessage();
  virtual ~UpdateFrameworkMessage();

  UpdateFrameworkMessage(const UpdateFrameworkMessage& from);

  inline UpdateFrameworkMessage& operator=(const UpdateFrameworkMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateFrameworkMessage& default_instance();

  void Swap(UpdateFrameworkMessage* other);

  // implements Message ----------------------------------------------

  UpdateFrameworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateFrameworkMessage& from);
  void MergeFrom(const UpdateFrameworkMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional string pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // @@protoc_insertion_point(class_scope:mesos.internal.UpdateFrameworkMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::std::string* pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static UpdateFrameworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class CheckpointResourcesMessage : public ::google::protobuf::Message {
 public:
  CheckpointResourcesMessage();
  virtual ~CheckpointResourcesMessage();

  CheckpointResourcesMessage(const CheckpointResourcesMessage& from);

  inline CheckpointResourcesMessage& operator=(const CheckpointResourcesMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckpointResourcesMessage& default_instance();

  void Swap(CheckpointResourcesMessage* other);

  // implements Message ----------------------------------------------

  CheckpointResourcesMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckpointResourcesMessage& from);
  void MergeFrom(const CheckpointResourcesMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 1;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.internal.CheckpointResourcesMessage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static CheckpointResourcesMessage* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSlaveMessage : public ::google::protobuf::Message {
 public:
  UpdateSlaveMessage();
  virtual ~UpdateSlaveMessage();

  UpdateSlaveMessage(const UpdateSlaveMessage& from);

  inline UpdateSlaveMessage& operator=(const UpdateSlaveMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSlaveMessage& default_instance();

  void Swap(UpdateSlaveMessage* other);

  // implements Message ----------------------------------------------

  UpdateSlaveMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSlaveMessage& from);
  void MergeFrom(const UpdateSlaveMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // repeated .mesos.Resource oversubscribed_resources = 2;
  inline int oversubscribed_resources_size() const;
  inline void clear_oversubscribed_resources();
  static const int kOversubscribedResourcesFieldNumber = 2;
  inline const ::mesos::Resource& oversubscribed_resources(int index) const;
  inline ::mesos::Resource* mutable_oversubscribed_resources(int index);
  inline ::mesos::Resource* add_oversubscribed_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      oversubscribed_resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_oversubscribed_resources();

  // @@protoc_insertion_point(class_scope:mesos.internal.UpdateSlaveMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > oversubscribed_resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static UpdateSlaveMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegisterExecutorMessage : public ::google::protobuf::Message {
 public:
  RegisterExecutorMessage();
  virtual ~RegisterExecutorMessage();

  RegisterExecutorMessage(const RegisterExecutorMessage& from);

  inline RegisterExecutorMessage& operator=(const RegisterExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterExecutorMessage& default_instance();

  void Swap(RegisterExecutorMessage* other);

  // implements Message ----------------------------------------------

  RegisterExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterExecutorMessage& from);
  void MergeFrom(const RegisterExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.RegisterExecutorMessage)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorRegisteredMessage : public ::google::protobuf::Message {
 public:
  ExecutorRegisteredMessage();
  virtual ~ExecutorRegisteredMessage();

  ExecutorRegisteredMessage(const ExecutorRegisteredMessage& from);

  inline ExecutorRegisteredMessage& operator=(const ExecutorRegisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorRegisteredMessage& default_instance();

  void Swap(ExecutorRegisteredMessage* other);

  // implements Message ----------------------------------------------

  ExecutorRegisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorRegisteredMessage& from);
  void MergeFrom(const ExecutorRegisteredMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorInfo executor_info = 2;
  inline bool has_executor_info() const;
  inline void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 2;
  inline const ::mesos::ExecutorInfo& executor_info() const;
  inline ::mesos::ExecutorInfo* mutable_executor_info();
  inline ::mesos::ExecutorInfo* release_executor_info();
  inline void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);

  // required .mesos.FrameworkID framework_id = 3;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.FrameworkInfo framework_info = 4;
  inline bool has_framework_info() const;
  inline void clear_framework_info();
  static const int kFrameworkInfoFieldNumber = 4;
  inline const ::mesos::FrameworkInfo& framework_info() const;
  inline ::mesos::FrameworkInfo* mutable_framework_info();
  inline ::mesos::FrameworkInfo* release_framework_info();
  inline void set_allocated_framework_info(::mesos::FrameworkInfo* framework_info);

  // required .mesos.SlaveID slave_id = 5;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.SlaveInfo slave_info = 6;
  inline bool has_slave_info() const;
  inline void clear_slave_info();
  static const int kSlaveInfoFieldNumber = 6;
  inline const ::mesos::SlaveInfo& slave_info() const;
  inline ::mesos::SlaveInfo* mutable_slave_info();
  inline ::mesos::SlaveInfo* release_slave_info();
  inline void set_allocated_slave_info(::mesos::SlaveInfo* slave_info);

  // @@protoc_insertion_point(class_scope:mesos.internal.ExecutorRegisteredMessage)
 private:
  inline void set_has_executor_info();
  inline void clear_has_executor_info();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_framework_info();
  inline void clear_has_framework_info();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_slave_info();
  inline void clear_has_slave_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ExecutorInfo* executor_info_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::FrameworkInfo* framework_info_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::SlaveInfo* slave_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ExecutorRegisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorReregisteredMessage : public ::google::protobuf::Message {
 public:
  ExecutorReregisteredMessage();
  virtual ~ExecutorReregisteredMessage();

  ExecutorReregisteredMessage(const ExecutorReregisteredMessage& from);

  inline ExecutorReregisteredMessage& operator=(const ExecutorReregisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorReregisteredMessage& default_instance();

  void Swap(ExecutorReregisteredMessage* other);

  // implements Message ----------------------------------------------

  ExecutorReregisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorReregisteredMessage& from);
  void MergeFrom(const ExecutorReregisteredMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.SlaveInfo slave_info = 2;
  inline bool has_slave_info() const;
  inline void clear_slave_info();
  static const int kSlaveInfoFieldNumber = 2;
  inline const ::mesos::SlaveInfo& slave_info() const;
  inline ::mesos::SlaveInfo* mutable_slave_info();
  inline ::mesos::SlaveInfo* release_slave_info();
  inline void set_allocated_slave_info(::mesos::SlaveInfo* slave_info);

  // @@protoc_insertion_point(class_scope:mesos.internal.ExecutorReregisteredMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_slave_info();
  inline void clear_has_slave_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::SlaveInfo* slave_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ExecutorReregisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class ExitedExecutorMessage : public ::google::protobuf::Message {
 public:
  ExitedExecutorMessage();
  virtual ~ExitedExecutorMessage();

  ExitedExecutorMessage(const ExitedExecutorMessage& from);

  inline ExitedExecutorMessage& operator=(const ExitedExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExitedExecutorMessage& default_instance();

  void Swap(ExitedExecutorMessage* other);

  // implements Message ----------------------------------------------

  ExitedExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExitedExecutorMessage& from);
  void MergeFrom(const ExitedExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.internal.ExitedExecutorMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ExitedExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReconnectExecutorMessage : public ::google::protobuf::Message {
 public:
  ReconnectExecutorMessage();
  virtual ~ReconnectExecutorMessage();

  ReconnectExecutorMessage(const ReconnectExecutorMessage& from);

  inline ReconnectExecutorMessage& operator=(const ReconnectExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReconnectExecutorMessage& default_instance();

  void Swap(ReconnectExecutorMessage* other);

  // implements Message ----------------------------------------------

  ReconnectExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReconnectExecutorMessage& from);
  void MergeFrom(const ReconnectExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // @@protoc_insertion_point(class_scope:mesos.internal.ReconnectExecutorMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ReconnectExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReregisterExecutorMessage : public ::google::protobuf::Message {
 public:
  ReregisterExecutorMessage();
  virtual ~ReregisterExecutorMessage();

  ReregisterExecutorMessage(const ReregisterExecutorMessage& from);

  inline ReregisterExecutorMessage& operator=(const ReregisterExecutorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReregisterExecutorMessage& default_instance();

  void Swap(ReregisterExecutorMessage* other);

  // implements Message ----------------------------------------------

  ReregisterExecutorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReregisterExecutorMessage& from);
  void MergeFrom(const ReregisterExecutorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorID executor_id = 1;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // repeated .mesos.TaskInfo tasks = 3;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 3;
  inline const ::mesos::TaskInfo& tasks(int index) const;
  inline ::mesos::TaskInfo* mutable_tasks(int index);
  inline ::mesos::TaskInfo* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
      mutable_tasks();

  // repeated .mesos.internal.StatusUpdate updates = 4;
  inline int updates_size() const;
  inline void clear_updates();
  static const int kUpdatesFieldNumber = 4;
  inline const ::mesos::internal::StatusUpdate& updates(int index) const;
  inline ::mesos::internal::StatusUpdate* mutable_updates(int index);
  inline ::mesos::internal::StatusUpdate* add_updates();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::StatusUpdate >&
      updates() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::StatusUpdate >*
      mutable_updates();

  // @@protoc_insertion_point(class_scope:mesos.internal.ReregisterExecutorMessage)
 private:
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ExecutorID* executor_id_;
  ::mesos::FrameworkID* framework_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo > tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::StatusUpdate > updates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ReregisterExecutorMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownMessage : public ::google::protobuf::Message {
 public:
  ShutdownMessage();
  virtual ~ShutdownMessage();

  ShutdownMessage(const ShutdownMessage& from);

  inline ShutdownMessage& operator=(const ShutdownMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownMessage& default_instance();

  void Swap(ShutdownMessage* other);

  // implements Message ----------------------------------------------

  ShutdownMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownMessage& from);
  void MergeFrom(const ShutdownMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:mesos.internal.ShutdownMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ShutdownMessage* default_instance_;
};
// -------------------------------------------------------------------

class Archive_Framework : public ::google::protobuf::Message {
 public:
  Archive_Framework();
  virtual ~Archive_Framework();

  Archive_Framework(const Archive_Framework& from);

  inline Archive_Framework& operator=(const Archive_Framework& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Archive_Framework& default_instance();

  void Swap(Archive_Framework* other);

  // implements Message ----------------------------------------------

  Archive_Framework* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Archive_Framework& from);
  void MergeFrom(const Archive_Framework& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkInfo framework_info = 1;
  inline bool has_framework_info() const;
  inline void clear_framework_info();
  static const int kFrameworkInfoFieldNumber = 1;
  inline const ::mesos::FrameworkInfo& framework_info() const;
  inline ::mesos::FrameworkInfo* mutable_framework_info();
  inline ::mesos::FrameworkInfo* release_framework_info();
  inline void set_allocated_framework_info(::mesos::FrameworkInfo* framework_info);

  // optional string pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // repeated .mesos.internal.Task tasks = 3;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 3;
  inline const ::mesos::internal::Task& tasks(int index) const;
  inline ::mesos::internal::Task* mutable_tasks(int index);
  inline ::mesos::internal::Task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:mesos.internal.Archive.Framework)
 private:
  inline void set_has_framework_info();
  inline void clear_has_framework_info();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkInfo* framework_info_;
  ::std::string* pid_;
  ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task > tasks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Archive_Framework* default_instance_;
};
// -------------------------------------------------------------------

class Archive : public ::google::protobuf::Message {
 public:
  Archive();
  virtual ~Archive();

  Archive(const Archive& from);

  inline Archive& operator=(const Archive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Archive& default_instance();

  void Swap(Archive* other);

  // implements Message ----------------------------------------------

  Archive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Archive& from);
  void MergeFrom(const Archive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Archive_Framework Framework;

  // accessors -------------------------------------------------------

  // repeated .mesos.internal.Archive.Framework frameworks = 1;
  inline int frameworks_size() const;
  inline void clear_frameworks();
  static const int kFrameworksFieldNumber = 1;
  inline const ::mesos::internal::Archive_Framework& frameworks(int index) const;
  inline ::mesos::internal::Archive_Framework* mutable_frameworks(int index);
  inline ::mesos::internal::Archive_Framework* add_frameworks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework >&
      frameworks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework >*
      mutable_frameworks();

  // @@protoc_insertion_point(class_scope:mesos.internal.Archive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework > frameworks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Archive* default_instance_;
};
// -------------------------------------------------------------------

class TaskHealthStatus : public ::google::protobuf::Message {
 public:
  TaskHealthStatus();
  virtual ~TaskHealthStatus();

  TaskHealthStatus(const TaskHealthStatus& from);

  inline TaskHealthStatus& operator=(const TaskHealthStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskHealthStatus& default_instance();

  void Swap(TaskHealthStatus* other);

  // implements Message ----------------------------------------------

  TaskHealthStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskHealthStatus& from);
  void MergeFrom(const TaskHealthStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required bool healthy = 2;
  inline bool has_healthy() const;
  inline void clear_healthy();
  static const int kHealthyFieldNumber = 2;
  inline bool healthy() const;
  inline void set_healthy(bool value);

  // optional bool kill_task = 3 [default = false];
  inline bool has_kill_task() const;
  inline void clear_kill_task();
  static const int kKillTaskFieldNumber = 3;
  inline bool kill_task() const;
  inline void set_kill_task(bool value);

  // optional int32 consecutive_failures = 4;
  inline bool has_consecutive_failures() const;
  inline void clear_consecutive_failures();
  static const int kConsecutiveFailuresFieldNumber = 4;
  inline ::google::protobuf::int32 consecutive_failures() const;
  inline void set_consecutive_failures(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.internal.TaskHealthStatus)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_healthy();
  inline void clear_has_healthy();
  inline void set_has_kill_task();
  inline void clear_has_kill_task();
  inline void set_has_consecutive_failures();
  inline void clear_has_consecutive_failures();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::TaskID* task_id_;
  bool healthy_;
  bool kill_task_;
  ::google::protobuf::int32 consecutive_failures_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TaskHealthStatus* default_instance_;
};
// -------------------------------------------------------------------

class HookExecuted : public ::google::protobuf::Message {
 public:
  HookExecuted();
  virtual ~HookExecuted();

  HookExecuted(const HookExecuted& from);

  inline HookExecuted& operator=(const HookExecuted& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HookExecuted& default_instance();

  void Swap(HookExecuted* other);

  // implements Message ----------------------------------------------

  HookExecuted* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HookExecuted& from);
  void MergeFrom(const HookExecuted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string module = 1;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 1;
  inline const ::std::string& module() const;
  inline void set_module(const ::std::string& value);
  inline void set_module(const char* value);
  inline void set_module(const char* value, size_t size);
  inline ::std::string* mutable_module();
  inline ::std::string* release_module();
  inline void set_allocated_module(::std::string* module);

  // @@protoc_insertion_point(class_scope:mesos.internal.HookExecuted)
 private:
  inline void set_has_module();
  inline void clear_has_module();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* module_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2fmessages_2eproto();
  friend void protobuf_AssignDesc_messages_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_messages_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static HookExecuted* default_instance_;
};
// ===================================================================


// ===================================================================

// Task

// required string name = 1;
inline bool Task::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Task::name() const {
  return *name_;
}
inline void Task::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Task::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.TaskID task_id = 2;
inline bool Task::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& Task::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* Task::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* Task::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void Task::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// required .mesos.FrameworkID framework_id = 3;
inline bool Task::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Task::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Task::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* Task::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Task::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// optional .mesos.ExecutorID executor_id = 4;
inline bool Task::has_executor_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_executor_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Task::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Task::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* Task::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Task::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// required .mesos.SlaveID slave_id = 5;
inline bool Task::has_slave_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task::set_has_slave_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Task::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Task::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Task::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Task::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.TaskState state = 6;
inline bool Task::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Task::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Task::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Task::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState Task::state() const {
  return static_cast< ::mesos::TaskState >(state_);
}
inline void Task::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .mesos.Resource resources = 7;
inline int Task::resources_size() const {
  return resources_.size();
}
inline void Task::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Task::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Task::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Task::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Task::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Task::mutable_resources() {
  return &resources_;
}

// repeated .mesos.TaskStatus statuses = 8;
inline int Task::statuses_size() const {
  return statuses_.size();
}
inline void Task::clear_statuses() {
  statuses_.Clear();
}
inline const ::mesos::TaskStatus& Task::statuses(int index) const {
  return statuses_.Get(index);
}
inline ::mesos::TaskStatus* Task::mutable_statuses(int index) {
  return statuses_.Mutable(index);
}
inline ::mesos::TaskStatus* Task::add_statuses() {
  return statuses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
Task::statuses() const {
  return statuses_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
Task::mutable_statuses() {
  return &statuses_;
}

// optional .mesos.TaskState status_update_state = 9;
inline bool Task::has_status_update_state() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Task::set_has_status_update_state() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Task::clear_has_status_update_state() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Task::clear_status_update_state() {
  status_update_state_ = 6;
  clear_has_status_update_state();
}
inline ::mesos::TaskState Task::status_update_state() const {
  return static_cast< ::mesos::TaskState >(status_update_state_);
}
inline void Task::set_status_update_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_status_update_state();
  status_update_state_ = value;
}

// optional bytes status_update_uuid = 10;
inline bool Task::has_status_update_uuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Task::set_has_status_update_uuid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Task::clear_has_status_update_uuid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Task::clear_status_update_uuid() {
  if (status_update_uuid_ != &::google::protobuf::internal::kEmptyString) {
    status_update_uuid_->clear();
  }
  clear_has_status_update_uuid();
}
inline const ::std::string& Task::status_update_uuid() const {
  return *status_update_uuid_;
}
inline void Task::set_status_update_uuid(const ::std::string& value) {
  set_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::kEmptyString) {
    status_update_uuid_ = new ::std::string;
  }
  status_update_uuid_->assign(value);
}
inline void Task::set_status_update_uuid(const char* value) {
  set_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::kEmptyString) {
    status_update_uuid_ = new ::std::string;
  }
  status_update_uuid_->assign(value);
}
inline void Task::set_status_update_uuid(const void* value, size_t size) {
  set_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::kEmptyString) {
    status_update_uuid_ = new ::std::string;
  }
  status_update_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_status_update_uuid() {
  set_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::kEmptyString) {
    status_update_uuid_ = new ::std::string;
  }
  return status_update_uuid_;
}
inline ::std::string* Task::release_status_update_uuid() {
  clear_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_update_uuid_;
    status_update_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task::set_allocated_status_update_uuid(::std::string* status_update_uuid) {
  if (status_update_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete status_update_uuid_;
  }
  if (status_update_uuid) {
    set_has_status_update_uuid();
    status_update_uuid_ = status_update_uuid;
  } else {
    clear_has_status_update_uuid();
    status_update_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.Labels labels = 11;
inline bool Task::has_labels() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Task::set_has_labels() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Task::clear_has_labels() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Task::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Task::labels() const {
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* Task::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  return labels_;
}
inline ::mesos::Labels* Task::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void Task::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
}

// optional .mesos.DiscoveryInfo discovery = 12;
inline bool Task::has_discovery() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Task::set_has_discovery() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Task::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Task::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& Task::discovery() const {
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
inline ::mesos::DiscoveryInfo* Task::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) discovery_ = new ::mesos::DiscoveryInfo;
  return discovery_;
}
inline ::mesos::DiscoveryInfo* Task::release_discovery() {
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline void Task::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
}

// -------------------------------------------------------------------

// StatusUpdate

// required .mesos.FrameworkID framework_id = 1;
inline bool StatusUpdate::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusUpdate::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusUpdate::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusUpdate::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& StatusUpdate::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* StatusUpdate::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* StatusUpdate::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void StatusUpdate::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// optional .mesos.ExecutorID executor_id = 2;
inline bool StatusUpdate::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusUpdate::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusUpdate::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusUpdate::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& StatusUpdate::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* StatusUpdate::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* StatusUpdate::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void StatusUpdate::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional .mesos.SlaveID slave_id = 3;
inline bool StatusUpdate::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusUpdate::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusUpdate::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusUpdate::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& StatusUpdate::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* StatusUpdate::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* StatusUpdate::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void StatusUpdate::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.TaskStatus status = 4;
inline bool StatusUpdate::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusUpdate::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusUpdate::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusUpdate::clear_status() {
  if (status_ != NULL) status_->::mesos::TaskStatus::Clear();
  clear_has_status();
}
inline const ::mesos::TaskStatus& StatusUpdate::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::mesos::TaskStatus* StatusUpdate::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::mesos::TaskStatus;
  return status_;
}
inline ::mesos::TaskStatus* StatusUpdate::release_status() {
  clear_has_status();
  ::mesos::TaskStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void StatusUpdate::set_allocated_status(::mesos::TaskStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// required double timestamp = 5;
inline bool StatusUpdate::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StatusUpdate::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StatusUpdate::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StatusUpdate::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double StatusUpdate::timestamp() const {
  return timestamp_;
}
inline void StatusUpdate::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional bytes uuid = 6;
inline bool StatusUpdate::has_uuid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StatusUpdate::set_has_uuid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StatusUpdate::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StatusUpdate::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& StatusUpdate::uuid() const {
  return *uuid_;
}
inline void StatusUpdate::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdate::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdate::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusUpdate::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* StatusUpdate::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusUpdate::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.TaskState latest_state = 7;
inline bool StatusUpdate::has_latest_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StatusUpdate::set_has_latest_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StatusUpdate::clear_has_latest_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StatusUpdate::clear_latest_state() {
  latest_state_ = 6;
  clear_has_latest_state();
}
inline ::mesos::TaskState StatusUpdate::latest_state() const {
  return static_cast< ::mesos::TaskState >(latest_state_);
}
inline void StatusUpdate::set_latest_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_latest_state();
  latest_state_ = value;
}

// -------------------------------------------------------------------

// StatusUpdateRecord

// required .mesos.internal.StatusUpdateRecord.Type type = 1;
inline bool StatusUpdateRecord::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusUpdateRecord::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusUpdateRecord::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusUpdateRecord::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::internal::StatusUpdateRecord_Type StatusUpdateRecord::type() const {
  return static_cast< ::mesos::internal::StatusUpdateRecord_Type >(type_);
}
inline void StatusUpdateRecord::set_type(::mesos::internal::StatusUpdateRecord_Type value) {
  assert(::mesos::internal::StatusUpdateRecord_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.internal.StatusUpdate update = 2;
inline bool StatusUpdateRecord::has_update() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusUpdateRecord::set_has_update() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusUpdateRecord::clear_has_update() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusUpdateRecord::clear_update() {
  if (update_ != NULL) update_->::mesos::internal::StatusUpdate::Clear();
  clear_has_update();
}
inline const ::mesos::internal::StatusUpdate& StatusUpdateRecord::update() const {
  return update_ != NULL ? *update_ : *default_instance_->update_;
}
inline ::mesos::internal::StatusUpdate* StatusUpdateRecord::mutable_update() {
  set_has_update();
  if (update_ == NULL) update_ = new ::mesos::internal::StatusUpdate;
  return update_;
}
inline ::mesos::internal::StatusUpdate* StatusUpdateRecord::release_update() {
  clear_has_update();
  ::mesos::internal::StatusUpdate* temp = update_;
  update_ = NULL;
  return temp;
}
inline void StatusUpdateRecord::set_allocated_update(::mesos::internal::StatusUpdate* update) {
  delete update_;
  update_ = update;
  if (update) {
    set_has_update();
  } else {
    clear_has_update();
  }
}

// optional bytes uuid = 3;
inline bool StatusUpdateRecord::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusUpdateRecord::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusUpdateRecord::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusUpdateRecord::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& StatusUpdateRecord::uuid() const {
  return *uuid_;
}
inline void StatusUpdateRecord::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdateRecord::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdateRecord::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusUpdateRecord::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* StatusUpdateRecord::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusUpdateRecord::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SubmitSchedulerRequest

// required string name = 1;
inline bool SubmitSchedulerRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitSchedulerRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitSchedulerRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitSchedulerRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SubmitSchedulerRequest::name() const {
  return *name_;
}
inline void SubmitSchedulerRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SubmitSchedulerRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SubmitSchedulerRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubmitSchedulerRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SubmitSchedulerRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SubmitSchedulerRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SubmitSchedulerResponse

// required bool okay = 1;
inline bool SubmitSchedulerResponse::has_okay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitSchedulerResponse::set_has_okay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitSchedulerResponse::clear_has_okay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitSchedulerResponse::clear_okay() {
  okay_ = false;
  clear_has_okay();
}
inline bool SubmitSchedulerResponse::okay() const {
  return okay_;
}
inline void SubmitSchedulerResponse::set_okay(bool value) {
  set_has_okay();
  okay_ = value;
}

// -------------------------------------------------------------------

// ExecutorToFrameworkMessage

// required .mesos.SlaveID slave_id = 1;
inline bool ExecutorToFrameworkMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorToFrameworkMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorToFrameworkMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorToFrameworkMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ExecutorToFrameworkMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ExecutorToFrameworkMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ExecutorToFrameworkMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ExecutorToFrameworkMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool ExecutorToFrameworkMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorToFrameworkMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorToFrameworkMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorToFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ExecutorToFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExecutorToFrameworkMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ExecutorToFrameworkMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ExecutorToFrameworkMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.ExecutorID executor_id = 3;
inline bool ExecutorToFrameworkMessage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutorToFrameworkMessage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutorToFrameworkMessage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutorToFrameworkMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ExecutorToFrameworkMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExecutorToFrameworkMessage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ExecutorToFrameworkMessage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ExecutorToFrameworkMessage::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// required bytes data = 4;
inline bool ExecutorToFrameworkMessage::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutorToFrameworkMessage::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutorToFrameworkMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutorToFrameworkMessage::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ExecutorToFrameworkMessage::data() const {
  return *data_;
}
inline void ExecutorToFrameworkMessage::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorToFrameworkMessage::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorToFrameworkMessage::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorToFrameworkMessage::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ExecutorToFrameworkMessage::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorToFrameworkMessage::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FrameworkToExecutorMessage

// required .mesos.SlaveID slave_id = 1;
inline bool FrameworkToExecutorMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkToExecutorMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkToExecutorMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkToExecutorMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& FrameworkToExecutorMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* FrameworkToExecutorMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* FrameworkToExecutorMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void FrameworkToExecutorMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool FrameworkToExecutorMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkToExecutorMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkToExecutorMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkToExecutorMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& FrameworkToExecutorMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* FrameworkToExecutorMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* FrameworkToExecutorMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void FrameworkToExecutorMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.ExecutorID executor_id = 3;
inline bool FrameworkToExecutorMessage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameworkToExecutorMessage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameworkToExecutorMessage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameworkToExecutorMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& FrameworkToExecutorMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* FrameworkToExecutorMessage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* FrameworkToExecutorMessage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void FrameworkToExecutorMessage::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// required bytes data = 4;
inline bool FrameworkToExecutorMessage::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrameworkToExecutorMessage::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrameworkToExecutorMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrameworkToExecutorMessage::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& FrameworkToExecutorMessage::data() const {
  return *data_;
}
inline void FrameworkToExecutorMessage::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FrameworkToExecutorMessage::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FrameworkToExecutorMessage::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkToExecutorMessage::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* FrameworkToExecutorMessage::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkToExecutorMessage::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterFrameworkMessage

// required .mesos.FrameworkInfo framework = 1;
inline bool RegisterFrameworkMessage::has_framework() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterFrameworkMessage::set_has_framework() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterFrameworkMessage::clear_has_framework() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterFrameworkMessage::clear_framework() {
  if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
  clear_has_framework();
}
inline const ::mesos::FrameworkInfo& RegisterFrameworkMessage::framework() const {
  return framework_ != NULL ? *framework_ : *default_instance_->framework_;
}
inline ::mesos::FrameworkInfo* RegisterFrameworkMessage::mutable_framework() {
  set_has_framework();
  if (framework_ == NULL) framework_ = new ::mesos::FrameworkInfo;
  return framework_;
}
inline ::mesos::FrameworkInfo* RegisterFrameworkMessage::release_framework() {
  clear_has_framework();
  ::mesos::FrameworkInfo* temp = framework_;
  framework_ = NULL;
  return temp;
}
inline void RegisterFrameworkMessage::set_allocated_framework(::mesos::FrameworkInfo* framework) {
  delete framework_;
  framework_ = framework;
  if (framework) {
    set_has_framework();
  } else {
    clear_has_framework();
  }
}

// -------------------------------------------------------------------

// ReregisterFrameworkMessage

// required .mesos.FrameworkInfo framework = 2;
inline bool ReregisterFrameworkMessage::has_framework() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReregisterFrameworkMessage::set_has_framework() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReregisterFrameworkMessage::clear_has_framework() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReregisterFrameworkMessage::clear_framework() {
  if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
  clear_has_framework();
}
inline const ::mesos::FrameworkInfo& ReregisterFrameworkMessage::framework() const {
  return framework_ != NULL ? *framework_ : *default_instance_->framework_;
}
inline ::mesos::FrameworkInfo* ReregisterFrameworkMessage::mutable_framework() {
  set_has_framework();
  if (framework_ == NULL) framework_ = new ::mesos::FrameworkInfo;
  return framework_;
}
inline ::mesos::FrameworkInfo* ReregisterFrameworkMessage::release_framework() {
  clear_has_framework();
  ::mesos::FrameworkInfo* temp = framework_;
  framework_ = NULL;
  return temp;
}
inline void ReregisterFrameworkMessage::set_allocated_framework(::mesos::FrameworkInfo* framework) {
  delete framework_;
  framework_ = framework;
  if (framework) {
    set_has_framework();
  } else {
    clear_has_framework();
  }
}

// required bool failover = 3;
inline bool ReregisterFrameworkMessage::has_failover() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReregisterFrameworkMessage::set_has_failover() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReregisterFrameworkMessage::clear_has_failover() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReregisterFrameworkMessage::clear_failover() {
  failover_ = false;
  clear_has_failover();
}
inline bool ReregisterFrameworkMessage::failover() const {
  return failover_;
}
inline void ReregisterFrameworkMessage::set_failover(bool value) {
  set_has_failover();
  failover_ = value;
}

// -------------------------------------------------------------------

// FrameworkRegisteredMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool FrameworkRegisteredMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkRegisteredMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkRegisteredMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkRegisteredMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& FrameworkRegisteredMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* FrameworkRegisteredMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* FrameworkRegisteredMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void FrameworkRegisteredMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.MasterInfo master_info = 2;
inline bool FrameworkRegisteredMessage::has_master_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkRegisteredMessage::set_has_master_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkRegisteredMessage::clear_has_master_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkRegisteredMessage::clear_master_info() {
  if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
  clear_has_master_info();
}
inline const ::mesos::MasterInfo& FrameworkRegisteredMessage::master_info() const {
  return master_info_ != NULL ? *master_info_ : *default_instance_->master_info_;
}
inline ::mesos::MasterInfo* FrameworkRegisteredMessage::mutable_master_info() {
  set_has_master_info();
  if (master_info_ == NULL) master_info_ = new ::mesos::MasterInfo;
  return master_info_;
}
inline ::mesos::MasterInfo* FrameworkRegisteredMessage::release_master_info() {
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  master_info_ = NULL;
  return temp;
}
inline void FrameworkRegisteredMessage::set_allocated_master_info(::mesos::MasterInfo* master_info) {
  delete master_info_;
  master_info_ = master_info;
  if (master_info) {
    set_has_master_info();
  } else {
    clear_has_master_info();
  }
}

// -------------------------------------------------------------------

// FrameworkReregisteredMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool FrameworkReregisteredMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkReregisteredMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkReregisteredMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkReregisteredMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& FrameworkReregisteredMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* FrameworkReregisteredMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* FrameworkReregisteredMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void FrameworkReregisteredMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.MasterInfo master_info = 2;
inline bool FrameworkReregisteredMessage::has_master_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkReregisteredMessage::set_has_master_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkReregisteredMessage::clear_has_master_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkReregisteredMessage::clear_master_info() {
  if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
  clear_has_master_info();
}
inline const ::mesos::MasterInfo& FrameworkReregisteredMessage::master_info() const {
  return master_info_ != NULL ? *master_info_ : *default_instance_->master_info_;
}
inline ::mesos::MasterInfo* FrameworkReregisteredMessage::mutable_master_info() {
  set_has_master_info();
  if (master_info_ == NULL) master_info_ = new ::mesos::MasterInfo;
  return master_info_;
}
inline ::mesos::MasterInfo* FrameworkReregisteredMessage::release_master_info() {
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  master_info_ = NULL;
  return temp;
}
inline void FrameworkReregisteredMessage::set_allocated_master_info(::mesos::MasterInfo* master_info) {
  delete master_info_;
  master_info_ = master_info;
  if (master_info) {
    set_has_master_info();
  } else {
    clear_has_master_info();
  }
}

// -------------------------------------------------------------------

// UnregisterFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool UnregisterFrameworkMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterFrameworkMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterFrameworkMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& UnregisterFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* UnregisterFrameworkMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* UnregisterFrameworkMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void UnregisterFrameworkMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// -------------------------------------------------------------------

// DeactivateFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool DeactivateFrameworkMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeactivateFrameworkMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeactivateFrameworkMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeactivateFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& DeactivateFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* DeactivateFrameworkMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* DeactivateFrameworkMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void DeactivateFrameworkMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// -------------------------------------------------------------------

// ResourceRequestMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool ResourceRequestMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceRequestMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceRequestMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceRequestMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ResourceRequestMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ResourceRequestMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ResourceRequestMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ResourceRequestMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// repeated .mesos.Request requests = 2;
inline int ResourceRequestMessage::requests_size() const {
  return requests_.size();
}
inline void ResourceRequestMessage::clear_requests() {
  requests_.Clear();
}
inline const ::mesos::Request& ResourceRequestMessage::requests(int index) const {
  return requests_.Get(index);
}
inline ::mesos::Request* ResourceRequestMessage::mutable_requests(int index) {
  return requests_.Mutable(index);
}
inline ::mesos::Request* ResourceRequestMessage::add_requests() {
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Request >&
ResourceRequestMessage::requests() const {
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Request >*
ResourceRequestMessage::mutable_requests() {
  return &requests_;
}

// -------------------------------------------------------------------

// ResourceOffersMessage

// repeated .mesos.Offer offers = 1;
inline int ResourceOffersMessage::offers_size() const {
  return offers_.size();
}
inline void ResourceOffersMessage::clear_offers() {
  offers_.Clear();
}
inline const ::mesos::Offer& ResourceOffersMessage::offers(int index) const {
  return offers_.Get(index);
}
inline ::mesos::Offer* ResourceOffersMessage::mutable_offers(int index) {
  return offers_.Mutable(index);
}
inline ::mesos::Offer* ResourceOffersMessage::add_offers() {
  return offers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
ResourceOffersMessage::offers() const {
  return offers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
ResourceOffersMessage::mutable_offers() {
  return &offers_;
}

// repeated string pids = 2;
inline int ResourceOffersMessage::pids_size() const {
  return pids_.size();
}
inline void ResourceOffersMessage::clear_pids() {
  pids_.Clear();
}
inline const ::std::string& ResourceOffersMessage::pids(int index) const {
  return pids_.Get(index);
}
inline ::std::string* ResourceOffersMessage::mutable_pids(int index) {
  return pids_.Mutable(index);
}
inline void ResourceOffersMessage::set_pids(int index, const ::std::string& value) {
  pids_.Mutable(index)->assign(value);
}
inline void ResourceOffersMessage::set_pids(int index, const char* value) {
  pids_.Mutable(index)->assign(value);
}
inline void ResourceOffersMessage::set_pids(int index, const char* value, size_t size) {
  pids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceOffersMessage::add_pids() {
  return pids_.Add();
}
inline void ResourceOffersMessage::add_pids(const ::std::string& value) {
  pids_.Add()->assign(value);
}
inline void ResourceOffersMessage::add_pids(const char* value) {
  pids_.Add()->assign(value);
}
inline void ResourceOffersMessage::add_pids(const char* value, size_t size) {
  pids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResourceOffersMessage::pids() const {
  return pids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResourceOffersMessage::mutable_pids() {
  return &pids_;
}

// repeated .mesos.InverseOffer inverse_offers = 3;
inline int ResourceOffersMessage::inverse_offers_size() const {
  return inverse_offers_.size();
}
inline void ResourceOffersMessage::clear_inverse_offers() {
  inverse_offers_.Clear();
}
inline const ::mesos::InverseOffer& ResourceOffersMessage::inverse_offers(int index) const {
  return inverse_offers_.Get(index);
}
inline ::mesos::InverseOffer* ResourceOffersMessage::mutable_inverse_offers(int index) {
  return inverse_offers_.Mutable(index);
}
inline ::mesos::InverseOffer* ResourceOffersMessage::add_inverse_offers() {
  return inverse_offers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >&
ResourceOffersMessage::inverse_offers() const {
  return inverse_offers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >*
ResourceOffersMessage::mutable_inverse_offers() {
  return &inverse_offers_;
}

// -------------------------------------------------------------------

// LaunchTasksMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool LaunchTasksMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaunchTasksMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaunchTasksMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaunchTasksMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& LaunchTasksMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* LaunchTasksMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* LaunchTasksMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void LaunchTasksMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// repeated .mesos.TaskInfo tasks = 3;
inline int LaunchTasksMessage::tasks_size() const {
  return tasks_.size();
}
inline void LaunchTasksMessage::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::TaskInfo& LaunchTasksMessage::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::mesos::TaskInfo* LaunchTasksMessage::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::mesos::TaskInfo* LaunchTasksMessage::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
LaunchTasksMessage::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
LaunchTasksMessage::mutable_tasks() {
  return &tasks_;
}

// required .mesos.Filters filters = 5;
inline bool LaunchTasksMessage::has_filters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaunchTasksMessage::set_has_filters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaunchTasksMessage::clear_has_filters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaunchTasksMessage::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  clear_has_filters();
}
inline const ::mesos::Filters& LaunchTasksMessage::filters() const {
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* LaunchTasksMessage::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  return filters_;
}
inline ::mesos::Filters* LaunchTasksMessage::release_filters() {
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void LaunchTasksMessage::set_allocated_filters(::mesos::Filters* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
}

// repeated .mesos.OfferID offer_ids = 6;
inline int LaunchTasksMessage::offer_ids_size() const {
  return offer_ids_.size();
}
inline void LaunchTasksMessage::clear_offer_ids() {
  offer_ids_.Clear();
}
inline const ::mesos::OfferID& LaunchTasksMessage::offer_ids(int index) const {
  return offer_ids_.Get(index);
}
inline ::mesos::OfferID* LaunchTasksMessage::mutable_offer_ids(int index) {
  return offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* LaunchTasksMessage::add_offer_ids() {
  return offer_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
LaunchTasksMessage::offer_ids() const {
  return offer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
LaunchTasksMessage::mutable_offer_ids() {
  return &offer_ids_;
}

// -------------------------------------------------------------------

// RescindResourceOfferMessage

// required .mesos.OfferID offer_id = 1;
inline bool RescindResourceOfferMessage::has_offer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RescindResourceOfferMessage::set_has_offer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RescindResourceOfferMessage::clear_has_offer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RescindResourceOfferMessage::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  clear_has_offer_id();
}
inline const ::mesos::OfferID& RescindResourceOfferMessage::offer_id() const {
  return offer_id_ != NULL ? *offer_id_ : *default_instance_->offer_id_;
}
inline ::mesos::OfferID* RescindResourceOfferMessage::mutable_offer_id() {
  set_has_offer_id();
  if (offer_id_ == NULL) offer_id_ = new ::mesos::OfferID;
  return offer_id_;
}
inline ::mesos::OfferID* RescindResourceOfferMessage::release_offer_id() {
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  offer_id_ = NULL;
  return temp;
}
inline void RescindResourceOfferMessage::set_allocated_offer_id(::mesos::OfferID* offer_id) {
  delete offer_id_;
  offer_id_ = offer_id;
  if (offer_id) {
    set_has_offer_id();
  } else {
    clear_has_offer_id();
  }
}

// -------------------------------------------------------------------

// ReviveOffersMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool ReviveOffersMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReviveOffersMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReviveOffersMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReviveOffersMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ReviveOffersMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ReviveOffersMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ReviveOffersMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ReviveOffersMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// -------------------------------------------------------------------

// RunTaskMessage

// optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
inline bool RunTaskMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunTaskMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunTaskMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunTaskMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& RunTaskMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* RunTaskMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* RunTaskMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void RunTaskMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.FrameworkInfo framework = 2;
inline bool RunTaskMessage::has_framework() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunTaskMessage::set_has_framework() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunTaskMessage::clear_has_framework() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunTaskMessage::clear_framework() {
  if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
  clear_has_framework();
}
inline const ::mesos::FrameworkInfo& RunTaskMessage::framework() const {
  return framework_ != NULL ? *framework_ : *default_instance_->framework_;
}
inline ::mesos::FrameworkInfo* RunTaskMessage::mutable_framework() {
  set_has_framework();
  if (framework_ == NULL) framework_ = new ::mesos::FrameworkInfo;
  return framework_;
}
inline ::mesos::FrameworkInfo* RunTaskMessage::release_framework() {
  clear_has_framework();
  ::mesos::FrameworkInfo* temp = framework_;
  framework_ = NULL;
  return temp;
}
inline void RunTaskMessage::set_allocated_framework(::mesos::FrameworkInfo* framework) {
  delete framework_;
  framework_ = framework;
  if (framework) {
    set_has_framework();
  } else {
    clear_has_framework();
  }
}

// required .mesos.TaskInfo task = 4;
inline bool RunTaskMessage::has_task() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RunTaskMessage::set_has_task() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RunTaskMessage::clear_has_task() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RunTaskMessage::clear_task() {
  if (task_ != NULL) task_->::mesos::TaskInfo::Clear();
  clear_has_task();
}
inline const ::mesos::TaskInfo& RunTaskMessage::task() const {
  return task_ != NULL ? *task_ : *default_instance_->task_;
}
inline ::mesos::TaskInfo* RunTaskMessage::mutable_task() {
  set_has_task();
  if (task_ == NULL) task_ = new ::mesos::TaskInfo;
  return task_;
}
inline ::mesos::TaskInfo* RunTaskMessage::release_task() {
  clear_has_task();
  ::mesos::TaskInfo* temp = task_;
  task_ = NULL;
  return temp;
}
inline void RunTaskMessage::set_allocated_task(::mesos::TaskInfo* task) {
  delete task_;
  task_ = task;
  if (task) {
    set_has_task();
  } else {
    clear_has_task();
  }
}

// optional string pid = 3;
inline bool RunTaskMessage::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RunTaskMessage::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RunTaskMessage::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RunTaskMessage::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& RunTaskMessage::pid() const {
  return *pid_;
}
inline void RunTaskMessage::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void RunTaskMessage::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void RunTaskMessage::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunTaskMessage::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* RunTaskMessage::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RunTaskMessage::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KillTaskMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool KillTaskMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KillTaskMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KillTaskMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KillTaskMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& KillTaskMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* KillTaskMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* KillTaskMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void KillTaskMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.TaskID task_id = 2;
inline bool KillTaskMessage::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KillTaskMessage::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KillTaskMessage::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KillTaskMessage::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& KillTaskMessage::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* KillTaskMessage::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* KillTaskMessage::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void KillTaskMessage::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// -------------------------------------------------------------------

// StatusUpdateMessage

// required .mesos.internal.StatusUpdate update = 1;
inline bool StatusUpdateMessage::has_update() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusUpdateMessage::set_has_update() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusUpdateMessage::clear_has_update() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusUpdateMessage::clear_update() {
  if (update_ != NULL) update_->::mesos::internal::StatusUpdate::Clear();
  clear_has_update();
}
inline const ::mesos::internal::StatusUpdate& StatusUpdateMessage::update() const {
  return update_ != NULL ? *update_ : *default_instance_->update_;
}
inline ::mesos::internal::StatusUpdate* StatusUpdateMessage::mutable_update() {
  set_has_update();
  if (update_ == NULL) update_ = new ::mesos::internal::StatusUpdate;
  return update_;
}
inline ::mesos::internal::StatusUpdate* StatusUpdateMessage::release_update() {
  clear_has_update();
  ::mesos::internal::StatusUpdate* temp = update_;
  update_ = NULL;
  return temp;
}
inline void StatusUpdateMessage::set_allocated_update(::mesos::internal::StatusUpdate* update) {
  delete update_;
  update_ = update;
  if (update) {
    set_has_update();
  } else {
    clear_has_update();
  }
}

// optional string pid = 2;
inline bool StatusUpdateMessage::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusUpdateMessage::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusUpdateMessage::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusUpdateMessage::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& StatusUpdateMessage::pid() const {
  return *pid_;
}
inline void StatusUpdateMessage::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void StatusUpdateMessage::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void StatusUpdateMessage::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusUpdateMessage::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* StatusUpdateMessage::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusUpdateMessage::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StatusUpdateAcknowledgementMessage

// required .mesos.SlaveID slave_id = 1;
inline bool StatusUpdateAcknowledgementMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusUpdateAcknowledgementMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusUpdateAcknowledgementMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusUpdateAcknowledgementMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& StatusUpdateAcknowledgementMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* StatusUpdateAcknowledgementMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* StatusUpdateAcknowledgementMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void StatusUpdateAcknowledgementMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool StatusUpdateAcknowledgementMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusUpdateAcknowledgementMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusUpdateAcknowledgementMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusUpdateAcknowledgementMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& StatusUpdateAcknowledgementMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* StatusUpdateAcknowledgementMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* StatusUpdateAcknowledgementMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void StatusUpdateAcknowledgementMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.TaskID task_id = 3;
inline bool StatusUpdateAcknowledgementMessage::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusUpdateAcknowledgementMessage::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusUpdateAcknowledgementMessage::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusUpdateAcknowledgementMessage::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& StatusUpdateAcknowledgementMessage::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* StatusUpdateAcknowledgementMessage::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* StatusUpdateAcknowledgementMessage::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void StatusUpdateAcknowledgementMessage::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// required bytes uuid = 4;
inline bool StatusUpdateAcknowledgementMessage::has_uuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusUpdateAcknowledgementMessage::set_has_uuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusUpdateAcknowledgementMessage::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusUpdateAcknowledgementMessage::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& StatusUpdateAcknowledgementMessage::uuid() const {
  return *uuid_;
}
inline void StatusUpdateAcknowledgementMessage::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdateAcknowledgementMessage::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void StatusUpdateAcknowledgementMessage::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusUpdateAcknowledgementMessage::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* StatusUpdateAcknowledgementMessage::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusUpdateAcknowledgementMessage::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LostSlaveMessage

// required .mesos.SlaveID slave_id = 1;
inline bool LostSlaveMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LostSlaveMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LostSlaveMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LostSlaveMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& LostSlaveMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* LostSlaveMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* LostSlaveMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void LostSlaveMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// -------------------------------------------------------------------

// ReconcileTasksMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool ReconcileTasksMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconcileTasksMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconcileTasksMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconcileTasksMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ReconcileTasksMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ReconcileTasksMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ReconcileTasksMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ReconcileTasksMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// repeated .mesos.TaskStatus statuses = 2;
inline int ReconcileTasksMessage::statuses_size() const {
  return statuses_.size();
}
inline void ReconcileTasksMessage::clear_statuses() {
  statuses_.Clear();
}
inline const ::mesos::TaskStatus& ReconcileTasksMessage::statuses(int index) const {
  return statuses_.Get(index);
}
inline ::mesos::TaskStatus* ReconcileTasksMessage::mutable_statuses(int index) {
  return statuses_.Mutable(index);
}
inline ::mesos::TaskStatus* ReconcileTasksMessage::add_statuses() {
  return statuses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
ReconcileTasksMessage::statuses() const {
  return statuses_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
ReconcileTasksMessage::mutable_statuses() {
  return &statuses_;
}

// -------------------------------------------------------------------

// FrameworkErrorMessage

// required string message = 2;
inline bool FrameworkErrorMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkErrorMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkErrorMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkErrorMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& FrameworkErrorMessage::message() const {
  return *message_;
}
inline void FrameworkErrorMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void FrameworkErrorMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void FrameworkErrorMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkErrorMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* FrameworkErrorMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkErrorMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterSlaveMessage

// required .mesos.SlaveInfo slave = 1;
inline bool RegisterSlaveMessage::has_slave() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterSlaveMessage::set_has_slave() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterSlaveMessage::clear_has_slave() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterSlaveMessage::clear_slave() {
  if (slave_ != NULL) slave_->::mesos::SlaveInfo::Clear();
  clear_has_slave();
}
inline const ::mesos::SlaveInfo& RegisterSlaveMessage::slave() const {
  return slave_ != NULL ? *slave_ : *default_instance_->slave_;
}
inline ::mesos::SlaveInfo* RegisterSlaveMessage::mutable_slave() {
  set_has_slave();
  if (slave_ == NULL) slave_ = new ::mesos::SlaveInfo;
  return slave_;
}
inline ::mesos::SlaveInfo* RegisterSlaveMessage::release_slave() {
  clear_has_slave();
  ::mesos::SlaveInfo* temp = slave_;
  slave_ = NULL;
  return temp;
}
inline void RegisterSlaveMessage::set_allocated_slave(::mesos::SlaveInfo* slave) {
  delete slave_;
  slave_ = slave;
  if (slave) {
    set_has_slave();
  } else {
    clear_has_slave();
  }
}

// repeated .mesos.Resource checkpointed_resources = 3;
inline int RegisterSlaveMessage::checkpointed_resources_size() const {
  return checkpointed_resources_.size();
}
inline void RegisterSlaveMessage::clear_checkpointed_resources() {
  checkpointed_resources_.Clear();
}
inline const ::mesos::Resource& RegisterSlaveMessage::checkpointed_resources(int index) const {
  return checkpointed_resources_.Get(index);
}
inline ::mesos::Resource* RegisterSlaveMessage::mutable_checkpointed_resources(int index) {
  return checkpointed_resources_.Mutable(index);
}
inline ::mesos::Resource* RegisterSlaveMessage::add_checkpointed_resources() {
  return checkpointed_resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
RegisterSlaveMessage::checkpointed_resources() const {
  return checkpointed_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
RegisterSlaveMessage::mutable_checkpointed_resources() {
  return &checkpointed_resources_;
}

// optional string version = 2;
inline bool RegisterSlaveMessage::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterSlaveMessage::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterSlaveMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterSlaveMessage::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RegisterSlaveMessage::version() const {
  return *version_;
}
inline void RegisterSlaveMessage::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RegisterSlaveMessage::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RegisterSlaveMessage::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterSlaveMessage::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RegisterSlaveMessage::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterSlaveMessage::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReregisterSlaveMessage

// required .mesos.SlaveInfo slave = 2;
inline bool ReregisterSlaveMessage::has_slave() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReregisterSlaveMessage::set_has_slave() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReregisterSlaveMessage::clear_has_slave() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReregisterSlaveMessage::clear_slave() {
  if (slave_ != NULL) slave_->::mesos::SlaveInfo::Clear();
  clear_has_slave();
}
inline const ::mesos::SlaveInfo& ReregisterSlaveMessage::slave() const {
  return slave_ != NULL ? *slave_ : *default_instance_->slave_;
}
inline ::mesos::SlaveInfo* ReregisterSlaveMessage::mutable_slave() {
  set_has_slave();
  if (slave_ == NULL) slave_ = new ::mesos::SlaveInfo;
  return slave_;
}
inline ::mesos::SlaveInfo* ReregisterSlaveMessage::release_slave() {
  clear_has_slave();
  ::mesos::SlaveInfo* temp = slave_;
  slave_ = NULL;
  return temp;
}
inline void ReregisterSlaveMessage::set_allocated_slave(::mesos::SlaveInfo* slave) {
  delete slave_;
  slave_ = slave;
  if (slave) {
    set_has_slave();
  } else {
    clear_has_slave();
  }
}

// repeated .mesos.Resource checkpointed_resources = 7;
inline int ReregisterSlaveMessage::checkpointed_resources_size() const {
  return checkpointed_resources_.size();
}
inline void ReregisterSlaveMessage::clear_checkpointed_resources() {
  checkpointed_resources_.Clear();
}
inline const ::mesos::Resource& ReregisterSlaveMessage::checkpointed_resources(int index) const {
  return checkpointed_resources_.Get(index);
}
inline ::mesos::Resource* ReregisterSlaveMessage::mutable_checkpointed_resources(int index) {
  return checkpointed_resources_.Mutable(index);
}
inline ::mesos::Resource* ReregisterSlaveMessage::add_checkpointed_resources() {
  return checkpointed_resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ReregisterSlaveMessage::checkpointed_resources() const {
  return checkpointed_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ReregisterSlaveMessage::mutable_checkpointed_resources() {
  return &checkpointed_resources_;
}

// repeated .mesos.ExecutorInfo executor_infos = 4;
inline int ReregisterSlaveMessage::executor_infos_size() const {
  return executor_infos_.size();
}
inline void ReregisterSlaveMessage::clear_executor_infos() {
  executor_infos_.Clear();
}
inline const ::mesos::ExecutorInfo& ReregisterSlaveMessage::executor_infos(int index) const {
  return executor_infos_.Get(index);
}
inline ::mesos::ExecutorInfo* ReregisterSlaveMessage::mutable_executor_infos(int index) {
  return executor_infos_.Mutable(index);
}
inline ::mesos::ExecutorInfo* ReregisterSlaveMessage::add_executor_infos() {
  return executor_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo >&
ReregisterSlaveMessage::executor_infos() const {
  return executor_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorInfo >*
ReregisterSlaveMessage::mutable_executor_infos() {
  return &executor_infos_;
}

// repeated .mesos.internal.Task tasks = 3;
inline int ReregisterSlaveMessage::tasks_size() const {
  return tasks_.size();
}
inline void ReregisterSlaveMessage::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::internal::Task& ReregisterSlaveMessage::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::mesos::internal::Task* ReregisterSlaveMessage::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::mesos::internal::Task* ReregisterSlaveMessage::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >&
ReregisterSlaveMessage::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >*
ReregisterSlaveMessage::mutable_tasks() {
  return &tasks_;
}

// repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
inline int ReregisterSlaveMessage::completed_frameworks_size() const {
  return completed_frameworks_.size();
}
inline void ReregisterSlaveMessage::clear_completed_frameworks() {
  completed_frameworks_.Clear();
}
inline const ::mesos::internal::Archive_Framework& ReregisterSlaveMessage::completed_frameworks(int index) const {
  return completed_frameworks_.Get(index);
}
inline ::mesos::internal::Archive_Framework* ReregisterSlaveMessage::mutable_completed_frameworks(int index) {
  return completed_frameworks_.Mutable(index);
}
inline ::mesos::internal::Archive_Framework* ReregisterSlaveMessage::add_completed_frameworks() {
  return completed_frameworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework >&
ReregisterSlaveMessage::completed_frameworks() const {
  return completed_frameworks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework >*
ReregisterSlaveMessage::mutable_completed_frameworks() {
  return &completed_frameworks_;
}

// optional string version = 6;
inline bool ReregisterSlaveMessage::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReregisterSlaveMessage::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReregisterSlaveMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReregisterSlaveMessage::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ReregisterSlaveMessage::version() const {
  return *version_;
}
inline void ReregisterSlaveMessage::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ReregisterSlaveMessage::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ReregisterSlaveMessage::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReregisterSlaveMessage::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ReregisterSlaveMessage::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReregisterSlaveMessage::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveRegisteredMessage

// required .mesos.SlaveID slave_id = 1;
inline bool SlaveRegisteredMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveRegisteredMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveRegisteredMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveRegisteredMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& SlaveRegisteredMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* SlaveRegisteredMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* SlaveRegisteredMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void SlaveRegisteredMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// optional .mesos.internal.MasterSlaveConnection connection = 2;
inline bool SlaveRegisteredMessage::has_connection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveRegisteredMessage::set_has_connection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveRegisteredMessage::clear_has_connection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveRegisteredMessage::clear_connection() {
  if (connection_ != NULL) connection_->::mesos::internal::MasterSlaveConnection::Clear();
  clear_has_connection();
}
inline const ::mesos::internal::MasterSlaveConnection& SlaveRegisteredMessage::connection() const {
  return connection_ != NULL ? *connection_ : *default_instance_->connection_;
}
inline ::mesos::internal::MasterSlaveConnection* SlaveRegisteredMessage::mutable_connection() {
  set_has_connection();
  if (connection_ == NULL) connection_ = new ::mesos::internal::MasterSlaveConnection;
  return connection_;
}
inline ::mesos::internal::MasterSlaveConnection* SlaveRegisteredMessage::release_connection() {
  clear_has_connection();
  ::mesos::internal::MasterSlaveConnection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline void SlaveRegisteredMessage::set_allocated_connection(::mesos::internal::MasterSlaveConnection* connection) {
  delete connection_;
  connection_ = connection;
  if (connection) {
    set_has_connection();
  } else {
    clear_has_connection();
  }
}

// -------------------------------------------------------------------

// SlaveReregisteredMessage

// required .mesos.SlaveID slave_id = 1;
inline bool SlaveReregisteredMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveReregisteredMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveReregisteredMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveReregisteredMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& SlaveReregisteredMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* SlaveReregisteredMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* SlaveReregisteredMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void SlaveReregisteredMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
inline int SlaveReregisteredMessage::reconciliations_size() const {
  return reconciliations_.size();
}
inline void SlaveReregisteredMessage::clear_reconciliations() {
  reconciliations_.Clear();
}
inline const ::mesos::internal::ReconcileTasksMessage& SlaveReregisteredMessage::reconciliations(int index) const {
  return reconciliations_.Get(index);
}
inline ::mesos::internal::ReconcileTasksMessage* SlaveReregisteredMessage::mutable_reconciliations(int index) {
  return reconciliations_.Mutable(index);
}
inline ::mesos::internal::ReconcileTasksMessage* SlaveReregisteredMessage::add_reconciliations() {
  return reconciliations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::ReconcileTasksMessage >&
SlaveReregisteredMessage::reconciliations() const {
  return reconciliations_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::ReconcileTasksMessage >*
SlaveReregisteredMessage::mutable_reconciliations() {
  return &reconciliations_;
}

// optional .mesos.internal.MasterSlaveConnection connection = 3;
inline bool SlaveReregisteredMessage::has_connection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveReregisteredMessage::set_has_connection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveReregisteredMessage::clear_has_connection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveReregisteredMessage::clear_connection() {
  if (connection_ != NULL) connection_->::mesos::internal::MasterSlaveConnection::Clear();
  clear_has_connection();
}
inline const ::mesos::internal::MasterSlaveConnection& SlaveReregisteredMessage::connection() const {
  return connection_ != NULL ? *connection_ : *default_instance_->connection_;
}
inline ::mesos::internal::MasterSlaveConnection* SlaveReregisteredMessage::mutable_connection() {
  set_has_connection();
  if (connection_ == NULL) connection_ = new ::mesos::internal::MasterSlaveConnection;
  return connection_;
}
inline ::mesos::internal::MasterSlaveConnection* SlaveReregisteredMessage::release_connection() {
  clear_has_connection();
  ::mesos::internal::MasterSlaveConnection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline void SlaveReregisteredMessage::set_allocated_connection(::mesos::internal::MasterSlaveConnection* connection) {
  delete connection_;
  connection_ = connection;
  if (connection) {
    set_has_connection();
  } else {
    clear_has_connection();
  }
}

// -------------------------------------------------------------------

// UnregisterSlaveMessage

// required .mesos.SlaveID slave_id = 1;
inline bool UnregisterSlaveMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterSlaveMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterSlaveMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterSlaveMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& UnregisterSlaveMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* UnregisterSlaveMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* UnregisterSlaveMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void UnregisterSlaveMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// -------------------------------------------------------------------

// MasterSlaveConnection

// optional double total_ping_timeout_seconds = 1;
inline bool MasterSlaveConnection::has_total_ping_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterSlaveConnection::set_has_total_ping_timeout_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterSlaveConnection::clear_has_total_ping_timeout_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterSlaveConnection::clear_total_ping_timeout_seconds() {
  total_ping_timeout_seconds_ = 0;
  clear_has_total_ping_timeout_seconds();
}
inline double MasterSlaveConnection::total_ping_timeout_seconds() const {
  return total_ping_timeout_seconds_;
}
inline void MasterSlaveConnection::set_total_ping_timeout_seconds(double value) {
  set_has_total_ping_timeout_seconds();
  total_ping_timeout_seconds_ = value;
}

// -------------------------------------------------------------------

// PingSlaveMessage

// required bool connected = 1;
inline bool PingSlaveMessage::has_connected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingSlaveMessage::set_has_connected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingSlaveMessage::clear_has_connected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingSlaveMessage::clear_connected() {
  connected_ = false;
  clear_has_connected();
}
inline bool PingSlaveMessage::connected() const {
  return connected_;
}
inline void PingSlaveMessage::set_connected(bool value) {
  set_has_connected();
  connected_ = value;
}

// -------------------------------------------------------------------

// PongSlaveMessage

// -------------------------------------------------------------------

// ShutdownFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool ShutdownFrameworkMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShutdownFrameworkMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShutdownFrameworkMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShutdownFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ShutdownFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ShutdownFrameworkMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ShutdownFrameworkMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ShutdownFrameworkMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// -------------------------------------------------------------------

// ShutdownExecutorMessage

// optional .mesos.ExecutorID executor_id = 1;
inline bool ShutdownExecutorMessage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShutdownExecutorMessage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShutdownExecutorMessage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShutdownExecutorMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ShutdownExecutorMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ShutdownExecutorMessage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ShutdownExecutorMessage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ShutdownExecutorMessage::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional .mesos.FrameworkID framework_id = 2;
inline bool ShutdownExecutorMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShutdownExecutorMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShutdownExecutorMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShutdownExecutorMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ShutdownExecutorMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ShutdownExecutorMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ShutdownExecutorMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ShutdownExecutorMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// -------------------------------------------------------------------

// UpdateFrameworkMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool UpdateFrameworkMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateFrameworkMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateFrameworkMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateFrameworkMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& UpdateFrameworkMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* UpdateFrameworkMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* UpdateFrameworkMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void UpdateFrameworkMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// optional string pid = 2;
inline bool UpdateFrameworkMessage::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateFrameworkMessage::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateFrameworkMessage::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateFrameworkMessage::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& UpdateFrameworkMessage::pid() const {
  return *pid_;
}
inline void UpdateFrameworkMessage::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void UpdateFrameworkMessage::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void UpdateFrameworkMessage::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateFrameworkMessage::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* UpdateFrameworkMessage::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateFrameworkMessage::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckpointResourcesMessage

// repeated .mesos.Resource resources = 1;
inline int CheckpointResourcesMessage::resources_size() const {
  return resources_.size();
}
inline void CheckpointResourcesMessage::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& CheckpointResourcesMessage::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* CheckpointResourcesMessage::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* CheckpointResourcesMessage::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
CheckpointResourcesMessage::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
CheckpointResourcesMessage::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// UpdateSlaveMessage

// required .mesos.SlaveID slave_id = 1;
inline bool UpdateSlaveMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSlaveMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSlaveMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSlaveMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& UpdateSlaveMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* UpdateSlaveMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* UpdateSlaveMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void UpdateSlaveMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// repeated .mesos.Resource oversubscribed_resources = 2;
inline int UpdateSlaveMessage::oversubscribed_resources_size() const {
  return oversubscribed_resources_.size();
}
inline void UpdateSlaveMessage::clear_oversubscribed_resources() {
  oversubscribed_resources_.Clear();
}
inline const ::mesos::Resource& UpdateSlaveMessage::oversubscribed_resources(int index) const {
  return oversubscribed_resources_.Get(index);
}
inline ::mesos::Resource* UpdateSlaveMessage::mutable_oversubscribed_resources(int index) {
  return oversubscribed_resources_.Mutable(index);
}
inline ::mesos::Resource* UpdateSlaveMessage::add_oversubscribed_resources() {
  return oversubscribed_resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
UpdateSlaveMessage::oversubscribed_resources() const {
  return oversubscribed_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
UpdateSlaveMessage::mutable_oversubscribed_resources() {
  return &oversubscribed_resources_;
}

// -------------------------------------------------------------------

// RegisterExecutorMessage

// required .mesos.FrameworkID framework_id = 1;
inline bool RegisterExecutorMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterExecutorMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterExecutorMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterExecutorMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& RegisterExecutorMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* RegisterExecutorMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* RegisterExecutorMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void RegisterExecutorMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.ExecutorID executor_id = 2;
inline bool RegisterExecutorMessage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterExecutorMessage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterExecutorMessage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterExecutorMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& RegisterExecutorMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* RegisterExecutorMessage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* RegisterExecutorMessage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void RegisterExecutorMessage::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// -------------------------------------------------------------------

// ExecutorRegisteredMessage

// required .mesos.ExecutorInfo executor_info = 2;
inline bool ExecutorRegisteredMessage::has_executor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorRegisteredMessage::set_has_executor_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorRegisteredMessage::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorRegisteredMessage::clear_executor_info() {
  if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
  clear_has_executor_info();
}
inline const ::mesos::ExecutorInfo& ExecutorRegisteredMessage::executor_info() const {
  return executor_info_ != NULL ? *executor_info_ : *default_instance_->executor_info_;
}
inline ::mesos::ExecutorInfo* ExecutorRegisteredMessage::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) executor_info_ = new ::mesos::ExecutorInfo;
  return executor_info_;
}
inline ::mesos::ExecutorInfo* ExecutorRegisteredMessage::release_executor_info() {
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline void ExecutorRegisteredMessage::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  delete executor_info_;
  executor_info_ = executor_info;
  if (executor_info) {
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
}

// required .mesos.FrameworkID framework_id = 3;
inline bool ExecutorRegisteredMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorRegisteredMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorRegisteredMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorRegisteredMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ExecutorRegisteredMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExecutorRegisteredMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ExecutorRegisteredMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ExecutorRegisteredMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.FrameworkInfo framework_info = 4;
inline bool ExecutorRegisteredMessage::has_framework_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutorRegisteredMessage::set_has_framework_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutorRegisteredMessage::clear_has_framework_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutorRegisteredMessage::clear_framework_info() {
  if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
  clear_has_framework_info();
}
inline const ::mesos::FrameworkInfo& ExecutorRegisteredMessage::framework_info() const {
  return framework_info_ != NULL ? *framework_info_ : *default_instance_->framework_info_;
}
inline ::mesos::FrameworkInfo* ExecutorRegisteredMessage::mutable_framework_info() {
  set_has_framework_info();
  if (framework_info_ == NULL) framework_info_ = new ::mesos::FrameworkInfo;
  return framework_info_;
}
inline ::mesos::FrameworkInfo* ExecutorRegisteredMessage::release_framework_info() {
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  framework_info_ = NULL;
  return temp;
}
inline void ExecutorRegisteredMessage::set_allocated_framework_info(::mesos::FrameworkInfo* framework_info) {
  delete framework_info_;
  framework_info_ = framework_info;
  if (framework_info) {
    set_has_framework_info();
  } else {
    clear_has_framework_info();
  }
}

// required .mesos.SlaveID slave_id = 5;
inline bool ExecutorRegisteredMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutorRegisteredMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutorRegisteredMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutorRegisteredMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ExecutorRegisteredMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ExecutorRegisteredMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ExecutorRegisteredMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ExecutorRegisteredMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.SlaveInfo slave_info = 6;
inline bool ExecutorRegisteredMessage::has_slave_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutorRegisteredMessage::set_has_slave_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutorRegisteredMessage::clear_has_slave_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutorRegisteredMessage::clear_slave_info() {
  if (slave_info_ != NULL) slave_info_->::mesos::SlaveInfo::Clear();
  clear_has_slave_info();
}
inline const ::mesos::SlaveInfo& ExecutorRegisteredMessage::slave_info() const {
  return slave_info_ != NULL ? *slave_info_ : *default_instance_->slave_info_;
}
inline ::mesos::SlaveInfo* ExecutorRegisteredMessage::mutable_slave_info() {
  set_has_slave_info();
  if (slave_info_ == NULL) slave_info_ = new ::mesos::SlaveInfo;
  return slave_info_;
}
inline ::mesos::SlaveInfo* ExecutorRegisteredMessage::release_slave_info() {
  clear_has_slave_info();
  ::mesos::SlaveInfo* temp = slave_info_;
  slave_info_ = NULL;
  return temp;
}
inline void ExecutorRegisteredMessage::set_allocated_slave_info(::mesos::SlaveInfo* slave_info) {
  delete slave_info_;
  slave_info_ = slave_info;
  if (slave_info) {
    set_has_slave_info();
  } else {
    clear_has_slave_info();
  }
}

// -------------------------------------------------------------------

// ExecutorReregisteredMessage

// required .mesos.SlaveID slave_id = 1;
inline bool ExecutorReregisteredMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorReregisteredMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorReregisteredMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorReregisteredMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ExecutorReregisteredMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ExecutorReregisteredMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ExecutorReregisteredMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ExecutorReregisteredMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.SlaveInfo slave_info = 2;
inline bool ExecutorReregisteredMessage::has_slave_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorReregisteredMessage::set_has_slave_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorReregisteredMessage::clear_has_slave_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorReregisteredMessage::clear_slave_info() {
  if (slave_info_ != NULL) slave_info_->::mesos::SlaveInfo::Clear();
  clear_has_slave_info();
}
inline const ::mesos::SlaveInfo& ExecutorReregisteredMessage::slave_info() const {
  return slave_info_ != NULL ? *slave_info_ : *default_instance_->slave_info_;
}
inline ::mesos::SlaveInfo* ExecutorReregisteredMessage::mutable_slave_info() {
  set_has_slave_info();
  if (slave_info_ == NULL) slave_info_ = new ::mesos::SlaveInfo;
  return slave_info_;
}
inline ::mesos::SlaveInfo* ExecutorReregisteredMessage::release_slave_info() {
  clear_has_slave_info();
  ::mesos::SlaveInfo* temp = slave_info_;
  slave_info_ = NULL;
  return temp;
}
inline void ExecutorReregisteredMessage::set_allocated_slave_info(::mesos::SlaveInfo* slave_info) {
  delete slave_info_;
  slave_info_ = slave_info;
  if (slave_info) {
    set_has_slave_info();
  } else {
    clear_has_slave_info();
  }
}

// -------------------------------------------------------------------

// ExitedExecutorMessage

// required .mesos.SlaveID slave_id = 1;
inline bool ExitedExecutorMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitedExecutorMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitedExecutorMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitedExecutorMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ExitedExecutorMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ExitedExecutorMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ExitedExecutorMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ExitedExecutorMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool ExitedExecutorMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExitedExecutorMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExitedExecutorMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExitedExecutorMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ExitedExecutorMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExitedExecutorMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ExitedExecutorMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ExitedExecutorMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.ExecutorID executor_id = 3;
inline bool ExitedExecutorMessage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExitedExecutorMessage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExitedExecutorMessage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExitedExecutorMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ExitedExecutorMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExitedExecutorMessage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ExitedExecutorMessage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ExitedExecutorMessage::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// required int32 status = 4;
inline bool ExitedExecutorMessage::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExitedExecutorMessage::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExitedExecutorMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExitedExecutorMessage::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ExitedExecutorMessage::status() const {
  return status_;
}
inline void ExitedExecutorMessage::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ReconnectExecutorMessage

// required .mesos.SlaveID slave_id = 1;
inline bool ReconnectExecutorMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconnectExecutorMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconnectExecutorMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconnectExecutorMessage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ReconnectExecutorMessage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ReconnectExecutorMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ReconnectExecutorMessage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ReconnectExecutorMessage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// -------------------------------------------------------------------

// ReregisterExecutorMessage

// required .mesos.ExecutorID executor_id = 1;
inline bool ReregisterExecutorMessage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReregisterExecutorMessage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReregisterExecutorMessage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReregisterExecutorMessage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ReregisterExecutorMessage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ReregisterExecutorMessage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ReregisterExecutorMessage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ReregisterExecutorMessage::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool ReregisterExecutorMessage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReregisterExecutorMessage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReregisterExecutorMessage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReregisterExecutorMessage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ReregisterExecutorMessage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ReregisterExecutorMessage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ReregisterExecutorMessage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ReregisterExecutorMessage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// repeated .mesos.TaskInfo tasks = 3;
inline int ReregisterExecutorMessage::tasks_size() const {
  return tasks_.size();
}
inline void ReregisterExecutorMessage::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::TaskInfo& ReregisterExecutorMessage::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::mesos::TaskInfo* ReregisterExecutorMessage::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::mesos::TaskInfo* ReregisterExecutorMessage::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
ReregisterExecutorMessage::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
ReregisterExecutorMessage::mutable_tasks() {
  return &tasks_;
}

// repeated .mesos.internal.StatusUpdate updates = 4;
inline int ReregisterExecutorMessage::updates_size() const {
  return updates_.size();
}
inline void ReregisterExecutorMessage::clear_updates() {
  updates_.Clear();
}
inline const ::mesos::internal::StatusUpdate& ReregisterExecutorMessage::updates(int index) const {
  return updates_.Get(index);
}
inline ::mesos::internal::StatusUpdate* ReregisterExecutorMessage::mutable_updates(int index) {
  return updates_.Mutable(index);
}
inline ::mesos::internal::StatusUpdate* ReregisterExecutorMessage::add_updates() {
  return updates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::StatusUpdate >&
ReregisterExecutorMessage::updates() const {
  return updates_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::StatusUpdate >*
ReregisterExecutorMessage::mutable_updates() {
  return &updates_;
}

// -------------------------------------------------------------------

// ShutdownMessage

// optional string message = 1;
inline bool ShutdownMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShutdownMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShutdownMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShutdownMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ShutdownMessage::message() const {
  return *message_;
}
inline void ShutdownMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ShutdownMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ShutdownMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShutdownMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ShutdownMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShutdownMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Archive_Framework

// required .mesos.FrameworkInfo framework_info = 1;
inline bool Archive_Framework::has_framework_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Archive_Framework::set_has_framework_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Archive_Framework::clear_has_framework_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Archive_Framework::clear_framework_info() {
  if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
  clear_has_framework_info();
}
inline const ::mesos::FrameworkInfo& Archive_Framework::framework_info() const {
  return framework_info_ != NULL ? *framework_info_ : *default_instance_->framework_info_;
}
inline ::mesos::FrameworkInfo* Archive_Framework::mutable_framework_info() {
  set_has_framework_info();
  if (framework_info_ == NULL) framework_info_ = new ::mesos::FrameworkInfo;
  return framework_info_;
}
inline ::mesos::FrameworkInfo* Archive_Framework::release_framework_info() {
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  framework_info_ = NULL;
  return temp;
}
inline void Archive_Framework::set_allocated_framework_info(::mesos::FrameworkInfo* framework_info) {
  delete framework_info_;
  framework_info_ = framework_info;
  if (framework_info) {
    set_has_framework_info();
  } else {
    clear_has_framework_info();
  }
}

// optional string pid = 2;
inline bool Archive_Framework::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Archive_Framework::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Archive_Framework::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Archive_Framework::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& Archive_Framework::pid() const {
  return *pid_;
}
inline void Archive_Framework::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void Archive_Framework::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void Archive_Framework::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Archive_Framework::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* Archive_Framework::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Archive_Framework::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mesos.internal.Task tasks = 3;
inline int Archive_Framework::tasks_size() const {
  return tasks_.size();
}
inline void Archive_Framework::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::internal::Task& Archive_Framework::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::mesos::internal::Task* Archive_Framework::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::mesos::internal::Task* Archive_Framework::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >&
Archive_Framework::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Task >*
Archive_Framework::mutable_tasks() {
  return &tasks_;
}

// -------------------------------------------------------------------

// Archive

// repeated .mesos.internal.Archive.Framework frameworks = 1;
inline int Archive::frameworks_size() const {
  return frameworks_.size();
}
inline void Archive::clear_frameworks() {
  frameworks_.Clear();
}
inline const ::mesos::internal::Archive_Framework& Archive::frameworks(int index) const {
  return frameworks_.Get(index);
}
inline ::mesos::internal::Archive_Framework* Archive::mutable_frameworks(int index) {
  return frameworks_.Mutable(index);
}
inline ::mesos::internal::Archive_Framework* Archive::add_frameworks() {
  return frameworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework >&
Archive::frameworks() const {
  return frameworks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::internal::Archive_Framework >*
Archive::mutable_frameworks() {
  return &frameworks_;
}

// -------------------------------------------------------------------

// TaskHealthStatus

// required .mesos.TaskID task_id = 1;
inline bool TaskHealthStatus::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskHealthStatus::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskHealthStatus::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskHealthStatus::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskHealthStatus::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskHealthStatus::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* TaskHealthStatus::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void TaskHealthStatus::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// required bool healthy = 2;
inline bool TaskHealthStatus::has_healthy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskHealthStatus::set_has_healthy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskHealthStatus::clear_has_healthy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskHealthStatus::clear_healthy() {
  healthy_ = false;
  clear_has_healthy();
}
inline bool TaskHealthStatus::healthy() const {
  return healthy_;
}
inline void TaskHealthStatus::set_healthy(bool value) {
  set_has_healthy();
  healthy_ = value;
}

// optional bool kill_task = 3 [default = false];
inline bool TaskHealthStatus::has_kill_task() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskHealthStatus::set_has_kill_task() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskHealthStatus::clear_has_kill_task() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskHealthStatus::clear_kill_task() {
  kill_task_ = false;
  clear_has_kill_task();
}
inline bool TaskHealthStatus::kill_task() const {
  return kill_task_;
}
inline void TaskHealthStatus::set_kill_task(bool value) {
  set_has_kill_task();
  kill_task_ = value;
}

// optional int32 consecutive_failures = 4;
inline bool TaskHealthStatus::has_consecutive_failures() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskHealthStatus::set_has_consecutive_failures() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskHealthStatus::clear_has_consecutive_failures() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskHealthStatus::clear_consecutive_failures() {
  consecutive_failures_ = 0;
  clear_has_consecutive_failures();
}
inline ::google::protobuf::int32 TaskHealthStatus::consecutive_failures() const {
  return consecutive_failures_;
}
inline void TaskHealthStatus::set_consecutive_failures(::google::protobuf::int32 value) {
  set_has_consecutive_failures();
  consecutive_failures_ = value;
}

// -------------------------------------------------------------------

// HookExecuted

// optional string module = 1;
inline bool HookExecuted::has_module() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HookExecuted::set_has_module() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HookExecuted::clear_has_module() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HookExecuted::clear_module() {
  if (module_ != &::google::protobuf::internal::kEmptyString) {
    module_->clear();
  }
  clear_has_module();
}
inline const ::std::string& HookExecuted::module() const {
  return *module_;
}
inline void HookExecuted::set_module(const ::std::string& value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(value);
}
inline void HookExecuted::set_module(const char* value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(value);
}
inline void HookExecuted::set_module(const char* value, size_t size) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  module_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HookExecuted::mutable_module() {
  set_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    module_ = new ::std::string;
  }
  return module_;
}
inline ::std::string* HookExecuted::release_module() {
  clear_has_module();
  if (module_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_;
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HookExecuted::set_allocated_module(::std::string* module) {
  if (module_ != &::google::protobuf::internal::kEmptyString) {
    delete module_;
  }
  if (module) {
    set_has_module();
    module_ = module;
  } else {
    clear_has_module();
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace internal
}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::internal::StatusUpdateRecord_Type>() {
  return ::mesos::internal::StatusUpdateRecord_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2fmessages_2eproto__INCLUDED
