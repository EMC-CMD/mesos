// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages/messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages/messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mesos {
namespace internal {

namespace {

const ::google::protobuf::Descriptor* Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Task_reflection_ = NULL;
const ::google::protobuf::Descriptor* StatusUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StatusUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* StatusUpdateRecord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StatusUpdateRecord_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* StatusUpdateRecord_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SubmitSchedulerRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubmitSchedulerRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubmitSchedulerResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubmitSchedulerResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorToFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorToFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkToExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkToExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReregisterFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReregisterFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkRegisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkRegisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkReregisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkReregisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnregisterFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnregisterFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeactivateFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeactivateFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceRequestMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceRequestMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceOffersMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceOffersMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaunchTasksMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaunchTasksMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RescindResourceOfferMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RescindResourceOfferMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReviveOffersMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReviveOffersMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RunTaskMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RunTaskMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* KillTaskMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KillTaskMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* StatusUpdateMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StatusUpdateMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* StatusUpdateAcknowledgementMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StatusUpdateAcknowledgementMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* LostSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LostSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReconcileTasksMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReconcileTasksMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkErrorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkErrorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReregisterSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReregisterSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveRegisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveRegisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveReregisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveReregisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnregisterSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnregisterSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* MasterSlaveConnection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MasterSlaveConnection_reflection_ = NULL;
const ::google::protobuf::Descriptor* PingSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PingSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* PongSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PongSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShutdownFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShutdownFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShutdownExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShutdownExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckpointResourcesMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckpointResourcesMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorRegisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorRegisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorReregisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorReregisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExitedExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExitedExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReconnectExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReconnectExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReregisterExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReregisterExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShutdownMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShutdownMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* Archive_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Archive_reflection_ = NULL;
const ::google::protobuf::Descriptor* Archive_Framework_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Archive_Framework_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskHealthStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskHealthStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* HookExecuted_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HookExecuted_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2fmessages_2eproto() {
  protobuf_AddDesc_messages_2fmessages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages/messages.proto");
  GOOGLE_CHECK(file != NULL);
  Task_descriptor_ = file->message_type(0);
  static const int Task_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, statuses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, status_update_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, status_update_uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, discovery_),
  };
  Task_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Task_descriptor_,
      Task::default_instance_,
      Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Task));
  StatusUpdate_descriptor_ = file->message_type(1);
  static const int StatusUpdate_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, latest_state_),
  };
  StatusUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StatusUpdate_descriptor_,
      StatusUpdate::default_instance_,
      StatusUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StatusUpdate));
  StatusUpdateRecord_descriptor_ = file->message_type(2);
  static const int StatusUpdateRecord_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, update_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, uuid_),
  };
  StatusUpdateRecord_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StatusUpdateRecord_descriptor_,
      StatusUpdateRecord::default_instance_,
      StatusUpdateRecord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StatusUpdateRecord));
  StatusUpdateRecord_Type_descriptor_ = StatusUpdateRecord_descriptor_->enum_type(0);
  SubmitSchedulerRequest_descriptor_ = file->message_type(3);
  static const int SubmitSchedulerRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerRequest, name_),
  };
  SubmitSchedulerRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SubmitSchedulerRequest_descriptor_,
      SubmitSchedulerRequest::default_instance_,
      SubmitSchedulerRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SubmitSchedulerRequest));
  SubmitSchedulerResponse_descriptor_ = file->message_type(4);
  static const int SubmitSchedulerResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerResponse, okay_),
  };
  SubmitSchedulerResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SubmitSchedulerResponse_descriptor_,
      SubmitSchedulerResponse::default_instance_,
      SubmitSchedulerResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SubmitSchedulerResponse));
  ExecutorToFrameworkMessage_descriptor_ = file->message_type(5);
  static const int ExecutorToFrameworkMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, data_),
  };
  ExecutorToFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutorToFrameworkMessage_descriptor_,
      ExecutorToFrameworkMessage::default_instance_,
      ExecutorToFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutorToFrameworkMessage));
  FrameworkToExecutorMessage_descriptor_ = file->message_type(6);
  static const int FrameworkToExecutorMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, data_),
  };
  FrameworkToExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkToExecutorMessage_descriptor_,
      FrameworkToExecutorMessage::default_instance_,
      FrameworkToExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkToExecutorMessage));
  RegisterFrameworkMessage_descriptor_ = file->message_type(7);
  static const int RegisterFrameworkMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterFrameworkMessage, framework_),
  };
  RegisterFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterFrameworkMessage_descriptor_,
      RegisterFrameworkMessage::default_instance_,
      RegisterFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterFrameworkMessage));
  ReregisterFrameworkMessage_descriptor_ = file->message_type(8);
  static const int ReregisterFrameworkMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterFrameworkMessage, framework_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterFrameworkMessage, failover_),
  };
  ReregisterFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReregisterFrameworkMessage_descriptor_,
      ReregisterFrameworkMessage::default_instance_,
      ReregisterFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReregisterFrameworkMessage));
  FrameworkRegisteredMessage_descriptor_ = file->message_type(9);
  static const int FrameworkRegisteredMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkRegisteredMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkRegisteredMessage, master_info_),
  };
  FrameworkRegisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkRegisteredMessage_descriptor_,
      FrameworkRegisteredMessage::default_instance_,
      FrameworkRegisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkRegisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkRegisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkRegisteredMessage));
  FrameworkReregisteredMessage_descriptor_ = file->message_type(10);
  static const int FrameworkReregisteredMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkReregisteredMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkReregisteredMessage, master_info_),
  };
  FrameworkReregisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkReregisteredMessage_descriptor_,
      FrameworkReregisteredMessage::default_instance_,
      FrameworkReregisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkReregisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkReregisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkReregisteredMessage));
  UnregisterFrameworkMessage_descriptor_ = file->message_type(11);
  static const int UnregisterFrameworkMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterFrameworkMessage, framework_id_),
  };
  UnregisterFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnregisterFrameworkMessage_descriptor_,
      UnregisterFrameworkMessage::default_instance_,
      UnregisterFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnregisterFrameworkMessage));
  DeactivateFrameworkMessage_descriptor_ = file->message_type(12);
  static const int DeactivateFrameworkMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeactivateFrameworkMessage, framework_id_),
  };
  DeactivateFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeactivateFrameworkMessage_descriptor_,
      DeactivateFrameworkMessage::default_instance_,
      DeactivateFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeactivateFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeactivateFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeactivateFrameworkMessage));
  ResourceRequestMessage_descriptor_ = file->message_type(13);
  static const int ResourceRequestMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceRequestMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceRequestMessage, requests_),
  };
  ResourceRequestMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceRequestMessage_descriptor_,
      ResourceRequestMessage::default_instance_,
      ResourceRequestMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceRequestMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceRequestMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceRequestMessage));
  ResourceOffersMessage_descriptor_ = file->message_type(14);
  static const int ResourceOffersMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, pids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, inverse_offers_),
  };
  ResourceOffersMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceOffersMessage_descriptor_,
      ResourceOffersMessage::default_instance_,
      ResourceOffersMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceOffersMessage));
  LaunchTasksMessage_descriptor_ = file->message_type(15);
  static const int LaunchTasksMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, tasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, filters_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, offer_ids_),
  };
  LaunchTasksMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LaunchTasksMessage_descriptor_,
      LaunchTasksMessage::default_instance_,
      LaunchTasksMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LaunchTasksMessage));
  RescindResourceOfferMessage_descriptor_ = file->message_type(16);
  static const int RescindResourceOfferMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindResourceOfferMessage, offer_id_),
  };
  RescindResourceOfferMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RescindResourceOfferMessage_descriptor_,
      RescindResourceOfferMessage::default_instance_,
      RescindResourceOfferMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindResourceOfferMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindResourceOfferMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RescindResourceOfferMessage));
  ReviveOffersMessage_descriptor_ = file->message_type(17);
  static const int ReviveOffersMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReviveOffersMessage, framework_id_),
  };
  ReviveOffersMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReviveOffersMessage_descriptor_,
      ReviveOffersMessage::default_instance_,
      ReviveOffersMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReviveOffersMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReviveOffersMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReviveOffersMessage));
  RunTaskMessage_descriptor_ = file->message_type(18);
  static const int RunTaskMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, framework_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, task_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, pid_),
  };
  RunTaskMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RunTaskMessage_descriptor_,
      RunTaskMessage::default_instance_,
      RunTaskMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RunTaskMessage));
  KillTaskMessage_descriptor_ = file->message_type(19);
  static const int KillTaskMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, task_id_),
  };
  KillTaskMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KillTaskMessage_descriptor_,
      KillTaskMessage::default_instance_,
      KillTaskMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KillTaskMessage));
  StatusUpdateMessage_descriptor_ = file->message_type(20);
  static const int StatusUpdateMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateMessage, update_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateMessage, pid_),
  };
  StatusUpdateMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StatusUpdateMessage_descriptor_,
      StatusUpdateMessage::default_instance_,
      StatusUpdateMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StatusUpdateMessage));
  StatusUpdateAcknowledgementMessage_descriptor_ = file->message_type(21);
  static const int StatusUpdateAcknowledgementMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, uuid_),
  };
  StatusUpdateAcknowledgementMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StatusUpdateAcknowledgementMessage_descriptor_,
      StatusUpdateAcknowledgementMessage::default_instance_,
      StatusUpdateAcknowledgementMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StatusUpdateAcknowledgementMessage));
  LostSlaveMessage_descriptor_ = file->message_type(22);
  static const int LostSlaveMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LostSlaveMessage, slave_id_),
  };
  LostSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LostSlaveMessage_descriptor_,
      LostSlaveMessage::default_instance_,
      LostSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LostSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LostSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LostSlaveMessage));
  ReconcileTasksMessage_descriptor_ = file->message_type(23);
  static const int ReconcileTasksMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, statuses_),
  };
  ReconcileTasksMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReconcileTasksMessage_descriptor_,
      ReconcileTasksMessage::default_instance_,
      ReconcileTasksMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReconcileTasksMessage));
  FrameworkErrorMessage_descriptor_ = file->message_type(24);
  static const int FrameworkErrorMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkErrorMessage, message_),
  };
  FrameworkErrorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkErrorMessage_descriptor_,
      FrameworkErrorMessage::default_instance_,
      FrameworkErrorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkErrorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkErrorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkErrorMessage));
  RegisterSlaveMessage_descriptor_ = file->message_type(25);
  static const int RegisterSlaveMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, slave_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, checkpointed_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, version_),
  };
  RegisterSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterSlaveMessage_descriptor_,
      RegisterSlaveMessage::default_instance_,
      RegisterSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterSlaveMessage));
  ReregisterSlaveMessage_descriptor_ = file->message_type(26);
  static const int ReregisterSlaveMessage_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, slave_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, checkpointed_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, executor_infos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, tasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, completed_frameworks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, version_),
  };
  ReregisterSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReregisterSlaveMessage_descriptor_,
      ReregisterSlaveMessage::default_instance_,
      ReregisterSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReregisterSlaveMessage));
  SlaveRegisteredMessage_descriptor_ = file->message_type(27);
  static const int SlaveRegisteredMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveRegisteredMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveRegisteredMessage, connection_),
  };
  SlaveRegisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveRegisteredMessage_descriptor_,
      SlaveRegisteredMessage::default_instance_,
      SlaveRegisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveRegisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveRegisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveRegisteredMessage));
  SlaveReregisteredMessage_descriptor_ = file->message_type(28);
  static const int SlaveReregisteredMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, reconciliations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, connection_),
  };
  SlaveReregisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveReregisteredMessage_descriptor_,
      SlaveReregisteredMessage::default_instance_,
      SlaveReregisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveReregisteredMessage));
  UnregisterSlaveMessage_descriptor_ = file->message_type(29);
  static const int UnregisterSlaveMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterSlaveMessage, slave_id_),
  };
  UnregisterSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnregisterSlaveMessage_descriptor_,
      UnregisterSlaveMessage::default_instance_,
      UnregisterSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnregisterSlaveMessage));
  MasterSlaveConnection_descriptor_ = file->message_type(30);
  static const int MasterSlaveConnection_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterSlaveConnection, total_ping_timeout_seconds_),
  };
  MasterSlaveConnection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MasterSlaveConnection_descriptor_,
      MasterSlaveConnection::default_instance_,
      MasterSlaveConnection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterSlaveConnection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterSlaveConnection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MasterSlaveConnection));
  PingSlaveMessage_descriptor_ = file->message_type(31);
  static const int PingSlaveMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingSlaveMessage, connected_),
  };
  PingSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PingSlaveMessage_descriptor_,
      PingSlaveMessage::default_instance_,
      PingSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PingSlaveMessage));
  PongSlaveMessage_descriptor_ = file->message_type(32);
  static const int PongSlaveMessage_offsets_[1] = {
  };
  PongSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PongSlaveMessage_descriptor_,
      PongSlaveMessage::default_instance_,
      PongSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PongSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PongSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PongSlaveMessage));
  ShutdownFrameworkMessage_descriptor_ = file->message_type(33);
  static const int ShutdownFrameworkMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownFrameworkMessage, framework_id_),
  };
  ShutdownFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShutdownFrameworkMessage_descriptor_,
      ShutdownFrameworkMessage::default_instance_,
      ShutdownFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShutdownFrameworkMessage));
  ShutdownExecutorMessage_descriptor_ = file->message_type(34);
  static const int ShutdownExecutorMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownExecutorMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownExecutorMessage, framework_id_),
  };
  ShutdownExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShutdownExecutorMessage_descriptor_,
      ShutdownExecutorMessage::default_instance_,
      ShutdownExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShutdownExecutorMessage));
  UpdateFrameworkMessage_descriptor_ = file->message_type(35);
  static const int UpdateFrameworkMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, pid_),
  };
  UpdateFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateFrameworkMessage_descriptor_,
      UpdateFrameworkMessage::default_instance_,
      UpdateFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateFrameworkMessage));
  CheckpointResourcesMessage_descriptor_ = file->message_type(36);
  static const int CheckpointResourcesMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointResourcesMessage, resources_),
  };
  CheckpointResourcesMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckpointResourcesMessage_descriptor_,
      CheckpointResourcesMessage::default_instance_,
      CheckpointResourcesMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointResourcesMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointResourcesMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckpointResourcesMessage));
  UpdateSlaveMessage_descriptor_ = file->message_type(37);
  static const int UpdateSlaveMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateSlaveMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateSlaveMessage, oversubscribed_resources_),
  };
  UpdateSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateSlaveMessage_descriptor_,
      UpdateSlaveMessage::default_instance_,
      UpdateSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateSlaveMessage));
  RegisterExecutorMessage_descriptor_ = file->message_type(38);
  static const int RegisterExecutorMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterExecutorMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterExecutorMessage, executor_id_),
  };
  RegisterExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterExecutorMessage_descriptor_,
      RegisterExecutorMessage::default_instance_,
      RegisterExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterExecutorMessage));
  ExecutorRegisteredMessage_descriptor_ = file->message_type(39);
  static const int ExecutorRegisteredMessage_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, executor_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, framework_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, slave_info_),
  };
  ExecutorRegisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutorRegisteredMessage_descriptor_,
      ExecutorRegisteredMessage::default_instance_,
      ExecutorRegisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutorRegisteredMessage));
  ExecutorReregisteredMessage_descriptor_ = file->message_type(40);
  static const int ExecutorReregisteredMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorReregisteredMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorReregisteredMessage, slave_info_),
  };
  ExecutorReregisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutorReregisteredMessage_descriptor_,
      ExecutorReregisteredMessage::default_instance_,
      ExecutorReregisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorReregisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorReregisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutorReregisteredMessage));
  ExitedExecutorMessage_descriptor_ = file->message_type(41);
  static const int ExitedExecutorMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, status_),
  };
  ExitedExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExitedExecutorMessage_descriptor_,
      ExitedExecutorMessage::default_instance_,
      ExitedExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExitedExecutorMessage));
  ReconnectExecutorMessage_descriptor_ = file->message_type(42);
  static const int ReconnectExecutorMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconnectExecutorMessage, slave_id_),
  };
  ReconnectExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReconnectExecutorMessage_descriptor_,
      ReconnectExecutorMessage::default_instance_,
      ReconnectExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconnectExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconnectExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReconnectExecutorMessage));
  ReregisterExecutorMessage_descriptor_ = file->message_type(43);
  static const int ReregisterExecutorMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, tasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, updates_),
  };
  ReregisterExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReregisterExecutorMessage_descriptor_,
      ReregisterExecutorMessage::default_instance_,
      ReregisterExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReregisterExecutorMessage));
  ShutdownMessage_descriptor_ = file->message_type(44);
  static const int ShutdownMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownMessage, message_),
  };
  ShutdownMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShutdownMessage_descriptor_,
      ShutdownMessage::default_instance_,
      ShutdownMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShutdownMessage));
  Archive_descriptor_ = file->message_type(45);
  static const int Archive_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive, frameworks_),
  };
  Archive_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Archive_descriptor_,
      Archive::default_instance_,
      Archive_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Archive));
  Archive_Framework_descriptor_ = Archive_descriptor_->nested_type(0);
  static const int Archive_Framework_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, framework_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, pid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, tasks_),
  };
  Archive_Framework_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Archive_Framework_descriptor_,
      Archive_Framework::default_instance_,
      Archive_Framework_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Archive_Framework));
  TaskHealthStatus_descriptor_ = file->message_type(46);
  static const int TaskHealthStatus_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, healthy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, kill_task_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, consecutive_failures_),
  };
  TaskHealthStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskHealthStatus_descriptor_,
      TaskHealthStatus::default_instance_,
      TaskHealthStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskHealthStatus));
  HookExecuted_descriptor_ = file->message_type(47);
  static const int HookExecuted_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HookExecuted, module_),
  };
  HookExecuted_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HookExecuted_descriptor_,
      HookExecuted::default_instance_,
      HookExecuted_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HookExecuted, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HookExecuted, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HookExecuted));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2fmessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Task_descriptor_, &Task::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StatusUpdate_descriptor_, &StatusUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StatusUpdateRecord_descriptor_, &StatusUpdateRecord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubmitSchedulerRequest_descriptor_, &SubmitSchedulerRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubmitSchedulerResponse_descriptor_, &SubmitSchedulerResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutorToFrameworkMessage_descriptor_, &ExecutorToFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkToExecutorMessage_descriptor_, &FrameworkToExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterFrameworkMessage_descriptor_, &RegisterFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReregisterFrameworkMessage_descriptor_, &ReregisterFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkRegisteredMessage_descriptor_, &FrameworkRegisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkReregisteredMessage_descriptor_, &FrameworkReregisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnregisterFrameworkMessage_descriptor_, &UnregisterFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeactivateFrameworkMessage_descriptor_, &DeactivateFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceRequestMessage_descriptor_, &ResourceRequestMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceOffersMessage_descriptor_, &ResourceOffersMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LaunchTasksMessage_descriptor_, &LaunchTasksMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RescindResourceOfferMessage_descriptor_, &RescindResourceOfferMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReviveOffersMessage_descriptor_, &ReviveOffersMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RunTaskMessage_descriptor_, &RunTaskMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KillTaskMessage_descriptor_, &KillTaskMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StatusUpdateMessage_descriptor_, &StatusUpdateMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StatusUpdateAcknowledgementMessage_descriptor_, &StatusUpdateAcknowledgementMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LostSlaveMessage_descriptor_, &LostSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReconcileTasksMessage_descriptor_, &ReconcileTasksMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkErrorMessage_descriptor_, &FrameworkErrorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterSlaveMessage_descriptor_, &RegisterSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReregisterSlaveMessage_descriptor_, &ReregisterSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveRegisteredMessage_descriptor_, &SlaveRegisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveReregisteredMessage_descriptor_, &SlaveReregisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnregisterSlaveMessage_descriptor_, &UnregisterSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MasterSlaveConnection_descriptor_, &MasterSlaveConnection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PingSlaveMessage_descriptor_, &PingSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PongSlaveMessage_descriptor_, &PongSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShutdownFrameworkMessage_descriptor_, &ShutdownFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShutdownExecutorMessage_descriptor_, &ShutdownExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateFrameworkMessage_descriptor_, &UpdateFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckpointResourcesMessage_descriptor_, &CheckpointResourcesMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateSlaveMessage_descriptor_, &UpdateSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterExecutorMessage_descriptor_, &RegisterExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutorRegisteredMessage_descriptor_, &ExecutorRegisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutorReregisteredMessage_descriptor_, &ExecutorReregisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExitedExecutorMessage_descriptor_, &ExitedExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReconnectExecutorMessage_descriptor_, &ReconnectExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReregisterExecutorMessage_descriptor_, &ReregisterExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShutdownMessage_descriptor_, &ShutdownMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Archive_descriptor_, &Archive::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Archive_Framework_descriptor_, &Archive_Framework::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskHealthStatus_descriptor_, &TaskHealthStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HookExecuted_descriptor_, &HookExecuted::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2fmessages_2eproto() {
  delete Task::default_instance_;
  delete Task_reflection_;
  delete StatusUpdate::default_instance_;
  delete StatusUpdate_reflection_;
  delete StatusUpdateRecord::default_instance_;
  delete StatusUpdateRecord_reflection_;
  delete SubmitSchedulerRequest::default_instance_;
  delete SubmitSchedulerRequest_reflection_;
  delete SubmitSchedulerResponse::default_instance_;
  delete SubmitSchedulerResponse_reflection_;
  delete ExecutorToFrameworkMessage::default_instance_;
  delete ExecutorToFrameworkMessage_reflection_;
  delete FrameworkToExecutorMessage::default_instance_;
  delete FrameworkToExecutorMessage_reflection_;
  delete RegisterFrameworkMessage::default_instance_;
  delete RegisterFrameworkMessage_reflection_;
  delete ReregisterFrameworkMessage::default_instance_;
  delete ReregisterFrameworkMessage_reflection_;
  delete FrameworkRegisteredMessage::default_instance_;
  delete FrameworkRegisteredMessage_reflection_;
  delete FrameworkReregisteredMessage::default_instance_;
  delete FrameworkReregisteredMessage_reflection_;
  delete UnregisterFrameworkMessage::default_instance_;
  delete UnregisterFrameworkMessage_reflection_;
  delete DeactivateFrameworkMessage::default_instance_;
  delete DeactivateFrameworkMessage_reflection_;
  delete ResourceRequestMessage::default_instance_;
  delete ResourceRequestMessage_reflection_;
  delete ResourceOffersMessage::default_instance_;
  delete ResourceOffersMessage_reflection_;
  delete LaunchTasksMessage::default_instance_;
  delete LaunchTasksMessage_reflection_;
  delete RescindResourceOfferMessage::default_instance_;
  delete RescindResourceOfferMessage_reflection_;
  delete ReviveOffersMessage::default_instance_;
  delete ReviveOffersMessage_reflection_;
  delete RunTaskMessage::default_instance_;
  delete RunTaskMessage_reflection_;
  delete KillTaskMessage::default_instance_;
  delete KillTaskMessage_reflection_;
  delete StatusUpdateMessage::default_instance_;
  delete StatusUpdateMessage_reflection_;
  delete StatusUpdateAcknowledgementMessage::default_instance_;
  delete StatusUpdateAcknowledgementMessage_reflection_;
  delete LostSlaveMessage::default_instance_;
  delete LostSlaveMessage_reflection_;
  delete ReconcileTasksMessage::default_instance_;
  delete ReconcileTasksMessage_reflection_;
  delete FrameworkErrorMessage::default_instance_;
  delete FrameworkErrorMessage_reflection_;
  delete RegisterSlaveMessage::default_instance_;
  delete RegisterSlaveMessage_reflection_;
  delete ReregisterSlaveMessage::default_instance_;
  delete ReregisterSlaveMessage_reflection_;
  delete SlaveRegisteredMessage::default_instance_;
  delete SlaveRegisteredMessage_reflection_;
  delete SlaveReregisteredMessage::default_instance_;
  delete SlaveReregisteredMessage_reflection_;
  delete UnregisterSlaveMessage::default_instance_;
  delete UnregisterSlaveMessage_reflection_;
  delete MasterSlaveConnection::default_instance_;
  delete MasterSlaveConnection_reflection_;
  delete PingSlaveMessage::default_instance_;
  delete PingSlaveMessage_reflection_;
  delete PongSlaveMessage::default_instance_;
  delete PongSlaveMessage_reflection_;
  delete ShutdownFrameworkMessage::default_instance_;
  delete ShutdownFrameworkMessage_reflection_;
  delete ShutdownExecutorMessage::default_instance_;
  delete ShutdownExecutorMessage_reflection_;
  delete UpdateFrameworkMessage::default_instance_;
  delete UpdateFrameworkMessage_reflection_;
  delete CheckpointResourcesMessage::default_instance_;
  delete CheckpointResourcesMessage_reflection_;
  delete UpdateSlaveMessage::default_instance_;
  delete UpdateSlaveMessage_reflection_;
  delete RegisterExecutorMessage::default_instance_;
  delete RegisterExecutorMessage_reflection_;
  delete ExecutorRegisteredMessage::default_instance_;
  delete ExecutorRegisteredMessage_reflection_;
  delete ExecutorReregisteredMessage::default_instance_;
  delete ExecutorReregisteredMessage_reflection_;
  delete ExitedExecutorMessage::default_instance_;
  delete ExitedExecutorMessage_reflection_;
  delete ReconnectExecutorMessage::default_instance_;
  delete ReconnectExecutorMessage_reflection_;
  delete ReregisterExecutorMessage::default_instance_;
  delete ReregisterExecutorMessage_reflection_;
  delete ShutdownMessage::default_instance_;
  delete ShutdownMessage_reflection_;
  delete Archive::default_instance_;
  delete Archive_reflection_;
  delete Archive_Framework::default_instance_;
  delete Archive_Framework_reflection_;
  delete TaskHealthStatus::default_instance_;
  delete TaskHealthStatus_reflection_;
  delete HookExecuted::default_instance_;
  delete HookExecuted_reflection_;
}

void protobuf_AddDesc_messages_2fmessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mesos::protobuf_AddDesc_mesos_2fmesos_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\027messages/messages.proto\022\016mesos.interna"
    "l\032\021mesos/mesos.proto\"\245\003\n\004Task\022\014\n\004name\030\001 "
    "\002(\t\022\036\n\007task_id\030\002 \002(\0132\r.mesos.TaskID\022(\n\014f"
    "ramework_id\030\003 \002(\0132\022.mesos.FrameworkID\022&\n"
    "\013executor_id\030\004 \001(\0132\021.mesos.ExecutorID\022 \n"
    "\010slave_id\030\005 \002(\0132\016.mesos.SlaveID\022\037\n\005state"
    "\030\006 \002(\0162\020.mesos.TaskState\022\"\n\tresources\030\007 "
    "\003(\0132\017.mesos.Resource\022#\n\010statuses\030\010 \003(\0132\021"
    ".mesos.TaskStatus\022-\n\023status_update_state"
    "\030\t \001(\0162\020.mesos.TaskState\022\032\n\022status_updat"
    "e_uuid\030\n \001(\014\022\035\n\006labels\030\013 \001(\0132\r.mesos.Lab"
    "els\022\'\n\tdiscovery\030\014 \001(\0132\024.mesos.Discovery"
    "Info\"\356\001\n\014StatusUpdate\022(\n\014framework_id\030\001 "
    "\002(\0132\022.mesos.FrameworkID\022&\n\013executor_id\030\002"
    " \001(\0132\021.mesos.ExecutorID\022 \n\010slave_id\030\003 \001("
    "\0132\016.mesos.SlaveID\022!\n\006status\030\004 \002(\0132\021.meso"
    "s.TaskStatus\022\021\n\ttimestamp\030\005 \002(\001\022\014\n\004uuid\030"
    "\006 \001(\014\022&\n\014latest_state\030\007 \001(\0162\020.mesos.Task"
    "State\"\244\001\n\022StatusUpdateRecord\0225\n\004type\030\001 \002"
    "(\0162\'.mesos.internal.StatusUpdateRecord.T"
    "ype\022,\n\006update\030\002 \001(\0132\034.mesos.internal.Sta"
    "tusUpdate\022\014\n\004uuid\030\003 \001(\014\"\033\n\004Type\022\n\n\006UPDAT"
    "E\020\000\022\007\n\003ACK\020\001\"&\n\026SubmitSchedulerRequest\022\014"
    "\n\004name\030\001 \002(\t\"\'\n\027SubmitSchedulerResponse\022"
    "\014\n\004okay\030\001 \002(\010\"\236\001\n\032ExecutorToFrameworkMes"
    "sage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID\022("
    "\n\014framework_id\030\002 \002(\0132\022.mesos.FrameworkID"
    "\022&\n\013executor_id\030\003 \002(\0132\021.mesos.ExecutorID"
    "\022\014\n\004data\030\004 \002(\014\"\236\001\n\032FrameworkToExecutorMe"
    "ssage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID\022"
    "(\n\014framework_id\030\002 \002(\0132\022.mesos.FrameworkI"
    "D\022&\n\013executor_id\030\003 \002(\0132\021.mesos.ExecutorI"
    "D\022\014\n\004data\030\004 \002(\014\"C\n\030RegisterFrameworkMess"
    "age\022\'\n\tframework\030\001 \002(\0132\024.mesos.Framework"
    "Info\"W\n\032ReregisterFrameworkMessage\022\'\n\tfr"
    "amework\030\002 \002(\0132\024.mesos.FrameworkInfo\022\020\n\010f"
    "ailover\030\003 \002(\010\"n\n\032FrameworkRegisteredMess"
    "age\022(\n\014framework_id\030\001 \002(\0132\022.mesos.Framew"
    "orkID\022&\n\013master_info\030\002 \002(\0132\021.mesos.Maste"
    "rInfo\"p\n\034FrameworkReregisteredMessage\022(\n"
    "\014framework_id\030\001 \002(\0132\022.mesos.FrameworkID\022"
    "&\n\013master_info\030\002 \002(\0132\021.mesos.MasterInfo\""
    "F\n\032UnregisterFrameworkMessage\022(\n\014framewo"
    "rk_id\030\001 \002(\0132\022.mesos.FrameworkID\"F\n\032Deact"
    "ivateFrameworkMessage\022(\n\014framework_id\030\001 "
    "\002(\0132\022.mesos.FrameworkID\"d\n\026ResourceReque"
    "stMessage\022(\n\014framework_id\030\001 \002(\0132\022.mesos."
    "FrameworkID\022 \n\010requests\030\002 \003(\0132\016.mesos.Re"
    "quest\"p\n\025ResourceOffersMessage\022\034\n\006offers"
    "\030\001 \003(\0132\014.mesos.Offer\022\014\n\004pids\030\002 \003(\t\022+\n\016in"
    "verse_offers\030\003 \003(\0132\023.mesos.InverseOffer\""
    "\242\001\n\022LaunchTasksMessage\022(\n\014framework_id\030\001"
    " \002(\0132\022.mesos.FrameworkID\022\036\n\005tasks\030\003 \003(\0132"
    "\017.mesos.TaskInfo\022\037\n\007filters\030\005 \002(\0132\016.meso"
    "s.Filters\022!\n\toffer_ids\030\006 \003(\0132\016.mesos.Off"
    "erID\"\?\n\033RescindResourceOfferMessage\022 \n\010o"
    "ffer_id\030\001 \002(\0132\016.mesos.OfferID\"\?\n\023ReviveO"
    "ffersMessage\022(\n\014framework_id\030\001 \002(\0132\022.mes"
    "os.FrameworkID\"\223\001\n\016RunTaskMessage\022,\n\014fra"
    "mework_id\030\001 \001(\0132\022.mesos.FrameworkIDB\002\030\001\022"
    "\'\n\tframework\030\002 \002(\0132\024.mesos.FrameworkInfo"
    "\022\035\n\004task\030\004 \002(\0132\017.mesos.TaskInfo\022\013\n\003pid\030\003"
    " \001(\t\"[\n\017KillTaskMessage\022(\n\014framework_id\030"
    "\001 \002(\0132\022.mesos.FrameworkID\022\036\n\007task_id\030\002 \002"
    "(\0132\r.mesos.TaskID\"P\n\023StatusUpdateMessage"
    "\022,\n\006update\030\001 \002(\0132\034.mesos.internal.Status"
    "Update\022\013\n\003pid\030\002 \001(\t\"\236\001\n\"StatusUpdateAckn"
    "owledgementMessage\022 \n\010slave_id\030\001 \002(\0132\016.m"
    "esos.SlaveID\022(\n\014framework_id\030\002 \002(\0132\022.mes"
    "os.FrameworkID\022\036\n\007task_id\030\003 \002(\0132\r.mesos."
    "TaskID\022\014\n\004uuid\030\004 \002(\014\"4\n\020LostSlaveMessage"
    "\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID\"f\n\025Re"
    "concileTasksMessage\022(\n\014framework_id\030\001 \002("
    "\0132\022.mesos.FrameworkID\022#\n\010statuses\030\002 \003(\0132"
    "\021.mesos.TaskStatus\"(\n\025FrameworkErrorMess"
    "age\022\017\n\007message\030\002 \002(\t\"y\n\024RegisterSlaveMes"
    "sage\022\037\n\005slave\030\001 \002(\0132\020.mesos.SlaveInfo\022/\n"
    "\026checkpointed_resources\030\003 \003(\0132\017.mesos.Re"
    "source\022\017\n\007version\030\002 \001(\t\"\216\002\n\026ReregisterSl"
    "aveMessage\022\037\n\005slave\030\002 \002(\0132\020.mesos.SlaveI"
    "nfo\022/\n\026checkpointed_resources\030\007 \003(\0132\017.me"
    "sos.Resource\022+\n\016executor_infos\030\004 \003(\0132\023.m"
    "esos.ExecutorInfo\022#\n\005tasks\030\003 \003(\0132\024.mesos"
    ".internal.Task\022\?\n\024completed_frameworks\030\005"
    " \003(\0132!.mesos.internal.Archive.Framework\022"
    "\017\n\007version\030\006 \001(\t\"u\n\026SlaveRegisteredMessa"
    "ge\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID\0229\n\n"
    "connection\030\002 \001(\0132%.mesos.internal.Master"
    "SlaveConnection\"\267\001\n\030SlaveReregisteredMes"
    "sage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID\022>"
    "\n\017reconciliations\030\002 \003(\0132%.mesos.internal"
    ".ReconcileTasksMessage\0229\n\nconnection\030\003 \001"
    "(\0132%.mesos.internal.MasterSlaveConnectio"
    "n\":\n\026UnregisterSlaveMessage\022 \n\010slave_id\030"
    "\001 \002(\0132\016.mesos.SlaveID\";\n\025MasterSlaveConn"
    "ection\022\"\n\032total_ping_timeout_seconds\030\001 \001"
    "(\001\"%\n\020PingSlaveMessage\022\021\n\tconnected\030\001 \002("
    "\010\"\022\n\020PongSlaveMessage\"D\n\030ShutdownFramewo"
    "rkMessage\022(\n\014framework_id\030\001 \002(\0132\022.mesos."
    "FrameworkID\"k\n\027ShutdownExecutorMessage\022&"
    "\n\013executor_id\030\001 \001(\0132\021.mesos.ExecutorID\022("
    "\n\014framework_id\030\002 \001(\0132\022.mesos.FrameworkID"
    "\"O\n\026UpdateFrameworkMessage\022(\n\014framework_"
    "id\030\001 \002(\0132\022.mesos.FrameworkID\022\013\n\003pid\030\002 \001("
    "\t\"@\n\032CheckpointResourcesMessage\022\"\n\tresou"
    "rces\030\001 \003(\0132\017.mesos.Resource\"i\n\022UpdateSla"
    "veMessage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.Slav"
    "eID\0221\n\030oversubscribed_resources\030\002 \003(\0132\017."
    "mesos.Resource\"k\n\027RegisterExecutorMessag"
    "e\022(\n\014framework_id\030\001 \002(\0132\022.mesos.Framewor"
    "kID\022&\n\013executor_id\030\002 \002(\0132\021.mesos.Executo"
    "rID\"\347\001\n\031ExecutorRegisteredMessage\022*\n\rexe"
    "cutor_info\030\002 \002(\0132\023.mesos.ExecutorInfo\022(\n"
    "\014framework_id\030\003 \002(\0132\022.mesos.FrameworkID\022"
    ",\n\016framework_info\030\004 \002(\0132\024.mesos.Framewor"
    "kInfo\022 \n\010slave_id\030\005 \002(\0132\016.mesos.SlaveID\022"
    "$\n\nslave_info\030\006 \002(\0132\020.mesos.SlaveInfo\"e\n"
    "\033ExecutorReregisteredMessage\022 \n\010slave_id"
    "\030\001 \002(\0132\016.mesos.SlaveID\022$\n\nslave_info\030\002 \002"
    "(\0132\020.mesos.SlaveInfo\"\233\001\n\025ExitedExecutorM"
    "essage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID"
    "\022(\n\014framework_id\030\002 \002(\0132\022.mesos.Framework"
    "ID\022&\n\013executor_id\030\003 \002(\0132\021.mesos.Executor"
    "ID\022\016\n\006status\030\004 \002(\005\"<\n\030ReconnectExecutorM"
    "essage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID"
    "\"\274\001\n\031ReregisterExecutorMessage\022&\n\013execut"
    "or_id\030\001 \002(\0132\021.mesos.ExecutorID\022(\n\014framew"
    "ork_id\030\002 \002(\0132\022.mesos.FrameworkID\022\036\n\005task"
    "s\030\003 \003(\0132\017.mesos.TaskInfo\022-\n\007updates\030\004 \003("
    "\0132\034.mesos.internal.StatusUpdate\"\"\n\017Shutd"
    "ownMessage\022\017\n\007message\030\001 \001(\t\"\255\001\n\007Archive\022"
    "5\n\nframeworks\030\001 \003(\0132!.mesos.internal.Arc"
    "hive.Framework\032k\n\tFramework\022,\n\016framework"
    "_info\030\001 \002(\0132\024.mesos.FrameworkInfo\022\013\n\003pid"
    "\030\002 \001(\t\022#\n\005tasks\030\003 \003(\0132\024.mesos.internal.T"
    "ask\"{\n\020TaskHealthStatus\022\036\n\007task_id\030\001 \002(\013"
    "2\r.mesos.TaskID\022\017\n\007healthy\030\002 \002(\010\022\030\n\tkill"
    "_task\030\003 \001(\010:\005false\022\034\n\024consecutive_failur"
    "es\030\004 \001(\005\"\036\n\014HookExecuted\022\016\n\006module\030\001 \001(\t", 5560);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages/messages.proto", &protobuf_RegisterTypes);
  Task::default_instance_ = new Task();
  StatusUpdate::default_instance_ = new StatusUpdate();
  StatusUpdateRecord::default_instance_ = new StatusUpdateRecord();
  SubmitSchedulerRequest::default_instance_ = new SubmitSchedulerRequest();
  SubmitSchedulerResponse::default_instance_ = new SubmitSchedulerResponse();
  ExecutorToFrameworkMessage::default_instance_ = new ExecutorToFrameworkMessage();
  FrameworkToExecutorMessage::default_instance_ = new FrameworkToExecutorMessage();
  RegisterFrameworkMessage::default_instance_ = new RegisterFrameworkMessage();
  ReregisterFrameworkMessage::default_instance_ = new ReregisterFrameworkMessage();
  FrameworkRegisteredMessage::default_instance_ = new FrameworkRegisteredMessage();
  FrameworkReregisteredMessage::default_instance_ = new FrameworkReregisteredMessage();
  UnregisterFrameworkMessage::default_instance_ = new UnregisterFrameworkMessage();
  DeactivateFrameworkMessage::default_instance_ = new DeactivateFrameworkMessage();
  ResourceRequestMessage::default_instance_ = new ResourceRequestMessage();
  ResourceOffersMessage::default_instance_ = new ResourceOffersMessage();
  LaunchTasksMessage::default_instance_ = new LaunchTasksMessage();
  RescindResourceOfferMessage::default_instance_ = new RescindResourceOfferMessage();
  ReviveOffersMessage::default_instance_ = new ReviveOffersMessage();
  RunTaskMessage::default_instance_ = new RunTaskMessage();
  KillTaskMessage::default_instance_ = new KillTaskMessage();
  StatusUpdateMessage::default_instance_ = new StatusUpdateMessage();
  StatusUpdateAcknowledgementMessage::default_instance_ = new StatusUpdateAcknowledgementMessage();
  LostSlaveMessage::default_instance_ = new LostSlaveMessage();
  ReconcileTasksMessage::default_instance_ = new ReconcileTasksMessage();
  FrameworkErrorMessage::default_instance_ = new FrameworkErrorMessage();
  RegisterSlaveMessage::default_instance_ = new RegisterSlaveMessage();
  ReregisterSlaveMessage::default_instance_ = new ReregisterSlaveMessage();
  SlaveRegisteredMessage::default_instance_ = new SlaveRegisteredMessage();
  SlaveReregisteredMessage::default_instance_ = new SlaveReregisteredMessage();
  UnregisterSlaveMessage::default_instance_ = new UnregisterSlaveMessage();
  MasterSlaveConnection::default_instance_ = new MasterSlaveConnection();
  PingSlaveMessage::default_instance_ = new PingSlaveMessage();
  PongSlaveMessage::default_instance_ = new PongSlaveMessage();
  ShutdownFrameworkMessage::default_instance_ = new ShutdownFrameworkMessage();
  ShutdownExecutorMessage::default_instance_ = new ShutdownExecutorMessage();
  UpdateFrameworkMessage::default_instance_ = new UpdateFrameworkMessage();
  CheckpointResourcesMessage::default_instance_ = new CheckpointResourcesMessage();
  UpdateSlaveMessage::default_instance_ = new UpdateSlaveMessage();
  RegisterExecutorMessage::default_instance_ = new RegisterExecutorMessage();
  ExecutorRegisteredMessage::default_instance_ = new ExecutorRegisteredMessage();
  ExecutorReregisteredMessage::default_instance_ = new ExecutorReregisteredMessage();
  ExitedExecutorMessage::default_instance_ = new ExitedExecutorMessage();
  ReconnectExecutorMessage::default_instance_ = new ReconnectExecutorMessage();
  ReregisterExecutorMessage::default_instance_ = new ReregisterExecutorMessage();
  ShutdownMessage::default_instance_ = new ShutdownMessage();
  Archive::default_instance_ = new Archive();
  Archive_Framework::default_instance_ = new Archive_Framework();
  TaskHealthStatus::default_instance_ = new TaskHealthStatus();
  HookExecuted::default_instance_ = new HookExecuted();
  Task::default_instance_->InitAsDefaultInstance();
  StatusUpdate::default_instance_->InitAsDefaultInstance();
  StatusUpdateRecord::default_instance_->InitAsDefaultInstance();
  SubmitSchedulerRequest::default_instance_->InitAsDefaultInstance();
  SubmitSchedulerResponse::default_instance_->InitAsDefaultInstance();
  ExecutorToFrameworkMessage::default_instance_->InitAsDefaultInstance();
  FrameworkToExecutorMessage::default_instance_->InitAsDefaultInstance();
  RegisterFrameworkMessage::default_instance_->InitAsDefaultInstance();
  ReregisterFrameworkMessage::default_instance_->InitAsDefaultInstance();
  FrameworkRegisteredMessage::default_instance_->InitAsDefaultInstance();
  FrameworkReregisteredMessage::default_instance_->InitAsDefaultInstance();
  UnregisterFrameworkMessage::default_instance_->InitAsDefaultInstance();
  DeactivateFrameworkMessage::default_instance_->InitAsDefaultInstance();
  ResourceRequestMessage::default_instance_->InitAsDefaultInstance();
  ResourceOffersMessage::default_instance_->InitAsDefaultInstance();
  LaunchTasksMessage::default_instance_->InitAsDefaultInstance();
  RescindResourceOfferMessage::default_instance_->InitAsDefaultInstance();
  ReviveOffersMessage::default_instance_->InitAsDefaultInstance();
  RunTaskMessage::default_instance_->InitAsDefaultInstance();
  KillTaskMessage::default_instance_->InitAsDefaultInstance();
  StatusUpdateMessage::default_instance_->InitAsDefaultInstance();
  StatusUpdateAcknowledgementMessage::default_instance_->InitAsDefaultInstance();
  LostSlaveMessage::default_instance_->InitAsDefaultInstance();
  ReconcileTasksMessage::default_instance_->InitAsDefaultInstance();
  FrameworkErrorMessage::default_instance_->InitAsDefaultInstance();
  RegisterSlaveMessage::default_instance_->InitAsDefaultInstance();
  ReregisterSlaveMessage::default_instance_->InitAsDefaultInstance();
  SlaveRegisteredMessage::default_instance_->InitAsDefaultInstance();
  SlaveReregisteredMessage::default_instance_->InitAsDefaultInstance();
  UnregisterSlaveMessage::default_instance_->InitAsDefaultInstance();
  MasterSlaveConnection::default_instance_->InitAsDefaultInstance();
  PingSlaveMessage::default_instance_->InitAsDefaultInstance();
  PongSlaveMessage::default_instance_->InitAsDefaultInstance();
  ShutdownFrameworkMessage::default_instance_->InitAsDefaultInstance();
  ShutdownExecutorMessage::default_instance_->InitAsDefaultInstance();
  UpdateFrameworkMessage::default_instance_->InitAsDefaultInstance();
  CheckpointResourcesMessage::default_instance_->InitAsDefaultInstance();
  UpdateSlaveMessage::default_instance_->InitAsDefaultInstance();
  RegisterExecutorMessage::default_instance_->InitAsDefaultInstance();
  ExecutorRegisteredMessage::default_instance_->InitAsDefaultInstance();
  ExecutorReregisteredMessage::default_instance_->InitAsDefaultInstance();
  ExitedExecutorMessage::default_instance_->InitAsDefaultInstance();
  ReconnectExecutorMessage::default_instance_->InitAsDefaultInstance();
  ReregisterExecutorMessage::default_instance_->InitAsDefaultInstance();
  ShutdownMessage::default_instance_->InitAsDefaultInstance();
  Archive::default_instance_->InitAsDefaultInstance();
  Archive_Framework::default_instance_->InitAsDefaultInstance();
  TaskHealthStatus::default_instance_->InitAsDefaultInstance();
  HookExecuted::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2fmessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2fmessages_2eproto {
  StaticDescriptorInitializer_messages_2fmessages_2eproto() {
    protobuf_AddDesc_messages_2fmessages_2eproto();
  }
} static_descriptor_initializer_messages_2fmessages_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Task::kNameFieldNumber;
const int Task::kTaskIdFieldNumber;
const int Task::kFrameworkIdFieldNumber;
const int Task::kExecutorIdFieldNumber;
const int Task::kSlaveIdFieldNumber;
const int Task::kStateFieldNumber;
const int Task::kResourcesFieldNumber;
const int Task::kStatusesFieldNumber;
const int Task::kStatusUpdateStateFieldNumber;
const int Task::kStatusUpdateUuidFieldNumber;
const int Task::kLabelsFieldNumber;
const int Task::kDiscoveryFieldNumber;
#endif  // !_MSC_VER

Task::Task()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Task::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
  discovery_ = const_cast< ::mesos::DiscoveryInfo*>(&::mesos::DiscoveryInfo::default_instance());
}

Task::Task(const Task& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Task::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  task_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  slave_id_ = NULL;
  state_ = 6;
  status_update_state_ = 6;
  status_update_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  labels_ = NULL;
  discovery_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Task::~Task() {
  SharedDtor();
}

void Task::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (status_update_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete status_update_uuid_;
  }
  if (this != default_instance_) {
    delete task_id_;
    delete framework_id_;
    delete executor_id_;
    delete slave_id_;
    delete labels_;
    delete discovery_;
  }
}

void Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Task_descriptor_;
}

const Task& Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

Task* Task::default_instance_ = NULL;

Task* Task::New() const {
  return new Task;
}

void Task::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    state_ = 6;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    status_update_state_ = 6;
    if (has_status_update_uuid()) {
      if (status_update_uuid_ != &::google::protobuf::internal::kEmptyString) {
        status_update_uuid_->clear();
      }
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
    if (has_discovery()) {
      if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
    }
  }
  resources_.Clear();
  statuses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_executor_id;
        break;
      }

      // optional .mesos.ExecutorID executor_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_state;
        break;
      }

      // required .mesos.TaskState state = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_resources;
        if (input->ExpectTag(66)) goto parse_statuses;
        break;
      }

      // repeated .mesos.TaskStatus statuses = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_statuses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_statuses()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_statuses;
        if (input->ExpectTag(72)) goto parse_status_update_state;
        break;
      }

      // optional .mesos.TaskState status_update_state = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status_update_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_status_update_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_status_update_uuid;
        break;
      }

      // optional bytes status_update_uuid = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_status_update_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_status_update_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_discovery;
        break;
      }

      // optional .mesos.DiscoveryInfo discovery = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_discovery:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_discovery()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->framework_id(), output);
  }

  // optional .mesos.ExecutorID executor_id = 4;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->executor_id(), output);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->slave_id(), output);
  }

  // required .mesos.TaskState state = 6;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->state(), output);
  }

  // repeated .mesos.Resource resources = 7;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->resources(i), output);
  }

  // repeated .mesos.TaskStatus statuses = 8;
  for (int i = 0; i < this->statuses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->statuses(i), output);
  }

  // optional .mesos.TaskState status_update_state = 9;
  if (has_status_update_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->status_update_state(), output);
  }

  // optional bytes status_update_uuid = 10;
  if (has_status_update_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->status_update_uuid(), output);
  }

  // optional .mesos.Labels labels = 11;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->labels(), output);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->discovery(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Task::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->framework_id(), target);
  }

  // optional .mesos.ExecutorID executor_id = 4;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->executor_id(), target);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->slave_id(), target);
  }

  // required .mesos.TaskState state = 6;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->state(), target);
  }

  // repeated .mesos.Resource resources = 7;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->resources(i), target);
  }

  // repeated .mesos.TaskStatus statuses = 8;
  for (int i = 0; i < this->statuses_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->statuses(i), target);
  }

  // optional .mesos.TaskState status_update_state = 9;
  if (has_status_update_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->status_update_state(), target);
  }

  // optional bytes status_update_uuid = 10;
  if (has_status_update_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->status_update_uuid(), target);
  }

  // optional .mesos.Labels labels = 11;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->labels(), target);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->discovery(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Task::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .mesos.TaskID task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required .mesos.FrameworkID framework_id = 3;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional .mesos.ExecutorID executor_id = 4;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required .mesos.SlaveID slave_id = 5;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.TaskState state = 6;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.TaskState status_update_state = 9;
    if (has_status_update_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status_update_state());
    }

    // optional bytes status_update_uuid = 10;
    if (has_status_update_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->status_update_uuid());
    }

    // optional .mesos.Labels labels = 11;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

    // optional .mesos.DiscoveryInfo discovery = 12;
    if (has_discovery()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->discovery());
    }

  }
  // repeated .mesos.Resource resources = 7;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated .mesos.TaskStatus statuses = 8;
  total_size += 1 * this->statuses_size();
  for (int i = 0; i < this->statuses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->statuses(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Task::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Task* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Task*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Task::MergeFrom(const Task& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  statuses_.MergeFrom(from.statuses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_status_update_state()) {
      set_status_update_state(from.status_update_state());
    }
    if (from.has_status_update_uuid()) {
      set_status_update_uuid(from.status_update_uuid());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
    if (from.has_discovery()) {
      mutable_discovery()->::mesos::DiscoveryInfo::MergeFrom(from.discovery());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Task::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Task::CopyFrom(const Task& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000037) != 0x00000037) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  for (int i = 0; i < resources_size(); i++) {
    if (!this->resources(i).IsInitialized()) return false;
  }
  for (int i = 0; i < statuses_size(); i++) {
    if (!this->statuses(i).IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  if (has_discovery()) {
    if (!this->discovery().IsInitialized()) return false;
  }
  return true;
}

void Task::Swap(Task* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(task_id_, other->task_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(state_, other->state_);
    resources_.Swap(&other->resources_);
    statuses_.Swap(&other->statuses_);
    std::swap(status_update_state_, other->status_update_state_);
    std::swap(status_update_uuid_, other->status_update_uuid_);
    std::swap(labels_, other->labels_);
    std::swap(discovery_, other->discovery_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Task_descriptor_;
  metadata.reflection = Task_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StatusUpdate::kFrameworkIdFieldNumber;
const int StatusUpdate::kExecutorIdFieldNumber;
const int StatusUpdate::kSlaveIdFieldNumber;
const int StatusUpdate::kStatusFieldNumber;
const int StatusUpdate::kTimestampFieldNumber;
const int StatusUpdate::kUuidFieldNumber;
const int StatusUpdate::kLatestStateFieldNumber;
#endif  // !_MSC_VER

StatusUpdate::StatusUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StatusUpdate::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  status_ = const_cast< ::mesos::TaskStatus*>(&::mesos::TaskStatus::default_instance());
}

StatusUpdate::StatusUpdate(const StatusUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StatusUpdate::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  executor_id_ = NULL;
  slave_id_ = NULL;
  status_ = NULL;
  timestamp_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  latest_state_ = 6;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusUpdate::~StatusUpdate() {
  SharedDtor();
}

void StatusUpdate::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete framework_id_;
    delete executor_id_;
    delete slave_id_;
    delete status_;
  }
}

void StatusUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StatusUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdate_descriptor_;
}

const StatusUpdate& StatusUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

StatusUpdate* StatusUpdate::default_instance_ = NULL;

StatusUpdate* StatusUpdate::New() const {
  return new StatusUpdate;
}

void StatusUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_status()) {
      if (status_ != NULL) status_->::mesos::TaskStatus::Clear();
    }
    timestamp_ = 0;
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    latest_state_ = 6;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StatusUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // optional .mesos.ExecutorID executor_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_status;
        break;
      }

      // required .mesos.TaskStatus status = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_timestamp;
        break;
      }

      // required double timestamp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_uuid;
        break;
      }

      // optional bytes uuid = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_latest_state;
        break;
      }

      // optional .mesos.TaskState latest_state = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_latest_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_latest_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StatusUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // optional .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  // optional .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->slave_id(), output);
  }

  // required .mesos.TaskStatus status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->status(), output);
  }

  // required double timestamp = 5;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->timestamp(), output);
  }

  // optional bytes uuid = 6;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->uuid(), output);
  }

  // optional .mesos.TaskState latest_state = 7;
  if (has_latest_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->latest_state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StatusUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // optional .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  // optional .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->slave_id(), target);
  }

  // required .mesos.TaskStatus status = 4;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->status(), target);
  }

  // required double timestamp = 5;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->timestamp(), target);
  }

  // optional bytes uuid = 6;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->uuid(), target);
  }

  // optional .mesos.TaskState latest_state = 7;
  if (has_latest_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->latest_state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StatusUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional .mesos.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // optional .mesos.SlaveID slave_id = 3;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.TaskStatus status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

    // required double timestamp = 5;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // optional bytes uuid = 6;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // optional .mesos.TaskState latest_state = 7;
    if (has_latest_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->latest_state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StatusUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StatusUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StatusUpdate::MergeFrom(const StatusUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_status()) {
      mutable_status()->::mesos::TaskStatus::MergeFrom(from.status());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_latest_state()) {
      set_latest_state(from.latest_state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StatusUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusUpdate::CopyFrom(const StatusUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000019) != 0x00000019) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void StatusUpdate::Swap(StatusUpdate* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(status_, other->status_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(uuid_, other->uuid_);
    std::swap(latest_state_, other->latest_state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StatusUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StatusUpdate_descriptor_;
  metadata.reflection = StatusUpdate_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* StatusUpdateRecord_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdateRecord_Type_descriptor_;
}
bool StatusUpdateRecord_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const StatusUpdateRecord_Type StatusUpdateRecord::UPDATE;
const StatusUpdateRecord_Type StatusUpdateRecord::ACK;
const StatusUpdateRecord_Type StatusUpdateRecord::Type_MIN;
const StatusUpdateRecord_Type StatusUpdateRecord::Type_MAX;
const int StatusUpdateRecord::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int StatusUpdateRecord::kTypeFieldNumber;
const int StatusUpdateRecord::kUpdateFieldNumber;
const int StatusUpdateRecord::kUuidFieldNumber;
#endif  // !_MSC_VER

StatusUpdateRecord::StatusUpdateRecord()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StatusUpdateRecord::InitAsDefaultInstance() {
  update_ = const_cast< ::mesos::internal::StatusUpdate*>(&::mesos::internal::StatusUpdate::default_instance());
}

StatusUpdateRecord::StatusUpdateRecord(const StatusUpdateRecord& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StatusUpdateRecord::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  update_ = NULL;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusUpdateRecord::~StatusUpdateRecord() {
  SharedDtor();
}

void StatusUpdateRecord::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete update_;
  }
}

void StatusUpdateRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StatusUpdateRecord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdateRecord_descriptor_;
}

const StatusUpdateRecord& StatusUpdateRecord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

StatusUpdateRecord* StatusUpdateRecord::default_instance_ = NULL;

StatusUpdateRecord* StatusUpdateRecord::New() const {
  return new StatusUpdateRecord;
}

void StatusUpdateRecord::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_update()) {
      if (update_ != NULL) update_->::mesos::internal::StatusUpdate::Clear();
    }
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StatusUpdateRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.internal.StatusUpdateRecord.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::internal::StatusUpdateRecord_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::internal::StatusUpdateRecord_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_update;
        break;
      }

      // optional .mesos.internal.StatusUpdate update = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_update:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_update()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_uuid;
        break;
      }

      // optional bytes uuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StatusUpdateRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.internal.StatusUpdateRecord.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.internal.StatusUpdate update = 2;
  if (has_update()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->update(), output);
  }

  // optional bytes uuid = 3;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StatusUpdateRecord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.internal.StatusUpdateRecord.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.internal.StatusUpdate update = 2;
  if (has_update()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->update(), target);
  }

  // optional bytes uuid = 3;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StatusUpdateRecord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.internal.StatusUpdateRecord.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.internal.StatusUpdate update = 2;
    if (has_update()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->update());
    }

    // optional bytes uuid = 3;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusUpdateRecord::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StatusUpdateRecord* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StatusUpdateRecord*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StatusUpdateRecord::MergeFrom(const StatusUpdateRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_update()) {
      mutable_update()->::mesos::internal::StatusUpdate::MergeFrom(from.update());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StatusUpdateRecord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusUpdateRecord::CopyFrom(const StatusUpdateRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusUpdateRecord::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_update()) {
    if (!this->update().IsInitialized()) return false;
  }
  return true;
}

void StatusUpdateRecord::Swap(StatusUpdateRecord* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(update_, other->update_);
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StatusUpdateRecord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StatusUpdateRecord_descriptor_;
  metadata.reflection = StatusUpdateRecord_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SubmitSchedulerRequest::kNameFieldNumber;
#endif  // !_MSC_VER

SubmitSchedulerRequest::SubmitSchedulerRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SubmitSchedulerRequest::InitAsDefaultInstance() {
}

SubmitSchedulerRequest::SubmitSchedulerRequest(const SubmitSchedulerRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SubmitSchedulerRequest::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubmitSchedulerRequest::~SubmitSchedulerRequest() {
  SharedDtor();
}

void SubmitSchedulerRequest::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void SubmitSchedulerRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubmitSchedulerRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubmitSchedulerRequest_descriptor_;
}

const SubmitSchedulerRequest& SubmitSchedulerRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

SubmitSchedulerRequest* SubmitSchedulerRequest::default_instance_ = NULL;

SubmitSchedulerRequest* SubmitSchedulerRequest::New() const {
  return new SubmitSchedulerRequest;
}

void SubmitSchedulerRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubmitSchedulerRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SubmitSchedulerRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SubmitSchedulerRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SubmitSchedulerRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubmitSchedulerRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubmitSchedulerRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubmitSchedulerRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SubmitSchedulerRequest::MergeFrom(const SubmitSchedulerRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubmitSchedulerRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubmitSchedulerRequest::CopyFrom(const SubmitSchedulerRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubmitSchedulerRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubmitSchedulerRequest::Swap(SubmitSchedulerRequest* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SubmitSchedulerRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubmitSchedulerRequest_descriptor_;
  metadata.reflection = SubmitSchedulerRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SubmitSchedulerResponse::kOkayFieldNumber;
#endif  // !_MSC_VER

SubmitSchedulerResponse::SubmitSchedulerResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SubmitSchedulerResponse::InitAsDefaultInstance() {
}

SubmitSchedulerResponse::SubmitSchedulerResponse(const SubmitSchedulerResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SubmitSchedulerResponse::SharedCtor() {
  _cached_size_ = 0;
  okay_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubmitSchedulerResponse::~SubmitSchedulerResponse() {
  SharedDtor();
}

void SubmitSchedulerResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SubmitSchedulerResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubmitSchedulerResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubmitSchedulerResponse_descriptor_;
}

const SubmitSchedulerResponse& SubmitSchedulerResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

SubmitSchedulerResponse* SubmitSchedulerResponse::default_instance_ = NULL;

SubmitSchedulerResponse* SubmitSchedulerResponse::New() const {
  return new SubmitSchedulerResponse;
}

void SubmitSchedulerResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    okay_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubmitSchedulerResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool okay = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &okay_)));
          set_has_okay();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SubmitSchedulerResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool okay = 1;
  if (has_okay()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->okay(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SubmitSchedulerResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool okay = 1;
  if (has_okay()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->okay(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SubmitSchedulerResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool okay = 1;
    if (has_okay()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubmitSchedulerResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubmitSchedulerResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubmitSchedulerResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SubmitSchedulerResponse::MergeFrom(const SubmitSchedulerResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_okay()) {
      set_okay(from.okay());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubmitSchedulerResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubmitSchedulerResponse::CopyFrom(const SubmitSchedulerResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubmitSchedulerResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubmitSchedulerResponse::Swap(SubmitSchedulerResponse* other) {
  if (other != this) {
    std::swap(okay_, other->okay_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SubmitSchedulerResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubmitSchedulerResponse_descriptor_;
  metadata.reflection = SubmitSchedulerResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutorToFrameworkMessage::kSlaveIdFieldNumber;
const int ExecutorToFrameworkMessage::kFrameworkIdFieldNumber;
const int ExecutorToFrameworkMessage::kExecutorIdFieldNumber;
const int ExecutorToFrameworkMessage::kDataFieldNumber;
#endif  // !_MSC_VER

ExecutorToFrameworkMessage::ExecutorToFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ExecutorToFrameworkMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

ExecutorToFrameworkMessage::ExecutorToFrameworkMessage(const ExecutorToFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ExecutorToFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorToFrameworkMessage::~ExecutorToFrameworkMessage() {
  SharedDtor();
}

void ExecutorToFrameworkMessage::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete framework_id_;
    delete executor_id_;
  }
}

void ExecutorToFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorToFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorToFrameworkMessage_descriptor_;
}

const ExecutorToFrameworkMessage& ExecutorToFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ExecutorToFrameworkMessage* ExecutorToFrameworkMessage::default_instance_ = NULL;

ExecutorToFrameworkMessage* ExecutorToFrameworkMessage::New() const {
  return new ExecutorToFrameworkMessage;
}

void ExecutorToFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutorToFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // required bytes data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExecutorToFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->executor_id(), output);
  }

  // required bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ExecutorToFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->executor_id(), target);
  }

  // required bytes data = 4;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ExecutorToFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.ExecutorID executor_id = 3;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorToFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutorToFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutorToFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutorToFrameworkMessage::MergeFrom(const ExecutorToFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutorToFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorToFrameworkMessage::CopyFrom(const ExecutorToFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorToFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void ExecutorToFrameworkMessage::Swap(ExecutorToFrameworkMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutorToFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorToFrameworkMessage_descriptor_;
  metadata.reflection = ExecutorToFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkToExecutorMessage::kSlaveIdFieldNumber;
const int FrameworkToExecutorMessage::kFrameworkIdFieldNumber;
const int FrameworkToExecutorMessage::kExecutorIdFieldNumber;
const int FrameworkToExecutorMessage::kDataFieldNumber;
#endif  // !_MSC_VER

FrameworkToExecutorMessage::FrameworkToExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FrameworkToExecutorMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

FrameworkToExecutorMessage::FrameworkToExecutorMessage(const FrameworkToExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FrameworkToExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkToExecutorMessage::~FrameworkToExecutorMessage() {
  SharedDtor();
}

void FrameworkToExecutorMessage::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete framework_id_;
    delete executor_id_;
  }
}

void FrameworkToExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkToExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkToExecutorMessage_descriptor_;
}

const FrameworkToExecutorMessage& FrameworkToExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

FrameworkToExecutorMessage* FrameworkToExecutorMessage::default_instance_ = NULL;

FrameworkToExecutorMessage* FrameworkToExecutorMessage::New() const {
  return new FrameworkToExecutorMessage;
}

void FrameworkToExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkToExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // required bytes data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameworkToExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->executor_id(), output);
  }

  // required bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FrameworkToExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->executor_id(), target);
  }

  // required bytes data = 4;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FrameworkToExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.ExecutorID executor_id = 3;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkToExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkToExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkToExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkToExecutorMessage::MergeFrom(const FrameworkToExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkToExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkToExecutorMessage::CopyFrom(const FrameworkToExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkToExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void FrameworkToExecutorMessage::Swap(FrameworkToExecutorMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkToExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkToExecutorMessage_descriptor_;
  metadata.reflection = FrameworkToExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterFrameworkMessage::kFrameworkFieldNumber;
#endif  // !_MSC_VER

RegisterFrameworkMessage::RegisterFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RegisterFrameworkMessage::InitAsDefaultInstance() {
  framework_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

RegisterFrameworkMessage::RegisterFrameworkMessage(const RegisterFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterFrameworkMessage::~RegisterFrameworkMessage() {
  SharedDtor();
}

void RegisterFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_;
  }
}

void RegisterFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterFrameworkMessage_descriptor_;
}

const RegisterFrameworkMessage& RegisterFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

RegisterFrameworkMessage* RegisterFrameworkMessage::default_instance_ = NULL;

RegisterFrameworkMessage* RegisterFrameworkMessage::New() const {
  return new RegisterFrameworkMessage;
}

void RegisterFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework()) {
      if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkInfo framework = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkInfo framework = 1;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RegisterFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkInfo framework = 1;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RegisterFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkInfo framework = 1;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterFrameworkMessage::MergeFrom(const RegisterFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework()) {
      mutable_framework()->::mesos::FrameworkInfo::MergeFrom(from.framework());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterFrameworkMessage::CopyFrom(const RegisterFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework()) {
    if (!this->framework().IsInitialized()) return false;
  }
  return true;
}

void RegisterFrameworkMessage::Swap(RegisterFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_, other->framework_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterFrameworkMessage_descriptor_;
  metadata.reflection = RegisterFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReregisterFrameworkMessage::kFrameworkFieldNumber;
const int ReregisterFrameworkMessage::kFailoverFieldNumber;
#endif  // !_MSC_VER

ReregisterFrameworkMessage::ReregisterFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReregisterFrameworkMessage::InitAsDefaultInstance() {
  framework_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

ReregisterFrameworkMessage::ReregisterFrameworkMessage(const ReregisterFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReregisterFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_ = NULL;
  failover_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReregisterFrameworkMessage::~ReregisterFrameworkMessage() {
  SharedDtor();
}

void ReregisterFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_;
  }
}

void ReregisterFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReregisterFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReregisterFrameworkMessage_descriptor_;
}

const ReregisterFrameworkMessage& ReregisterFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ReregisterFrameworkMessage* ReregisterFrameworkMessage::default_instance_ = NULL;

ReregisterFrameworkMessage* ReregisterFrameworkMessage::New() const {
  return new ReregisterFrameworkMessage;
}

void ReregisterFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework()) {
      if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
    }
    failover_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReregisterFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkInfo framework = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_failover;
        break;
      }

      // required bool failover = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_failover:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &failover_)));
          set_has_failover();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReregisterFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkInfo framework = 2;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework(), output);
  }

  // required bool failover = 3;
  if (has_failover()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->failover(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReregisterFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkInfo framework = 2;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework(), target);
  }

  // required bool failover = 3;
  if (has_failover()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->failover(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReregisterFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkInfo framework = 2;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework());
    }

    // required bool failover = 3;
    if (has_failover()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReregisterFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReregisterFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReregisterFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReregisterFrameworkMessage::MergeFrom(const ReregisterFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework()) {
      mutable_framework()->::mesos::FrameworkInfo::MergeFrom(from.framework());
    }
    if (from.has_failover()) {
      set_failover(from.failover());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReregisterFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReregisterFrameworkMessage::CopyFrom(const ReregisterFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReregisterFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework()) {
    if (!this->framework().IsInitialized()) return false;
  }
  return true;
}

void ReregisterFrameworkMessage::Swap(ReregisterFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_, other->framework_);
    std::swap(failover_, other->failover_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReregisterFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReregisterFrameworkMessage_descriptor_;
  metadata.reflection = ReregisterFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkRegisteredMessage::kFrameworkIdFieldNumber;
const int FrameworkRegisteredMessage::kMasterInfoFieldNumber;
#endif  // !_MSC_VER

FrameworkRegisteredMessage::FrameworkRegisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FrameworkRegisteredMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  master_info_ = const_cast< ::mesos::MasterInfo*>(&::mesos::MasterInfo::default_instance());
}

FrameworkRegisteredMessage::FrameworkRegisteredMessage(const FrameworkRegisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FrameworkRegisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  master_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkRegisteredMessage::~FrameworkRegisteredMessage() {
  SharedDtor();
}

void FrameworkRegisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete master_info_;
  }
}

void FrameworkRegisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkRegisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkRegisteredMessage_descriptor_;
}

const FrameworkRegisteredMessage& FrameworkRegisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

FrameworkRegisteredMessage* FrameworkRegisteredMessage::default_instance_ = NULL;

FrameworkRegisteredMessage* FrameworkRegisteredMessage::New() const {
  return new FrameworkRegisteredMessage;
}

void FrameworkRegisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_master_info()) {
      if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkRegisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_master_info;
        break;
      }

      // required .mesos.MasterInfo master_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_master_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameworkRegisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.MasterInfo master_info = 2;
  if (has_master_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->master_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FrameworkRegisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.MasterInfo master_info = 2;
  if (has_master_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->master_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FrameworkRegisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.MasterInfo master_info = 2;
    if (has_master_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkRegisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkRegisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkRegisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkRegisteredMessage::MergeFrom(const FrameworkRegisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_master_info()) {
      mutable_master_info()->::mesos::MasterInfo::MergeFrom(from.master_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkRegisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkRegisteredMessage::CopyFrom(const FrameworkRegisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkRegisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_master_info()) {
    if (!this->master_info().IsInitialized()) return false;
  }
  return true;
}

void FrameworkRegisteredMessage::Swap(FrameworkRegisteredMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(master_info_, other->master_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkRegisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkRegisteredMessage_descriptor_;
  metadata.reflection = FrameworkRegisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkReregisteredMessage::kFrameworkIdFieldNumber;
const int FrameworkReregisteredMessage::kMasterInfoFieldNumber;
#endif  // !_MSC_VER

FrameworkReregisteredMessage::FrameworkReregisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FrameworkReregisteredMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  master_info_ = const_cast< ::mesos::MasterInfo*>(&::mesos::MasterInfo::default_instance());
}

FrameworkReregisteredMessage::FrameworkReregisteredMessage(const FrameworkReregisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FrameworkReregisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  master_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkReregisteredMessage::~FrameworkReregisteredMessage() {
  SharedDtor();
}

void FrameworkReregisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete master_info_;
  }
}

void FrameworkReregisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkReregisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkReregisteredMessage_descriptor_;
}

const FrameworkReregisteredMessage& FrameworkReregisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

FrameworkReregisteredMessage* FrameworkReregisteredMessage::default_instance_ = NULL;

FrameworkReregisteredMessage* FrameworkReregisteredMessage::New() const {
  return new FrameworkReregisteredMessage;
}

void FrameworkReregisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_master_info()) {
      if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkReregisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_master_info;
        break;
      }

      // required .mesos.MasterInfo master_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_master_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameworkReregisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.MasterInfo master_info = 2;
  if (has_master_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->master_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FrameworkReregisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.MasterInfo master_info = 2;
  if (has_master_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->master_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FrameworkReregisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.MasterInfo master_info = 2;
    if (has_master_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkReregisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkReregisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkReregisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkReregisteredMessage::MergeFrom(const FrameworkReregisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_master_info()) {
      mutable_master_info()->::mesos::MasterInfo::MergeFrom(from.master_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkReregisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkReregisteredMessage::CopyFrom(const FrameworkReregisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkReregisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_master_info()) {
    if (!this->master_info().IsInitialized()) return false;
  }
  return true;
}

void FrameworkReregisteredMessage::Swap(FrameworkReregisteredMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(master_info_, other->master_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkReregisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkReregisteredMessage_descriptor_;
  metadata.reflection = FrameworkReregisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UnregisterFrameworkMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

UnregisterFrameworkMessage::UnregisterFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UnregisterFrameworkMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

UnregisterFrameworkMessage::UnregisterFrameworkMessage(const UnregisterFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UnregisterFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterFrameworkMessage::~UnregisterFrameworkMessage() {
  SharedDtor();
}

void UnregisterFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void UnregisterFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnregisterFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnregisterFrameworkMessage_descriptor_;
}

const UnregisterFrameworkMessage& UnregisterFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

UnregisterFrameworkMessage* UnregisterFrameworkMessage::default_instance_ = NULL;

UnregisterFrameworkMessage* UnregisterFrameworkMessage::New() const {
  return new UnregisterFrameworkMessage;
}

void UnregisterFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnregisterFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UnregisterFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UnregisterFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UnregisterFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnregisterFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnregisterFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnregisterFrameworkMessage::MergeFrom(const UnregisterFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnregisterFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnregisterFrameworkMessage::CopyFrom(const UnregisterFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void UnregisterFrameworkMessage::Swap(UnregisterFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnregisterFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnregisterFrameworkMessage_descriptor_;
  metadata.reflection = UnregisterFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeactivateFrameworkMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

DeactivateFrameworkMessage::DeactivateFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DeactivateFrameworkMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

DeactivateFrameworkMessage::DeactivateFrameworkMessage(const DeactivateFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DeactivateFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeactivateFrameworkMessage::~DeactivateFrameworkMessage() {
  SharedDtor();
}

void DeactivateFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void DeactivateFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeactivateFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeactivateFrameworkMessage_descriptor_;
}

const DeactivateFrameworkMessage& DeactivateFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

DeactivateFrameworkMessage* DeactivateFrameworkMessage::default_instance_ = NULL;

DeactivateFrameworkMessage* DeactivateFrameworkMessage::New() const {
  return new DeactivateFrameworkMessage;
}

void DeactivateFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeactivateFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DeactivateFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DeactivateFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DeactivateFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeactivateFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeactivateFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeactivateFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeactivateFrameworkMessage::MergeFrom(const DeactivateFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeactivateFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeactivateFrameworkMessage::CopyFrom(const DeactivateFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeactivateFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void DeactivateFrameworkMessage::Swap(DeactivateFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeactivateFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeactivateFrameworkMessage_descriptor_;
  metadata.reflection = DeactivateFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceRequestMessage::kFrameworkIdFieldNumber;
const int ResourceRequestMessage::kRequestsFieldNumber;
#endif  // !_MSC_VER

ResourceRequestMessage::ResourceRequestMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResourceRequestMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ResourceRequestMessage::ResourceRequestMessage(const ResourceRequestMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResourceRequestMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceRequestMessage::~ResourceRequestMessage() {
  SharedDtor();
}

void ResourceRequestMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void ResourceRequestMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceRequestMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceRequestMessage_descriptor_;
}

const ResourceRequestMessage& ResourceRequestMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ResourceRequestMessage* ResourceRequestMessage::default_instance_ = NULL;

ResourceRequestMessage* ResourceRequestMessage::New() const {
  return new ResourceRequestMessage;
}

void ResourceRequestMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  requests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceRequestMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_requests;
        break;
      }

      // repeated .mesos.Request requests = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_requests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_requests()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_requests;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResourceRequestMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // repeated .mesos.Request requests = 2;
  for (int i = 0; i < this->requests_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->requests(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResourceRequestMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // repeated .mesos.Request requests = 2;
  for (int i = 0; i < this->requests_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->requests(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResourceRequestMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  // repeated .mesos.Request requests = 2;
  total_size += 1 * this->requests_size();
  for (int i = 0; i < this->requests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->requests(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceRequestMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceRequestMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceRequestMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceRequestMessage::MergeFrom(const ResourceRequestMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  requests_.MergeFrom(from.requests_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceRequestMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceRequestMessage::CopyFrom(const ResourceRequestMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceRequestMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  for (int i = 0; i < requests_size(); i++) {
    if (!this->requests(i).IsInitialized()) return false;
  }
  return true;
}

void ResourceRequestMessage::Swap(ResourceRequestMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    requests_.Swap(&other->requests_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceRequestMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceRequestMessage_descriptor_;
  metadata.reflection = ResourceRequestMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceOffersMessage::kOffersFieldNumber;
const int ResourceOffersMessage::kPidsFieldNumber;
const int ResourceOffersMessage::kInverseOffersFieldNumber;
#endif  // !_MSC_VER

ResourceOffersMessage::ResourceOffersMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResourceOffersMessage::InitAsDefaultInstance() {
}

ResourceOffersMessage::ResourceOffersMessage(const ResourceOffersMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResourceOffersMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceOffersMessage::~ResourceOffersMessage() {
  SharedDtor();
}

void ResourceOffersMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResourceOffersMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceOffersMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceOffersMessage_descriptor_;
}

const ResourceOffersMessage& ResourceOffersMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ResourceOffersMessage* ResourceOffersMessage::default_instance_ = NULL;

ResourceOffersMessage* ResourceOffersMessage::New() const {
  return new ResourceOffersMessage;
}

void ResourceOffersMessage::Clear() {
  offers_.Clear();
  pids_.Clear();
  inverse_offers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceOffersMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Offer offers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_offers;
        if (input->ExpectTag(18)) goto parse_pids;
        break;
      }

      // repeated string pids = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_pids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pids(this->pids_size() - 1).data(),
            this->pids(this->pids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pids;
        if (input->ExpectTag(26)) goto parse_inverse_offers;
        break;
      }

      // repeated .mesos.InverseOffer inverse_offers = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inverse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inverse_offers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_inverse_offers;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResourceOffersMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.Offer offers = 1;
  for (int i = 0; i < this->offers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offers(i), output);
  }

  // repeated string pids = 2;
  for (int i = 0; i < this->pids_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->pids(i).data(), this->pids(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pids(i), output);
  }

  // repeated .mesos.InverseOffer inverse_offers = 3;
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->inverse_offers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResourceOffersMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.Offer offers = 1;
  for (int i = 0; i < this->offers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offers(i), target);
  }

  // repeated string pids = 2;
  for (int i = 0; i < this->pids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pids(i).data(), this->pids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->pids(i), target);
  }

  // repeated .mesos.InverseOffer inverse_offers = 3;
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->inverse_offers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResourceOffersMessage::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Offer offers = 1;
  total_size += 1 * this->offers_size();
  for (int i = 0; i < this->offers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offers(i));
  }

  // repeated string pids = 2;
  total_size += 1 * this->pids_size();
  for (int i = 0; i < this->pids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->pids(i));
  }

  // repeated .mesos.InverseOffer inverse_offers = 3;
  total_size += 1 * this->inverse_offers_size();
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inverse_offers(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceOffersMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceOffersMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceOffersMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceOffersMessage::MergeFrom(const ResourceOffersMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  offers_.MergeFrom(from.offers_);
  pids_.MergeFrom(from.pids_);
  inverse_offers_.MergeFrom(from.inverse_offers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceOffersMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceOffersMessage::CopyFrom(const ResourceOffersMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceOffersMessage::IsInitialized() const {

  for (int i = 0; i < offers_size(); i++) {
    if (!this->offers(i).IsInitialized()) return false;
  }
  for (int i = 0; i < inverse_offers_size(); i++) {
    if (!this->inverse_offers(i).IsInitialized()) return false;
  }
  return true;
}

void ResourceOffersMessage::Swap(ResourceOffersMessage* other) {
  if (other != this) {
    offers_.Swap(&other->offers_);
    pids_.Swap(&other->pids_);
    inverse_offers_.Swap(&other->inverse_offers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceOffersMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceOffersMessage_descriptor_;
  metadata.reflection = ResourceOffersMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LaunchTasksMessage::kFrameworkIdFieldNumber;
const int LaunchTasksMessage::kTasksFieldNumber;
const int LaunchTasksMessage::kFiltersFieldNumber;
const int LaunchTasksMessage::kOfferIdsFieldNumber;
#endif  // !_MSC_VER

LaunchTasksMessage::LaunchTasksMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LaunchTasksMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  filters_ = const_cast< ::mesos::Filters*>(&::mesos::Filters::default_instance());
}

LaunchTasksMessage::LaunchTasksMessage(const LaunchTasksMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LaunchTasksMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  filters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaunchTasksMessage::~LaunchTasksMessage() {
  SharedDtor();
}

void LaunchTasksMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete filters_;
  }
}

void LaunchTasksMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaunchTasksMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaunchTasksMessage_descriptor_;
}

const LaunchTasksMessage& LaunchTasksMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

LaunchTasksMessage* LaunchTasksMessage::default_instance_ = NULL;

LaunchTasksMessage* LaunchTasksMessage::New() const {
  return new LaunchTasksMessage;
}

void LaunchTasksMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_filters()) {
      if (filters_ != NULL) filters_->::mesos::Filters::Clear();
    }
  }
  tasks_.Clear();
  offer_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LaunchTasksMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        break;
      }

      // repeated .mesos.TaskInfo tasks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        if (input->ExpectTag(42)) goto parse_filters;
        break;
      }

      // required .mesos.Filters filters = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_offer_ids;
        break;
      }

      // repeated .mesos.OfferID offer_ids = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offer_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offer_ids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_offer_ids;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LaunchTasksMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // repeated .mesos.TaskInfo tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tasks(i), output);
  }

  // required .mesos.Filters filters = 5;
  if (has_filters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->filters(), output);
  }

  // repeated .mesos.OfferID offer_ids = 6;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->offer_ids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LaunchTasksMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // repeated .mesos.TaskInfo tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tasks(i), target);
  }

  // required .mesos.Filters filters = 5;
  if (has_filters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->filters(), target);
  }

  // repeated .mesos.OfferID offer_ids = 6;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->offer_ids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LaunchTasksMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.Filters filters = 5;
    if (has_filters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filters());
    }

  }
  // repeated .mesos.TaskInfo tasks = 3;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  // repeated .mesos.OfferID offer_ids = 6;
  total_size += 1 * this->offer_ids_size();
  for (int i = 0; i < this->offer_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offer_ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaunchTasksMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LaunchTasksMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LaunchTasksMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LaunchTasksMessage::MergeFrom(const LaunchTasksMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  offer_ids_.MergeFrom(from.offer_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_filters()) {
      mutable_filters()->::mesos::Filters::MergeFrom(from.filters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LaunchTasksMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaunchTasksMessage::CopyFrom(const LaunchTasksMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaunchTasksMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  for (int i = 0; i < tasks_size(); i++) {
    if (!this->tasks(i).IsInitialized()) return false;
  }
  for (int i = 0; i < offer_ids_size(); i++) {
    if (!this->offer_ids(i).IsInitialized()) return false;
  }
  return true;
}

void LaunchTasksMessage::Swap(LaunchTasksMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    tasks_.Swap(&other->tasks_);
    std::swap(filters_, other->filters_);
    offer_ids_.Swap(&other->offer_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LaunchTasksMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaunchTasksMessage_descriptor_;
  metadata.reflection = LaunchTasksMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RescindResourceOfferMessage::kOfferIdFieldNumber;
#endif  // !_MSC_VER

RescindResourceOfferMessage::RescindResourceOfferMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RescindResourceOfferMessage::InitAsDefaultInstance() {
  offer_id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
}

RescindResourceOfferMessage::RescindResourceOfferMessage(const RescindResourceOfferMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RescindResourceOfferMessage::SharedCtor() {
  _cached_size_ = 0;
  offer_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RescindResourceOfferMessage::~RescindResourceOfferMessage() {
  SharedDtor();
}

void RescindResourceOfferMessage::SharedDtor() {
  if (this != default_instance_) {
    delete offer_id_;
  }
}

void RescindResourceOfferMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RescindResourceOfferMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RescindResourceOfferMessage_descriptor_;
}

const RescindResourceOfferMessage& RescindResourceOfferMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

RescindResourceOfferMessage* RescindResourceOfferMessage::default_instance_ = NULL;

RescindResourceOfferMessage* RescindResourceOfferMessage::New() const {
  return new RescindResourceOfferMessage;
}

void RescindResourceOfferMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_offer_id()) {
      if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RescindResourceOfferMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID offer_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RescindResourceOfferMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.OfferID offer_id = 1;
  if (has_offer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offer_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RescindResourceOfferMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.OfferID offer_id = 1;
  if (has_offer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offer_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RescindResourceOfferMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.OfferID offer_id = 1;
    if (has_offer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->offer_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RescindResourceOfferMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RescindResourceOfferMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RescindResourceOfferMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RescindResourceOfferMessage::MergeFrom(const RescindResourceOfferMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offer_id()) {
      mutable_offer_id()->::mesos::OfferID::MergeFrom(from.offer_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RescindResourceOfferMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RescindResourceOfferMessage::CopyFrom(const RescindResourceOfferMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RescindResourceOfferMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_offer_id()) {
    if (!this->offer_id().IsInitialized()) return false;
  }
  return true;
}

void RescindResourceOfferMessage::Swap(RescindResourceOfferMessage* other) {
  if (other != this) {
    std::swap(offer_id_, other->offer_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RescindResourceOfferMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RescindResourceOfferMessage_descriptor_;
  metadata.reflection = RescindResourceOfferMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReviveOffersMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

ReviveOffersMessage::ReviveOffersMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReviveOffersMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ReviveOffersMessage::ReviveOffersMessage(const ReviveOffersMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReviveOffersMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReviveOffersMessage::~ReviveOffersMessage() {
  SharedDtor();
}

void ReviveOffersMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void ReviveOffersMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReviveOffersMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReviveOffersMessage_descriptor_;
}

const ReviveOffersMessage& ReviveOffersMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ReviveOffersMessage* ReviveOffersMessage::default_instance_ = NULL;

ReviveOffersMessage* ReviveOffersMessage::New() const {
  return new ReviveOffersMessage;
}

void ReviveOffersMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReviveOffersMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReviveOffersMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReviveOffersMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReviveOffersMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReviveOffersMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReviveOffersMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReviveOffersMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReviveOffersMessage::MergeFrom(const ReviveOffersMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReviveOffersMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReviveOffersMessage::CopyFrom(const ReviveOffersMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReviveOffersMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void ReviveOffersMessage::Swap(ReviveOffersMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReviveOffersMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReviveOffersMessage_descriptor_;
  metadata.reflection = ReviveOffersMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RunTaskMessage::kFrameworkIdFieldNumber;
const int RunTaskMessage::kFrameworkFieldNumber;
const int RunTaskMessage::kTaskFieldNumber;
const int RunTaskMessage::kPidFieldNumber;
#endif  // !_MSC_VER

RunTaskMessage::RunTaskMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RunTaskMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  framework_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
  task_ = const_cast< ::mesos::TaskInfo*>(&::mesos::TaskInfo::default_instance());
}

RunTaskMessage::RunTaskMessage(const RunTaskMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RunTaskMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  framework_ = NULL;
  task_ = NULL;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RunTaskMessage::~RunTaskMessage() {
  SharedDtor();
}

void RunTaskMessage::SharedDtor() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (this != default_instance_) {
    delete framework_id_;
    delete framework_;
    delete task_;
  }
}

void RunTaskMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RunTaskMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RunTaskMessage_descriptor_;
}

const RunTaskMessage& RunTaskMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

RunTaskMessage* RunTaskMessage::default_instance_ = NULL;

RunTaskMessage* RunTaskMessage::New() const {
  return new RunTaskMessage;
}

void RunTaskMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_framework()) {
      if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
    }
    if (has_task()) {
      if (task_ != NULL) task_->::mesos::TaskInfo::Clear();
    }
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::kEmptyString) {
        pid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RunTaskMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_framework;
        break;
      }

      // required .mesos.FrameworkInfo framework = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pid;
        break;
      }

      // optional string pid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_task;
        break;
      }

      // required .mesos.TaskInfo task = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RunTaskMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.FrameworkInfo framework = 2;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework(), output);
  }

  // optional string pid = 3;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->pid(), output);
  }

  // required .mesos.TaskInfo task = 4;
  if (has_task()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->task(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RunTaskMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.FrameworkInfo framework = 2;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework(), target);
  }

  // optional string pid = 3;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->pid(), target);
  }

  // required .mesos.TaskInfo task = 4;
  if (has_task()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->task(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RunTaskMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.FrameworkInfo framework = 2;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework());
    }

    // required .mesos.TaskInfo task = 4;
    if (has_task()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task());
    }

    // optional string pid = 3;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RunTaskMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RunTaskMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RunTaskMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RunTaskMessage::MergeFrom(const RunTaskMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_framework()) {
      mutable_framework()->::mesos::FrameworkInfo::MergeFrom(from.framework());
    }
    if (from.has_task()) {
      mutable_task()->::mesos::TaskInfo::MergeFrom(from.task());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RunTaskMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RunTaskMessage::CopyFrom(const RunTaskMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RunTaskMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_framework()) {
    if (!this->framework().IsInitialized()) return false;
  }
  if (has_task()) {
    if (!this->task().IsInitialized()) return false;
  }
  return true;
}

void RunTaskMessage::Swap(RunTaskMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(framework_, other->framework_);
    std::swap(task_, other->task_);
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RunTaskMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RunTaskMessage_descriptor_;
  metadata.reflection = RunTaskMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KillTaskMessage::kFrameworkIdFieldNumber;
const int KillTaskMessage::kTaskIdFieldNumber;
#endif  // !_MSC_VER

KillTaskMessage::KillTaskMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KillTaskMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
}

KillTaskMessage::KillTaskMessage(const KillTaskMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KillTaskMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  task_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KillTaskMessage::~KillTaskMessage() {
  SharedDtor();
}

void KillTaskMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete task_id_;
  }
}

void KillTaskMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KillTaskMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KillTaskMessage_descriptor_;
}

const KillTaskMessage& KillTaskMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

KillTaskMessage* KillTaskMessage::default_instance_ = NULL;

KillTaskMessage* KillTaskMessage::New() const {
  return new KillTaskMessage;
}

void KillTaskMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KillTaskMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KillTaskMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KillTaskMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KillTaskMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.TaskID task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KillTaskMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KillTaskMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KillTaskMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KillTaskMessage::MergeFrom(const KillTaskMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KillTaskMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KillTaskMessage::CopyFrom(const KillTaskMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KillTaskMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  return true;
}

void KillTaskMessage::Swap(KillTaskMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KillTaskMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KillTaskMessage_descriptor_;
  metadata.reflection = KillTaskMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StatusUpdateMessage::kUpdateFieldNumber;
const int StatusUpdateMessage::kPidFieldNumber;
#endif  // !_MSC_VER

StatusUpdateMessage::StatusUpdateMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StatusUpdateMessage::InitAsDefaultInstance() {
  update_ = const_cast< ::mesos::internal::StatusUpdate*>(&::mesos::internal::StatusUpdate::default_instance());
}

StatusUpdateMessage::StatusUpdateMessage(const StatusUpdateMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StatusUpdateMessage::SharedCtor() {
  _cached_size_ = 0;
  update_ = NULL;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusUpdateMessage::~StatusUpdateMessage() {
  SharedDtor();
}

void StatusUpdateMessage::SharedDtor() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (this != default_instance_) {
    delete update_;
  }
}

void StatusUpdateMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StatusUpdateMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdateMessage_descriptor_;
}

const StatusUpdateMessage& StatusUpdateMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

StatusUpdateMessage* StatusUpdateMessage::default_instance_ = NULL;

StatusUpdateMessage* StatusUpdateMessage::New() const {
  return new StatusUpdateMessage;
}

void StatusUpdateMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_update()) {
      if (update_ != NULL) update_->::mesos::internal::StatusUpdate::Clear();
    }
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::kEmptyString) {
        pid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StatusUpdateMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.internal.StatusUpdate update = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_update()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pid;
        break;
      }

      // optional string pid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StatusUpdateMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.internal.StatusUpdate update = 1;
  if (has_update()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->update(), output);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StatusUpdateMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.internal.StatusUpdate update = 1;
  if (has_update()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->update(), target);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StatusUpdateMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.internal.StatusUpdate update = 1;
    if (has_update()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->update());
    }

    // optional string pid = 2;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusUpdateMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StatusUpdateMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StatusUpdateMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StatusUpdateMessage::MergeFrom(const StatusUpdateMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_update()) {
      mutable_update()->::mesos::internal::StatusUpdate::MergeFrom(from.update());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StatusUpdateMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusUpdateMessage::CopyFrom(const StatusUpdateMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusUpdateMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_update()) {
    if (!this->update().IsInitialized()) return false;
  }
  return true;
}

void StatusUpdateMessage::Swap(StatusUpdateMessage* other) {
  if (other != this) {
    std::swap(update_, other->update_);
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StatusUpdateMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StatusUpdateMessage_descriptor_;
  metadata.reflection = StatusUpdateMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StatusUpdateAcknowledgementMessage::kSlaveIdFieldNumber;
const int StatusUpdateAcknowledgementMessage::kFrameworkIdFieldNumber;
const int StatusUpdateAcknowledgementMessage::kTaskIdFieldNumber;
const int StatusUpdateAcknowledgementMessage::kUuidFieldNumber;
#endif  // !_MSC_VER

StatusUpdateAcknowledgementMessage::StatusUpdateAcknowledgementMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StatusUpdateAcknowledgementMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
}

StatusUpdateAcknowledgementMessage::StatusUpdateAcknowledgementMessage(const StatusUpdateAcknowledgementMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StatusUpdateAcknowledgementMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  framework_id_ = NULL;
  task_id_ = NULL;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusUpdateAcknowledgementMessage::~StatusUpdateAcknowledgementMessage() {
  SharedDtor();
}

void StatusUpdateAcknowledgementMessage::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete framework_id_;
    delete task_id_;
  }
}

void StatusUpdateAcknowledgementMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StatusUpdateAcknowledgementMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdateAcknowledgementMessage_descriptor_;
}

const StatusUpdateAcknowledgementMessage& StatusUpdateAcknowledgementMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

StatusUpdateAcknowledgementMessage* StatusUpdateAcknowledgementMessage::default_instance_ = NULL;

StatusUpdateAcknowledgementMessage* StatusUpdateAcknowledgementMessage::New() const {
  return new StatusUpdateAcknowledgementMessage;
}

void StatusUpdateAcknowledgementMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StatusUpdateAcknowledgementMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_uuid;
        break;
      }

      // required bytes uuid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StatusUpdateAcknowledgementMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.TaskID task_id = 3;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->task_id(), output);
  }

  // required bytes uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StatusUpdateAcknowledgementMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.TaskID task_id = 3;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->task_id(), target);
  }

  // required bytes uuid = 4;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StatusUpdateAcknowledgementMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.TaskID task_id = 3;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required bytes uuid = 4;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusUpdateAcknowledgementMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StatusUpdateAcknowledgementMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StatusUpdateAcknowledgementMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StatusUpdateAcknowledgementMessage::MergeFrom(const StatusUpdateAcknowledgementMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StatusUpdateAcknowledgementMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusUpdateAcknowledgementMessage::CopyFrom(const StatusUpdateAcknowledgementMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusUpdateAcknowledgementMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  return true;
}

void StatusUpdateAcknowledgementMessage::Swap(StatusUpdateAcknowledgementMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StatusUpdateAcknowledgementMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StatusUpdateAcknowledgementMessage_descriptor_;
  metadata.reflection = StatusUpdateAcknowledgementMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LostSlaveMessage::kSlaveIdFieldNumber;
#endif  // !_MSC_VER

LostSlaveMessage::LostSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LostSlaveMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

LostSlaveMessage::LostSlaveMessage(const LostSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LostSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LostSlaveMessage::~LostSlaveMessage() {
  SharedDtor();
}

void LostSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void LostSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LostSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LostSlaveMessage_descriptor_;
}

const LostSlaveMessage& LostSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

LostSlaveMessage* LostSlaveMessage::default_instance_ = NULL;

LostSlaveMessage* LostSlaveMessage::New() const {
  return new LostSlaveMessage;
}

void LostSlaveMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LostSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LostSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LostSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LostSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LostSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LostSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LostSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LostSlaveMessage::MergeFrom(const LostSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LostSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LostSlaveMessage::CopyFrom(const LostSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LostSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void LostSlaveMessage::Swap(LostSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LostSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LostSlaveMessage_descriptor_;
  metadata.reflection = LostSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReconcileTasksMessage::kFrameworkIdFieldNumber;
const int ReconcileTasksMessage::kStatusesFieldNumber;
#endif  // !_MSC_VER

ReconcileTasksMessage::ReconcileTasksMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReconcileTasksMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ReconcileTasksMessage::ReconcileTasksMessage(const ReconcileTasksMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReconcileTasksMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReconcileTasksMessage::~ReconcileTasksMessage() {
  SharedDtor();
}

void ReconcileTasksMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void ReconcileTasksMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReconcileTasksMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconcileTasksMessage_descriptor_;
}

const ReconcileTasksMessage& ReconcileTasksMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ReconcileTasksMessage* ReconcileTasksMessage::default_instance_ = NULL;

ReconcileTasksMessage* ReconcileTasksMessage::New() const {
  return new ReconcileTasksMessage;
}

void ReconcileTasksMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  statuses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReconcileTasksMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_statuses;
        break;
      }

      // repeated .mesos.TaskStatus statuses = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_statuses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_statuses()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_statuses;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReconcileTasksMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // repeated .mesos.TaskStatus statuses = 2;
  for (int i = 0; i < this->statuses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->statuses(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReconcileTasksMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // repeated .mesos.TaskStatus statuses = 2;
  for (int i = 0; i < this->statuses_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->statuses(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReconcileTasksMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  // repeated .mesos.TaskStatus statuses = 2;
  total_size += 1 * this->statuses_size();
  for (int i = 0; i < this->statuses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->statuses(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReconcileTasksMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReconcileTasksMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReconcileTasksMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReconcileTasksMessage::MergeFrom(const ReconcileTasksMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  statuses_.MergeFrom(from.statuses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReconcileTasksMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReconcileTasksMessage::CopyFrom(const ReconcileTasksMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReconcileTasksMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  for (int i = 0; i < statuses_size(); i++) {
    if (!this->statuses(i).IsInitialized()) return false;
  }
  return true;
}

void ReconcileTasksMessage::Swap(ReconcileTasksMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    statuses_.Swap(&other->statuses_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReconcileTasksMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReconcileTasksMessage_descriptor_;
  metadata.reflection = ReconcileTasksMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkErrorMessage::kMessageFieldNumber;
#endif  // !_MSC_VER

FrameworkErrorMessage::FrameworkErrorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FrameworkErrorMessage::InitAsDefaultInstance() {
}

FrameworkErrorMessage::FrameworkErrorMessage(const FrameworkErrorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FrameworkErrorMessage::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkErrorMessage::~FrameworkErrorMessage() {
  SharedDtor();
}

void FrameworkErrorMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void FrameworkErrorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkErrorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkErrorMessage_descriptor_;
}

const FrameworkErrorMessage& FrameworkErrorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

FrameworkErrorMessage* FrameworkErrorMessage::default_instance_ = NULL;

FrameworkErrorMessage* FrameworkErrorMessage::New() const {
  return new FrameworkErrorMessage;
}

void FrameworkErrorMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkErrorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameworkErrorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FrameworkErrorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FrameworkErrorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkErrorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkErrorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkErrorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkErrorMessage::MergeFrom(const FrameworkErrorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkErrorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkErrorMessage::CopyFrom(const FrameworkErrorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkErrorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FrameworkErrorMessage::Swap(FrameworkErrorMessage* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkErrorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkErrorMessage_descriptor_;
  metadata.reflection = FrameworkErrorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterSlaveMessage::kSlaveFieldNumber;
const int RegisterSlaveMessage::kCheckpointedResourcesFieldNumber;
const int RegisterSlaveMessage::kVersionFieldNumber;
#endif  // !_MSC_VER

RegisterSlaveMessage::RegisterSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RegisterSlaveMessage::InitAsDefaultInstance() {
  slave_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

RegisterSlaveMessage::RegisterSlaveMessage(const RegisterSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_ = NULL;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterSlaveMessage::~RegisterSlaveMessage() {
  SharedDtor();
}

void RegisterSlaveMessage::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
    delete slave_;
  }
}

void RegisterSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterSlaveMessage_descriptor_;
}

const RegisterSlaveMessage& RegisterSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

RegisterSlaveMessage* RegisterSlaveMessage::default_instance_ = NULL;

RegisterSlaveMessage* RegisterSlaveMessage::New() const {
  return new RegisterSlaveMessage;
}

void RegisterSlaveMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave()) {
      if (slave_ != NULL) slave_->::mesos::SlaveInfo::Clear();
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  checkpointed_resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveInfo slave = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_version;
        break;
      }

      // optional string version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_checkpointed_resources;
        break;
      }

      // repeated .mesos.Resource checkpointed_resources = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_checkpointed_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_checkpointed_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_checkpointed_resources;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveInfo slave = 1;
  if (has_slave()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave(), output);
  }

  // optional string version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->version(), output);
  }

  // repeated .mesos.Resource checkpointed_resources = 3;
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->checkpointed_resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RegisterSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveInfo slave = 1;
  if (has_slave()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave(), target);
  }

  // optional string version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->version(), target);
  }

  // repeated .mesos.Resource checkpointed_resources = 3;
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->checkpointed_resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RegisterSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveInfo slave = 1;
    if (has_slave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave());
    }

    // optional string version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  // repeated .mesos.Resource checkpointed_resources = 3;
  total_size += 1 * this->checkpointed_resources_size();
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->checkpointed_resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterSlaveMessage::MergeFrom(const RegisterSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  checkpointed_resources_.MergeFrom(from.checkpointed_resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave()) {
      mutable_slave()->::mesos::SlaveInfo::MergeFrom(from.slave());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterSlaveMessage::CopyFrom(const RegisterSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave()) {
    if (!this->slave().IsInitialized()) return false;
  }
  for (int i = 0; i < checkpointed_resources_size(); i++) {
    if (!this->checkpointed_resources(i).IsInitialized()) return false;
  }
  return true;
}

void RegisterSlaveMessage::Swap(RegisterSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_, other->slave_);
    checkpointed_resources_.Swap(&other->checkpointed_resources_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterSlaveMessage_descriptor_;
  metadata.reflection = RegisterSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReregisterSlaveMessage::kSlaveFieldNumber;
const int ReregisterSlaveMessage::kCheckpointedResourcesFieldNumber;
const int ReregisterSlaveMessage::kExecutorInfosFieldNumber;
const int ReregisterSlaveMessage::kTasksFieldNumber;
const int ReregisterSlaveMessage::kCompletedFrameworksFieldNumber;
const int ReregisterSlaveMessage::kVersionFieldNumber;
#endif  // !_MSC_VER

ReregisterSlaveMessage::ReregisterSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReregisterSlaveMessage::InitAsDefaultInstance() {
  slave_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

ReregisterSlaveMessage::ReregisterSlaveMessage(const ReregisterSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReregisterSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_ = NULL;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReregisterSlaveMessage::~ReregisterSlaveMessage() {
  SharedDtor();
}

void ReregisterSlaveMessage::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
    delete slave_;
  }
}

void ReregisterSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReregisterSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReregisterSlaveMessage_descriptor_;
}

const ReregisterSlaveMessage& ReregisterSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ReregisterSlaveMessage* ReregisterSlaveMessage::default_instance_ = NULL;

ReregisterSlaveMessage* ReregisterSlaveMessage::New() const {
  return new ReregisterSlaveMessage;
}

void ReregisterSlaveMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave()) {
      if (slave_ != NULL) slave_->::mesos::SlaveInfo::Clear();
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  checkpointed_resources_.Clear();
  executor_infos_.Clear();
  tasks_.Clear();
  completed_frameworks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReregisterSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveInfo slave = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        break;
      }

      // repeated .mesos.internal.Task tasks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        if (input->ExpectTag(34)) goto parse_executor_infos;
        break;
      }

      // repeated .mesos.ExecutorInfo executor_infos = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_executor_infos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_executor_infos;
        if (input->ExpectTag(42)) goto parse_completed_frameworks;
        break;
      }

      // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_completed_frameworks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_completed_frameworks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_completed_frameworks;
        if (input->ExpectTag(50)) goto parse_version;
        break;
      }

      // optional string version = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_checkpointed_resources;
        break;
      }

      // repeated .mesos.Resource checkpointed_resources = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_checkpointed_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_checkpointed_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_checkpointed_resources;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReregisterSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveInfo slave = 2;
  if (has_slave()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave(), output);
  }

  // repeated .mesos.internal.Task tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tasks(i), output);
  }

  // repeated .mesos.ExecutorInfo executor_infos = 4;
  for (int i = 0; i < this->executor_infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->executor_infos(i), output);
  }

  // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
  for (int i = 0; i < this->completed_frameworks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->completed_frameworks(i), output);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->version(), output);
  }

  // repeated .mesos.Resource checkpointed_resources = 7;
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->checkpointed_resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReregisterSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveInfo slave = 2;
  if (has_slave()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave(), target);
  }

  // repeated .mesos.internal.Task tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tasks(i), target);
  }

  // repeated .mesos.ExecutorInfo executor_infos = 4;
  for (int i = 0; i < this->executor_infos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->executor_infos(i), target);
  }

  // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
  for (int i = 0; i < this->completed_frameworks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->completed_frameworks(i), target);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->version(), target);
  }

  // repeated .mesos.Resource checkpointed_resources = 7;
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->checkpointed_resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReregisterSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveInfo slave = 2;
    if (has_slave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave());
    }

    // optional string version = 6;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  // repeated .mesos.Resource checkpointed_resources = 7;
  total_size += 1 * this->checkpointed_resources_size();
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->checkpointed_resources(i));
  }

  // repeated .mesos.ExecutorInfo executor_infos = 4;
  total_size += 1 * this->executor_infos_size();
  for (int i = 0; i < this->executor_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->executor_infos(i));
  }

  // repeated .mesos.internal.Task tasks = 3;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
  total_size += 1 * this->completed_frameworks_size();
  for (int i = 0; i < this->completed_frameworks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->completed_frameworks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReregisterSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReregisterSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReregisterSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReregisterSlaveMessage::MergeFrom(const ReregisterSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  checkpointed_resources_.MergeFrom(from.checkpointed_resources_);
  executor_infos_.MergeFrom(from.executor_infos_);
  tasks_.MergeFrom(from.tasks_);
  completed_frameworks_.MergeFrom(from.completed_frameworks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave()) {
      mutable_slave()->::mesos::SlaveInfo::MergeFrom(from.slave());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReregisterSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReregisterSlaveMessage::CopyFrom(const ReregisterSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReregisterSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave()) {
    if (!this->slave().IsInitialized()) return false;
  }
  for (int i = 0; i < checkpointed_resources_size(); i++) {
    if (!this->checkpointed_resources(i).IsInitialized()) return false;
  }
  for (int i = 0; i < executor_infos_size(); i++) {
    if (!this->executor_infos(i).IsInitialized()) return false;
  }
  for (int i = 0; i < tasks_size(); i++) {
    if (!this->tasks(i).IsInitialized()) return false;
  }
  for (int i = 0; i < completed_frameworks_size(); i++) {
    if (!this->completed_frameworks(i).IsInitialized()) return false;
  }
  return true;
}

void ReregisterSlaveMessage::Swap(ReregisterSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_, other->slave_);
    checkpointed_resources_.Swap(&other->checkpointed_resources_);
    executor_infos_.Swap(&other->executor_infos_);
    tasks_.Swap(&other->tasks_);
    completed_frameworks_.Swap(&other->completed_frameworks_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReregisterSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReregisterSlaveMessage_descriptor_;
  metadata.reflection = ReregisterSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveRegisteredMessage::kSlaveIdFieldNumber;
const int SlaveRegisteredMessage::kConnectionFieldNumber;
#endif  // !_MSC_VER

SlaveRegisteredMessage::SlaveRegisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveRegisteredMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  connection_ = const_cast< ::mesos::internal::MasterSlaveConnection*>(&::mesos::internal::MasterSlaveConnection::default_instance());
}

SlaveRegisteredMessage::SlaveRegisteredMessage(const SlaveRegisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveRegisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  connection_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveRegisteredMessage::~SlaveRegisteredMessage() {
  SharedDtor();
}

void SlaveRegisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete connection_;
  }
}

void SlaveRegisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveRegisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveRegisteredMessage_descriptor_;
}

const SlaveRegisteredMessage& SlaveRegisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

SlaveRegisteredMessage* SlaveRegisteredMessage::default_instance_ = NULL;

SlaveRegisteredMessage* SlaveRegisteredMessage::New() const {
  return new SlaveRegisteredMessage;
}

void SlaveRegisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_connection()) {
      if (connection_ != NULL) connection_->::mesos::internal::MasterSlaveConnection::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveRegisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_connection;
        break;
      }

      // optional .mesos.internal.MasterSlaveConnection connection = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_connection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_connection()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveRegisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // optional .mesos.internal.MasterSlaveConnection connection = 2;
  if (has_connection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->connection(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveRegisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // optional .mesos.internal.MasterSlaveConnection connection = 2;
  if (has_connection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->connection(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveRegisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.internal.MasterSlaveConnection connection = 2;
    if (has_connection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->connection());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveRegisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveRegisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveRegisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveRegisteredMessage::MergeFrom(const SlaveRegisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_connection()) {
      mutable_connection()->::mesos::internal::MasterSlaveConnection::MergeFrom(from.connection());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveRegisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveRegisteredMessage::CopyFrom(const SlaveRegisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveRegisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void SlaveRegisteredMessage::Swap(SlaveRegisteredMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(connection_, other->connection_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveRegisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveRegisteredMessage_descriptor_;
  metadata.reflection = SlaveRegisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveReregisteredMessage::kSlaveIdFieldNumber;
const int SlaveReregisteredMessage::kReconciliationsFieldNumber;
const int SlaveReregisteredMessage::kConnectionFieldNumber;
#endif  // !_MSC_VER

SlaveReregisteredMessage::SlaveReregisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveReregisteredMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  connection_ = const_cast< ::mesos::internal::MasterSlaveConnection*>(&::mesos::internal::MasterSlaveConnection::default_instance());
}

SlaveReregisteredMessage::SlaveReregisteredMessage(const SlaveReregisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveReregisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  connection_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveReregisteredMessage::~SlaveReregisteredMessage() {
  SharedDtor();
}

void SlaveReregisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete connection_;
  }
}

void SlaveReregisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveReregisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveReregisteredMessage_descriptor_;
}

const SlaveReregisteredMessage& SlaveReregisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

SlaveReregisteredMessage* SlaveReregisteredMessage::default_instance_ = NULL;

SlaveReregisteredMessage* SlaveReregisteredMessage::New() const {
  return new SlaveReregisteredMessage;
}

void SlaveReregisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_connection()) {
      if (connection_ != NULL) connection_->::mesos::internal::MasterSlaveConnection::Clear();
    }
  }
  reconciliations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveReregisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reconciliations;
        break;
      }

      // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reconciliations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reconciliations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reconciliations;
        if (input->ExpectTag(26)) goto parse_connection;
        break;
      }

      // optional .mesos.internal.MasterSlaveConnection connection = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_connection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_connection()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveReregisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
  for (int i = 0; i < this->reconciliations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->reconciliations(i), output);
  }

  // optional .mesos.internal.MasterSlaveConnection connection = 3;
  if (has_connection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->connection(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveReregisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
  for (int i = 0; i < this->reconciliations_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->reconciliations(i), target);
  }

  // optional .mesos.internal.MasterSlaveConnection connection = 3;
  if (has_connection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->connection(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveReregisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.internal.MasterSlaveConnection connection = 3;
    if (has_connection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->connection());
    }

  }
  // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
  total_size += 1 * this->reconciliations_size();
  for (int i = 0; i < this->reconciliations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reconciliations(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveReregisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveReregisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveReregisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveReregisteredMessage::MergeFrom(const SlaveReregisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  reconciliations_.MergeFrom(from.reconciliations_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_connection()) {
      mutable_connection()->::mesos::internal::MasterSlaveConnection::MergeFrom(from.connection());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveReregisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveReregisteredMessage::CopyFrom(const SlaveReregisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveReregisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  for (int i = 0; i < reconciliations_size(); i++) {
    if (!this->reconciliations(i).IsInitialized()) return false;
  }
  return true;
}

void SlaveReregisteredMessage::Swap(SlaveReregisteredMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    reconciliations_.Swap(&other->reconciliations_);
    std::swap(connection_, other->connection_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveReregisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveReregisteredMessage_descriptor_;
  metadata.reflection = SlaveReregisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UnregisterSlaveMessage::kSlaveIdFieldNumber;
#endif  // !_MSC_VER

UnregisterSlaveMessage::UnregisterSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UnregisterSlaveMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

UnregisterSlaveMessage::UnregisterSlaveMessage(const UnregisterSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UnregisterSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterSlaveMessage::~UnregisterSlaveMessage() {
  SharedDtor();
}

void UnregisterSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void UnregisterSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnregisterSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnregisterSlaveMessage_descriptor_;
}

const UnregisterSlaveMessage& UnregisterSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

UnregisterSlaveMessage* UnregisterSlaveMessage::default_instance_ = NULL;

UnregisterSlaveMessage* UnregisterSlaveMessage::New() const {
  return new UnregisterSlaveMessage;
}

void UnregisterSlaveMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnregisterSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UnregisterSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UnregisterSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UnregisterSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnregisterSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnregisterSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnregisterSlaveMessage::MergeFrom(const UnregisterSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnregisterSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnregisterSlaveMessage::CopyFrom(const UnregisterSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void UnregisterSlaveMessage::Swap(UnregisterSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnregisterSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnregisterSlaveMessage_descriptor_;
  metadata.reflection = UnregisterSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MasterSlaveConnection::kTotalPingTimeoutSecondsFieldNumber;
#endif  // !_MSC_VER

MasterSlaveConnection::MasterSlaveConnection()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MasterSlaveConnection::InitAsDefaultInstance() {
}

MasterSlaveConnection::MasterSlaveConnection(const MasterSlaveConnection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MasterSlaveConnection::SharedCtor() {
  _cached_size_ = 0;
  total_ping_timeout_seconds_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MasterSlaveConnection::~MasterSlaveConnection() {
  SharedDtor();
}

void MasterSlaveConnection::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MasterSlaveConnection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MasterSlaveConnection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterSlaveConnection_descriptor_;
}

const MasterSlaveConnection& MasterSlaveConnection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

MasterSlaveConnection* MasterSlaveConnection::default_instance_ = NULL;

MasterSlaveConnection* MasterSlaveConnection::New() const {
  return new MasterSlaveConnection;
}

void MasterSlaveConnection::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    total_ping_timeout_seconds_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MasterSlaveConnection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double total_ping_timeout_seconds = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &total_ping_timeout_seconds_)));
          set_has_total_ping_timeout_seconds();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MasterSlaveConnection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional double total_ping_timeout_seconds = 1;
  if (has_total_ping_timeout_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->total_ping_timeout_seconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MasterSlaveConnection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional double total_ping_timeout_seconds = 1;
  if (has_total_ping_timeout_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->total_ping_timeout_seconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MasterSlaveConnection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double total_ping_timeout_seconds = 1;
    if (has_total_ping_timeout_seconds()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MasterSlaveConnection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MasterSlaveConnection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MasterSlaveConnection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MasterSlaveConnection::MergeFrom(const MasterSlaveConnection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_total_ping_timeout_seconds()) {
      set_total_ping_timeout_seconds(from.total_ping_timeout_seconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MasterSlaveConnection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MasterSlaveConnection::CopyFrom(const MasterSlaveConnection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MasterSlaveConnection::IsInitialized() const {

  return true;
}

void MasterSlaveConnection::Swap(MasterSlaveConnection* other) {
  if (other != this) {
    std::swap(total_ping_timeout_seconds_, other->total_ping_timeout_seconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MasterSlaveConnection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MasterSlaveConnection_descriptor_;
  metadata.reflection = MasterSlaveConnection_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PingSlaveMessage::kConnectedFieldNumber;
#endif  // !_MSC_VER

PingSlaveMessage::PingSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PingSlaveMessage::InitAsDefaultInstance() {
}

PingSlaveMessage::PingSlaveMessage(const PingSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PingSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  connected_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PingSlaveMessage::~PingSlaveMessage() {
  SharedDtor();
}

void PingSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PingSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PingSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PingSlaveMessage_descriptor_;
}

const PingSlaveMessage& PingSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

PingSlaveMessage* PingSlaveMessage::default_instance_ = NULL;

PingSlaveMessage* PingSlaveMessage::New() const {
  return new PingSlaveMessage;
}

void PingSlaveMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    connected_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PingSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool connected = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
          set_has_connected();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PingSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool connected = 1;
  if (has_connected()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->connected(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PingSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool connected = 1;
  if (has_connected()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->connected(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PingSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool connected = 1;
    if (has_connected()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PingSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PingSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PingSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PingSlaveMessage::MergeFrom(const PingSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_connected()) {
      set_connected(from.connected());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PingSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PingSlaveMessage::CopyFrom(const PingSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PingSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PingSlaveMessage::Swap(PingSlaveMessage* other) {
  if (other != this) {
    std::swap(connected_, other->connected_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PingSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PingSlaveMessage_descriptor_;
  metadata.reflection = PingSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PongSlaveMessage::PongSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PongSlaveMessage::InitAsDefaultInstance() {
}

PongSlaveMessage::PongSlaveMessage(const PongSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PongSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PongSlaveMessage::~PongSlaveMessage() {
  SharedDtor();
}

void PongSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PongSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PongSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PongSlaveMessage_descriptor_;
}

const PongSlaveMessage& PongSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

PongSlaveMessage* PongSlaveMessage::default_instance_ = NULL;

PongSlaveMessage* PongSlaveMessage::New() const {
  return new PongSlaveMessage;
}

void PongSlaveMessage::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PongSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void PongSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PongSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PongSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PongSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PongSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PongSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PongSlaveMessage::MergeFrom(const PongSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PongSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PongSlaveMessage::CopyFrom(const PongSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PongSlaveMessage::IsInitialized() const {

  return true;
}

void PongSlaveMessage::Swap(PongSlaveMessage* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PongSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PongSlaveMessage_descriptor_;
  metadata.reflection = PongSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShutdownFrameworkMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

ShutdownFrameworkMessage::ShutdownFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ShutdownFrameworkMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ShutdownFrameworkMessage::ShutdownFrameworkMessage(const ShutdownFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ShutdownFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShutdownFrameworkMessage::~ShutdownFrameworkMessage() {
  SharedDtor();
}

void ShutdownFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void ShutdownFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShutdownFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShutdownFrameworkMessage_descriptor_;
}

const ShutdownFrameworkMessage& ShutdownFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ShutdownFrameworkMessage* ShutdownFrameworkMessage::default_instance_ = NULL;

ShutdownFrameworkMessage* ShutdownFrameworkMessage::New() const {
  return new ShutdownFrameworkMessage;
}

void ShutdownFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShutdownFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShutdownFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ShutdownFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ShutdownFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShutdownFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShutdownFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShutdownFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShutdownFrameworkMessage::MergeFrom(const ShutdownFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShutdownFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShutdownFrameworkMessage::CopyFrom(const ShutdownFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShutdownFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void ShutdownFrameworkMessage::Swap(ShutdownFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShutdownFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShutdownFrameworkMessage_descriptor_;
  metadata.reflection = ShutdownFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShutdownExecutorMessage::kExecutorIdFieldNumber;
const int ShutdownExecutorMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

ShutdownExecutorMessage::ShutdownExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ShutdownExecutorMessage::InitAsDefaultInstance() {
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ShutdownExecutorMessage::ShutdownExecutorMessage(const ShutdownExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ShutdownExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  executor_id_ = NULL;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShutdownExecutorMessage::~ShutdownExecutorMessage() {
  SharedDtor();
}

void ShutdownExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete executor_id_;
    delete framework_id_;
  }
}

void ShutdownExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShutdownExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShutdownExecutorMessage_descriptor_;
}

const ShutdownExecutorMessage& ShutdownExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ShutdownExecutorMessage* ShutdownExecutorMessage::default_instance_ = NULL;

ShutdownExecutorMessage* ShutdownExecutorMessage::New() const {
  return new ShutdownExecutorMessage;
}

void ShutdownExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShutdownExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.ExecutorID executor_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // optional .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShutdownExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_id(), output);
  }

  // optional .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ShutdownExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_id(), target);
  }

  // optional .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ShutdownExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.ExecutorID executor_id = 1;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // optional .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShutdownExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShutdownExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShutdownExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShutdownExecutorMessage::MergeFrom(const ShutdownExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShutdownExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShutdownExecutorMessage::CopyFrom(const ShutdownExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShutdownExecutorMessage::IsInitialized() const {

  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void ShutdownExecutorMessage::Swap(ShutdownExecutorMessage* other) {
  if (other != this) {
    std::swap(executor_id_, other->executor_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShutdownExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShutdownExecutorMessage_descriptor_;
  metadata.reflection = ShutdownExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateFrameworkMessage::kFrameworkIdFieldNumber;
const int UpdateFrameworkMessage::kPidFieldNumber;
#endif  // !_MSC_VER

UpdateFrameworkMessage::UpdateFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UpdateFrameworkMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

UpdateFrameworkMessage::UpdateFrameworkMessage(const UpdateFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateFrameworkMessage::~UpdateFrameworkMessage() {
  SharedDtor();
}

void UpdateFrameworkMessage::SharedDtor() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void UpdateFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateFrameworkMessage_descriptor_;
}

const UpdateFrameworkMessage& UpdateFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

UpdateFrameworkMessage* UpdateFrameworkMessage::default_instance_ = NULL;

UpdateFrameworkMessage* UpdateFrameworkMessage::New() const {
  return new UpdateFrameworkMessage;
}

void UpdateFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::kEmptyString) {
        pid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pid;
        break;
      }

      // optional string pid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UpdateFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UpdateFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional string pid = 2;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateFrameworkMessage::MergeFrom(const UpdateFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateFrameworkMessage::CopyFrom(const UpdateFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void UpdateFrameworkMessage::Swap(UpdateFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateFrameworkMessage_descriptor_;
  metadata.reflection = UpdateFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckpointResourcesMessage::kResourcesFieldNumber;
#endif  // !_MSC_VER

CheckpointResourcesMessage::CheckpointResourcesMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CheckpointResourcesMessage::InitAsDefaultInstance() {
}

CheckpointResourcesMessage::CheckpointResourcesMessage(const CheckpointResourcesMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CheckpointResourcesMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckpointResourcesMessage::~CheckpointResourcesMessage() {
  SharedDtor();
}

void CheckpointResourcesMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckpointResourcesMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckpointResourcesMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckpointResourcesMessage_descriptor_;
}

const CheckpointResourcesMessage& CheckpointResourcesMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

CheckpointResourcesMessage* CheckpointResourcesMessage::default_instance_ = NULL;

CheckpointResourcesMessage* CheckpointResourcesMessage::New() const {
  return new CheckpointResourcesMessage;
}

void CheckpointResourcesMessage::Clear() {
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckpointResourcesMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource resources = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_resources;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckpointResourcesMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CheckpointResourcesMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CheckpointResourcesMessage::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Resource resources = 1;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckpointResourcesMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckpointResourcesMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckpointResourcesMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckpointResourcesMessage::MergeFrom(const CheckpointResourcesMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckpointResourcesMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckpointResourcesMessage::CopyFrom(const CheckpointResourcesMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckpointResourcesMessage::IsInitialized() const {

  for (int i = 0; i < resources_size(); i++) {
    if (!this->resources(i).IsInitialized()) return false;
  }
  return true;
}

void CheckpointResourcesMessage::Swap(CheckpointResourcesMessage* other) {
  if (other != this) {
    resources_.Swap(&other->resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckpointResourcesMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckpointResourcesMessage_descriptor_;
  metadata.reflection = CheckpointResourcesMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateSlaveMessage::kSlaveIdFieldNumber;
const int UpdateSlaveMessage::kOversubscribedResourcesFieldNumber;
#endif  // !_MSC_VER

UpdateSlaveMessage::UpdateSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UpdateSlaveMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

UpdateSlaveMessage::UpdateSlaveMessage(const UpdateSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateSlaveMessage::~UpdateSlaveMessage() {
  SharedDtor();
}

void UpdateSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void UpdateSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateSlaveMessage_descriptor_;
}

const UpdateSlaveMessage& UpdateSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

UpdateSlaveMessage* UpdateSlaveMessage::default_instance_ = NULL;

UpdateSlaveMessage* UpdateSlaveMessage::New() const {
  return new UpdateSlaveMessage;
}

void UpdateSlaveMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
  }
  oversubscribed_resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_oversubscribed_resources;
        break;
      }

      // repeated .mesos.Resource oversubscribed_resources = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_oversubscribed_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_oversubscribed_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_oversubscribed_resources;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // repeated .mesos.Resource oversubscribed_resources = 2;
  for (int i = 0; i < this->oversubscribed_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->oversubscribed_resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UpdateSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // repeated .mesos.Resource oversubscribed_resources = 2;
  for (int i = 0; i < this->oversubscribed_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->oversubscribed_resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UpdateSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  // repeated .mesos.Resource oversubscribed_resources = 2;
  total_size += 1 * this->oversubscribed_resources_size();
  for (int i = 0; i < this->oversubscribed_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->oversubscribed_resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateSlaveMessage::MergeFrom(const UpdateSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  oversubscribed_resources_.MergeFrom(from.oversubscribed_resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateSlaveMessage::CopyFrom(const UpdateSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  for (int i = 0; i < oversubscribed_resources_size(); i++) {
    if (!this->oversubscribed_resources(i).IsInitialized()) return false;
  }
  return true;
}

void UpdateSlaveMessage::Swap(UpdateSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    oversubscribed_resources_.Swap(&other->oversubscribed_resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateSlaveMessage_descriptor_;
  metadata.reflection = UpdateSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterExecutorMessage::kFrameworkIdFieldNumber;
const int RegisterExecutorMessage::kExecutorIdFieldNumber;
#endif  // !_MSC_VER

RegisterExecutorMessage::RegisterExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RegisterExecutorMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

RegisterExecutorMessage::RegisterExecutorMessage(const RegisterExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  executor_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterExecutorMessage::~RegisterExecutorMessage() {
  SharedDtor();
}

void RegisterExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete executor_id_;
  }
}

void RegisterExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterExecutorMessage_descriptor_;
}

const RegisterExecutorMessage& RegisterExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

RegisterExecutorMessage* RegisterExecutorMessage::default_instance_ = NULL;

RegisterExecutorMessage* RegisterExecutorMessage::New() const {
  return new RegisterExecutorMessage;
}

void RegisterExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RegisterExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RegisterExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterExecutorMessage::MergeFrom(const RegisterExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterExecutorMessage::CopyFrom(const RegisterExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void RegisterExecutorMessage::Swap(RegisterExecutorMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterExecutorMessage_descriptor_;
  metadata.reflection = RegisterExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutorRegisteredMessage::kExecutorInfoFieldNumber;
const int ExecutorRegisteredMessage::kFrameworkIdFieldNumber;
const int ExecutorRegisteredMessage::kFrameworkInfoFieldNumber;
const int ExecutorRegisteredMessage::kSlaveIdFieldNumber;
const int ExecutorRegisteredMessage::kSlaveInfoFieldNumber;
#endif  // !_MSC_VER

ExecutorRegisteredMessage::ExecutorRegisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ExecutorRegisteredMessage::InitAsDefaultInstance() {
  executor_info_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  framework_info_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  slave_info_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

ExecutorRegisteredMessage::ExecutorRegisteredMessage(const ExecutorRegisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ExecutorRegisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  executor_info_ = NULL;
  framework_id_ = NULL;
  framework_info_ = NULL;
  slave_id_ = NULL;
  slave_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorRegisteredMessage::~ExecutorRegisteredMessage() {
  SharedDtor();
}

void ExecutorRegisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete executor_info_;
    delete framework_id_;
    delete framework_info_;
    delete slave_id_;
    delete slave_info_;
  }
}

void ExecutorRegisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorRegisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorRegisteredMessage_descriptor_;
}

const ExecutorRegisteredMessage& ExecutorRegisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ExecutorRegisteredMessage* ExecutorRegisteredMessage::default_instance_ = NULL;

ExecutorRegisteredMessage* ExecutorRegisteredMessage::New() const {
  return new ExecutorRegisteredMessage;
}

void ExecutorRegisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_executor_info()) {
      if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_framework_info()) {
      if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_slave_info()) {
      if (slave_info_ != NULL) slave_info_->::mesos::SlaveInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutorRegisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorInfo executor_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_framework_info;
        break;
      }

      // required .mesos.FrameworkInfo framework_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_slave_info;
        break;
      }

      // required .mesos.SlaveInfo slave_info = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExecutorRegisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.ExecutorInfo executor_info = 2;
  if (has_executor_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_info(), output);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->framework_id(), output);
  }

  // required .mesos.FrameworkInfo framework_info = 4;
  if (has_framework_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->framework_info(), output);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->slave_id(), output);
  }

  // required .mesos.SlaveInfo slave_info = 6;
  if (has_slave_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->slave_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ExecutorRegisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.ExecutorInfo executor_info = 2;
  if (has_executor_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_info(), target);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->framework_id(), target);
  }

  // required .mesos.FrameworkInfo framework_info = 4;
  if (has_framework_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->framework_info(), target);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->slave_id(), target);
  }

  // required .mesos.SlaveInfo slave_info = 6;
  if (has_slave_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->slave_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ExecutorRegisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.ExecutorInfo executor_info = 2;
    if (has_executor_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_info());
    }

    // required .mesos.FrameworkID framework_id = 3;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.FrameworkInfo framework_info = 4;
    if (has_framework_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_info());
    }

    // required .mesos.SlaveID slave_id = 5;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.SlaveInfo slave_info = 6;
    if (has_slave_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorRegisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutorRegisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutorRegisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutorRegisteredMessage::MergeFrom(const ExecutorRegisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_info()) {
      mutable_executor_info()->::mesos::ExecutorInfo::MergeFrom(from.executor_info());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_framework_info()) {
      mutable_framework_info()->::mesos::FrameworkInfo::MergeFrom(from.framework_info());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_slave_info()) {
      mutable_slave_info()->::mesos::SlaveInfo::MergeFrom(from.slave_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutorRegisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorRegisteredMessage::CopyFrom(const ExecutorRegisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorRegisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_executor_info()) {
    if (!this->executor_info().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_framework_info()) {
    if (!this->framework_info().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_slave_info()) {
    if (!this->slave_info().IsInitialized()) return false;
  }
  return true;
}

void ExecutorRegisteredMessage::Swap(ExecutorRegisteredMessage* other) {
  if (other != this) {
    std::swap(executor_info_, other->executor_info_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(framework_info_, other->framework_info_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(slave_info_, other->slave_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutorRegisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorRegisteredMessage_descriptor_;
  metadata.reflection = ExecutorRegisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutorReregisteredMessage::kSlaveIdFieldNumber;
const int ExecutorReregisteredMessage::kSlaveInfoFieldNumber;
#endif  // !_MSC_VER

ExecutorReregisteredMessage::ExecutorReregisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ExecutorReregisteredMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  slave_info_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

ExecutorReregisteredMessage::ExecutorReregisteredMessage(const ExecutorReregisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ExecutorReregisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  slave_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorReregisteredMessage::~ExecutorReregisteredMessage() {
  SharedDtor();
}

void ExecutorReregisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete slave_info_;
  }
}

void ExecutorReregisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorReregisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorReregisteredMessage_descriptor_;
}

const ExecutorReregisteredMessage& ExecutorReregisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ExecutorReregisteredMessage* ExecutorReregisteredMessage::default_instance_ = NULL;

ExecutorReregisteredMessage* ExecutorReregisteredMessage::New() const {
  return new ExecutorReregisteredMessage;
}

void ExecutorReregisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_slave_info()) {
      if (slave_info_ != NULL) slave_info_->::mesos::SlaveInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutorReregisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_info;
        break;
      }

      // required .mesos.SlaveInfo slave_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExecutorReregisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.SlaveInfo slave_info = 2;
  if (has_slave_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ExecutorReregisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.SlaveInfo slave_info = 2;
  if (has_slave_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ExecutorReregisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.SlaveInfo slave_info = 2;
    if (has_slave_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorReregisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutorReregisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutorReregisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutorReregisteredMessage::MergeFrom(const ExecutorReregisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_slave_info()) {
      mutable_slave_info()->::mesos::SlaveInfo::MergeFrom(from.slave_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutorReregisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorReregisteredMessage::CopyFrom(const ExecutorReregisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorReregisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_slave_info()) {
    if (!this->slave_info().IsInitialized()) return false;
  }
  return true;
}

void ExecutorReregisteredMessage::Swap(ExecutorReregisteredMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(slave_info_, other->slave_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutorReregisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorReregisteredMessage_descriptor_;
  metadata.reflection = ExecutorReregisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExitedExecutorMessage::kSlaveIdFieldNumber;
const int ExitedExecutorMessage::kFrameworkIdFieldNumber;
const int ExitedExecutorMessage::kExecutorIdFieldNumber;
const int ExitedExecutorMessage::kStatusFieldNumber;
#endif  // !_MSC_VER

ExitedExecutorMessage::ExitedExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ExitedExecutorMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

ExitedExecutorMessage::ExitedExecutorMessage(const ExitedExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ExitedExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitedExecutorMessage::~ExitedExecutorMessage() {
  SharedDtor();
}

void ExitedExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete framework_id_;
    delete executor_id_;
  }
}

void ExitedExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExitedExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExitedExecutorMessage_descriptor_;
}

const ExitedExecutorMessage& ExitedExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ExitedExecutorMessage* ExitedExecutorMessage::default_instance_ = NULL;

ExitedExecutorMessage* ExitedExecutorMessage::New() const {
  return new ExitedExecutorMessage;
}

void ExitedExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExitedExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_status;
        break;
      }

      // required int32 status = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExitedExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->executor_id(), output);
  }

  // required int32 status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ExitedExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->executor_id(), target);
  }

  // required int32 status = 4;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ExitedExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.ExecutorID executor_id = 3;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required int32 status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitedExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExitedExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExitedExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExitedExecutorMessage::MergeFrom(const ExitedExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExitedExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExitedExecutorMessage::CopyFrom(const ExitedExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitedExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void ExitedExecutorMessage::Swap(ExitedExecutorMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExitedExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExitedExecutorMessage_descriptor_;
  metadata.reflection = ExitedExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReconnectExecutorMessage::kSlaveIdFieldNumber;
#endif  // !_MSC_VER

ReconnectExecutorMessage::ReconnectExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReconnectExecutorMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

ReconnectExecutorMessage::ReconnectExecutorMessage(const ReconnectExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReconnectExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReconnectExecutorMessage::~ReconnectExecutorMessage() {
  SharedDtor();
}

void ReconnectExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void ReconnectExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReconnectExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconnectExecutorMessage_descriptor_;
}

const ReconnectExecutorMessage& ReconnectExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ReconnectExecutorMessage* ReconnectExecutorMessage::default_instance_ = NULL;

ReconnectExecutorMessage* ReconnectExecutorMessage::New() const {
  return new ReconnectExecutorMessage;
}

void ReconnectExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReconnectExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReconnectExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReconnectExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReconnectExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReconnectExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReconnectExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReconnectExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReconnectExecutorMessage::MergeFrom(const ReconnectExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReconnectExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReconnectExecutorMessage::CopyFrom(const ReconnectExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReconnectExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void ReconnectExecutorMessage::Swap(ReconnectExecutorMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReconnectExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReconnectExecutorMessage_descriptor_;
  metadata.reflection = ReconnectExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReregisterExecutorMessage::kExecutorIdFieldNumber;
const int ReregisterExecutorMessage::kFrameworkIdFieldNumber;
const int ReregisterExecutorMessage::kTasksFieldNumber;
const int ReregisterExecutorMessage::kUpdatesFieldNumber;
#endif  // !_MSC_VER

ReregisterExecutorMessage::ReregisterExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReregisterExecutorMessage::InitAsDefaultInstance() {
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ReregisterExecutorMessage::ReregisterExecutorMessage(const ReregisterExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReregisterExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  executor_id_ = NULL;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReregisterExecutorMessage::~ReregisterExecutorMessage() {
  SharedDtor();
}

void ReregisterExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete executor_id_;
    delete framework_id_;
  }
}

void ReregisterExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReregisterExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReregisterExecutorMessage_descriptor_;
}

const ReregisterExecutorMessage& ReregisterExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ReregisterExecutorMessage* ReregisterExecutorMessage::default_instance_ = NULL;

ReregisterExecutorMessage* ReregisterExecutorMessage::New() const {
  return new ReregisterExecutorMessage;
}

void ReregisterExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  tasks_.Clear();
  updates_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReregisterExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorID executor_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        break;
      }

      // repeated .mesos.TaskInfo tasks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        if (input->ExpectTag(34)) goto parse_updates;
        break;
      }

      // repeated .mesos.internal.StatusUpdate updates = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_updates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updates()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_updates;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReregisterExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // repeated .mesos.TaskInfo tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tasks(i), output);
  }

  // repeated .mesos.internal.StatusUpdate updates = 4;
  for (int i = 0; i < this->updates_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->updates(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReregisterExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // repeated .mesos.TaskInfo tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tasks(i), target);
  }

  // repeated .mesos.internal.StatusUpdate updates = 4;
  for (int i = 0; i < this->updates_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->updates(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReregisterExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.ExecutorID executor_id = 1;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  // repeated .mesos.TaskInfo tasks = 3;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  // repeated .mesos.internal.StatusUpdate updates = 4;
  total_size += 1 * this->updates_size();
  for (int i = 0; i < this->updates_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updates(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReregisterExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReregisterExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReregisterExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReregisterExecutorMessage::MergeFrom(const ReregisterExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  updates_.MergeFrom(from.updates_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReregisterExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReregisterExecutorMessage::CopyFrom(const ReregisterExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReregisterExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  for (int i = 0; i < tasks_size(); i++) {
    if (!this->tasks(i).IsInitialized()) return false;
  }
  for (int i = 0; i < updates_size(); i++) {
    if (!this->updates(i).IsInitialized()) return false;
  }
  return true;
}

void ReregisterExecutorMessage::Swap(ReregisterExecutorMessage* other) {
  if (other != this) {
    std::swap(executor_id_, other->executor_id_);
    std::swap(framework_id_, other->framework_id_);
    tasks_.Swap(&other->tasks_);
    updates_.Swap(&other->updates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReregisterExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReregisterExecutorMessage_descriptor_;
  metadata.reflection = ReregisterExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShutdownMessage::kMessageFieldNumber;
#endif  // !_MSC_VER

ShutdownMessage::ShutdownMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ShutdownMessage::InitAsDefaultInstance() {
}

ShutdownMessage::ShutdownMessage(const ShutdownMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ShutdownMessage::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShutdownMessage::~ShutdownMessage() {
  SharedDtor();
}

void ShutdownMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void ShutdownMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShutdownMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShutdownMessage_descriptor_;
}

const ShutdownMessage& ShutdownMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

ShutdownMessage* ShutdownMessage::default_instance_ = NULL;

ShutdownMessage* ShutdownMessage::New() const {
  return new ShutdownMessage;
}

void ShutdownMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShutdownMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShutdownMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ShutdownMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ShutdownMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShutdownMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShutdownMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShutdownMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShutdownMessage::MergeFrom(const ShutdownMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShutdownMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShutdownMessage::CopyFrom(const ShutdownMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShutdownMessage::IsInitialized() const {

  return true;
}

void ShutdownMessage::Swap(ShutdownMessage* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShutdownMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShutdownMessage_descriptor_;
  metadata.reflection = ShutdownMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Archive_Framework::kFrameworkInfoFieldNumber;
const int Archive_Framework::kPidFieldNumber;
const int Archive_Framework::kTasksFieldNumber;
#endif  // !_MSC_VER

Archive_Framework::Archive_Framework()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Archive_Framework::InitAsDefaultInstance() {
  framework_info_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

Archive_Framework::Archive_Framework(const Archive_Framework& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Archive_Framework::SharedCtor() {
  _cached_size_ = 0;
  framework_info_ = NULL;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Archive_Framework::~Archive_Framework() {
  SharedDtor();
}

void Archive_Framework::SharedDtor() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (this != default_instance_) {
    delete framework_info_;
  }
}

void Archive_Framework::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Archive_Framework::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Archive_Framework_descriptor_;
}

const Archive_Framework& Archive_Framework::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

Archive_Framework* Archive_Framework::default_instance_ = NULL;

Archive_Framework* Archive_Framework::New() const {
  return new Archive_Framework;
}

void Archive_Framework::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_info()) {
      if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
    }
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::kEmptyString) {
        pid_->clear();
      }
    }
  }
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Archive_Framework::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkInfo framework_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pid;
        break;
      }

      // optional string pid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        break;
      }

      // repeated .mesos.internal.Task tasks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Archive_Framework::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.FrameworkInfo framework_info = 1;
  if (has_framework_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_info(), output);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pid(), output);
  }

  // repeated .mesos.internal.Task tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tasks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Archive_Framework::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.FrameworkInfo framework_info = 1;
  if (has_framework_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_info(), target);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pid(), target);
  }

  // repeated .mesos.internal.Task tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tasks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Archive_Framework::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkInfo framework_info = 1;
    if (has_framework_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_info());
    }

    // optional string pid = 2;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

  }
  // repeated .mesos.internal.Task tasks = 3;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Archive_Framework::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Archive_Framework* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Archive_Framework*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Archive_Framework::MergeFrom(const Archive_Framework& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_info()) {
      mutable_framework_info()->::mesos::FrameworkInfo::MergeFrom(from.framework_info());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Archive_Framework::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Archive_Framework::CopyFrom(const Archive_Framework& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Archive_Framework::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_info()) {
    if (!this->framework_info().IsInitialized()) return false;
  }
  for (int i = 0; i < tasks_size(); i++) {
    if (!this->tasks(i).IsInitialized()) return false;
  }
  return true;
}

void Archive_Framework::Swap(Archive_Framework* other) {
  if (other != this) {
    std::swap(framework_info_, other->framework_info_);
    std::swap(pid_, other->pid_);
    tasks_.Swap(&other->tasks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Archive_Framework::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Archive_Framework_descriptor_;
  metadata.reflection = Archive_Framework_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Archive::kFrameworksFieldNumber;
#endif  // !_MSC_VER

Archive::Archive()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Archive::InitAsDefaultInstance() {
}

Archive::Archive(const Archive& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Archive::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Archive::~Archive() {
  SharedDtor();
}

void Archive::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Archive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Archive::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Archive_descriptor_;
}

const Archive& Archive::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

Archive* Archive::default_instance_ = NULL;

Archive* Archive::New() const {
  return new Archive;
}

void Archive::Clear() {
  frameworks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Archive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.internal.Archive.Framework frameworks = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_frameworks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frameworks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_frameworks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Archive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mesos.internal.Archive.Framework frameworks = 1;
  for (int i = 0; i < this->frameworks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->frameworks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Archive::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .mesos.internal.Archive.Framework frameworks = 1;
  for (int i = 0; i < this->frameworks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->frameworks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Archive::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.internal.Archive.Framework frameworks = 1;
  total_size += 1 * this->frameworks_size();
  for (int i = 0; i < this->frameworks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frameworks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Archive::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Archive* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Archive*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Archive::MergeFrom(const Archive& from) {
  GOOGLE_CHECK_NE(&from, this);
  frameworks_.MergeFrom(from.frameworks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Archive::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Archive::CopyFrom(const Archive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Archive::IsInitialized() const {

  for (int i = 0; i < frameworks_size(); i++) {
    if (!this->frameworks(i).IsInitialized()) return false;
  }
  return true;
}

void Archive::Swap(Archive* other) {
  if (other != this) {
    frameworks_.Swap(&other->frameworks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Archive::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Archive_descriptor_;
  metadata.reflection = Archive_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TaskHealthStatus::kTaskIdFieldNumber;
const int TaskHealthStatus::kHealthyFieldNumber;
const int TaskHealthStatus::kKillTaskFieldNumber;
const int TaskHealthStatus::kConsecutiveFailuresFieldNumber;
#endif  // !_MSC_VER

TaskHealthStatus::TaskHealthStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TaskHealthStatus::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
}

TaskHealthStatus::TaskHealthStatus(const TaskHealthStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TaskHealthStatus::SharedCtor() {
  _cached_size_ = 0;
  task_id_ = NULL;
  healthy_ = false;
  kill_task_ = false;
  consecutive_failures_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskHealthStatus::~TaskHealthStatus() {
  SharedDtor();
}

void TaskHealthStatus::SharedDtor() {
  if (this != default_instance_) {
    delete task_id_;
  }
}

void TaskHealthStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskHealthStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskHealthStatus_descriptor_;
}

const TaskHealthStatus& TaskHealthStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

TaskHealthStatus* TaskHealthStatus::default_instance_ = NULL;

TaskHealthStatus* TaskHealthStatus::New() const {
  return new TaskHealthStatus;
}

void TaskHealthStatus::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    healthy_ = false;
    kill_task_ = false;
    consecutive_failures_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskHealthStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TaskID task_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_healthy;
        break;
      }

      // required bool healthy = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_healthy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &healthy_)));
          set_has_healthy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_kill_task;
        break;
      }

      // optional bool kill_task = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_kill_task:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &kill_task_)));
          set_has_kill_task();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_consecutive_failures;
        break;
      }

      // optional int32 consecutive_failures = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_consecutive_failures:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &consecutive_failures_)));
          set_has_consecutive_failures();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TaskHealthStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_id(), output);
  }

  // required bool healthy = 2;
  if (has_healthy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->healthy(), output);
  }

  // optional bool kill_task = 3 [default = false];
  if (has_kill_task()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->kill_task(), output);
  }

  // optional int32 consecutive_failures = 4;
  if (has_consecutive_failures()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->consecutive_failures(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TaskHealthStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->task_id(), target);
  }

  // required bool healthy = 2;
  if (has_healthy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->healthy(), target);
  }

  // optional bool kill_task = 3 [default = false];
  if (has_kill_task()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->kill_task(), target);
  }

  // optional int32 consecutive_failures = 4;
  if (has_consecutive_failures()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->consecutive_failures(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TaskHealthStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.TaskID task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required bool healthy = 2;
    if (has_healthy()) {
      total_size += 1 + 1;
    }

    // optional bool kill_task = 3 [default = false];
    if (has_kill_task()) {
      total_size += 1 + 1;
    }

    // optional int32 consecutive_failures = 4;
    if (has_consecutive_failures()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->consecutive_failures());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskHealthStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskHealthStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskHealthStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskHealthStatus::MergeFrom(const TaskHealthStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_healthy()) {
      set_healthy(from.healthy());
    }
    if (from.has_kill_task()) {
      set_kill_task(from.kill_task());
    }
    if (from.has_consecutive_failures()) {
      set_consecutive_failures(from.consecutive_failures());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskHealthStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskHealthStatus::CopyFrom(const TaskHealthStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskHealthStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  return true;
}

void TaskHealthStatus::Swap(TaskHealthStatus* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(healthy_, other->healthy_);
    std::swap(kill_task_, other->kill_task_);
    std::swap(consecutive_failures_, other->consecutive_failures_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskHealthStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskHealthStatus_descriptor_;
  metadata.reflection = TaskHealthStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HookExecuted::kModuleFieldNumber;
#endif  // !_MSC_VER

HookExecuted::HookExecuted()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HookExecuted::InitAsDefaultInstance() {
}

HookExecuted::HookExecuted(const HookExecuted& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HookExecuted::SharedCtor() {
  _cached_size_ = 0;
  module_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HookExecuted::~HookExecuted() {
  SharedDtor();
}

void HookExecuted::SharedDtor() {
  if (module_ != &::google::protobuf::internal::kEmptyString) {
    delete module_;
  }
  if (this != default_instance_) {
  }
}

void HookExecuted::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HookExecuted::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HookExecuted_descriptor_;
}

const HookExecuted& HookExecuted::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2fmessages_2eproto();
  return *default_instance_;
}

HookExecuted* HookExecuted::default_instance_ = NULL;

HookExecuted* HookExecuted::New() const {
  return new HookExecuted;
}

void HookExecuted::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_module()) {
      if (module_ != &::google::protobuf::internal::kEmptyString) {
        module_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HookExecuted::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string module = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_module()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->module().data(), this->module().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HookExecuted::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string module = 1;
  if (has_module()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->module().data(), this->module().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->module(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HookExecuted::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string module = 1;
  if (has_module()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->module().data(), this->module().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->module(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HookExecuted::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string module = 1;
    if (has_module()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->module());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HookExecuted::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HookExecuted* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HookExecuted*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HookExecuted::MergeFrom(const HookExecuted& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_module()) {
      set_module(from.module());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HookExecuted::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HookExecuted::CopyFrom(const HookExecuted& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HookExecuted::IsInitialized() const {

  return true;
}

void HookExecuted::Swap(HookExecuted* other) {
  if (other != this) {
    std::swap(module_, other->module_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HookExecuted::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HookExecuted_descriptor_;
  metadata.reflection = HookExecuted_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace internal
}  // namespace mesos

// @@protoc_insertion_point(global_scope)
