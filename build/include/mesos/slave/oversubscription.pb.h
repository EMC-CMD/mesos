// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/slave/oversubscription.proto

#ifndef PROTOBUF_mesos_2fslave_2foversubscription_2eproto__INCLUDED
#define PROTOBUF_mesos_2fslave_2foversubscription_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace mesos {
namespace slave {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mesos_2fslave_2foversubscription_2eproto();
void protobuf_AssignDesc_mesos_2fslave_2foversubscription_2eproto();
void protobuf_ShutdownFile_mesos_2fslave_2foversubscription_2eproto();

class QoSCorrection;
class QoSCorrection_Kill;

enum QoSCorrection_Type {
  QoSCorrection_Type_KILL = 1
};
bool QoSCorrection_Type_IsValid(int value);
const QoSCorrection_Type QoSCorrection_Type_Type_MIN = QoSCorrection_Type_KILL;
const QoSCorrection_Type QoSCorrection_Type_Type_MAX = QoSCorrection_Type_KILL;
const int QoSCorrection_Type_Type_ARRAYSIZE = QoSCorrection_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* QoSCorrection_Type_descriptor();
inline const ::std::string& QoSCorrection_Type_Name(QoSCorrection_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    QoSCorrection_Type_descriptor(), value);
}
inline bool QoSCorrection_Type_Parse(
    const ::std::string& name, QoSCorrection_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QoSCorrection_Type>(
    QoSCorrection_Type_descriptor(), name, value);
}
// ===================================================================

class QoSCorrection_Kill : public ::google::protobuf::Message {
 public:
  QoSCorrection_Kill();
  virtual ~QoSCorrection_Kill();

  QoSCorrection_Kill(const QoSCorrection_Kill& from);

  inline QoSCorrection_Kill& operator=(const QoSCorrection_Kill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QoSCorrection_Kill& default_instance();

  void Swap(QoSCorrection_Kill* other);

  // implements Message ----------------------------------------------

  QoSCorrection_Kill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QoSCorrection_Kill& from);
  void MergeFrom(const QoSCorrection_Kill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional .mesos.ContainerID container_id = 3;
  inline bool has_container_id() const;
  inline void clear_container_id();
  static const int kContainerIdFieldNumber = 3;
  inline const ::mesos::ContainerID& container_id() const;
  inline ::mesos::ContainerID* mutable_container_id();
  inline ::mesos::ContainerID* release_container_id();
  inline void set_allocated_container_id(::mesos::ContainerID* container_id);

  // @@protoc_insertion_point(class_scope:mesos.slave.QoSCorrection.Kill)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_container_id();
  inline void clear_has_container_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::ContainerID* container_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fslave_2foversubscription_2eproto();
  friend void protobuf_AssignDesc_mesos_2fslave_2foversubscription_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fslave_2foversubscription_2eproto();

  void InitAsDefaultInstance();
  static QoSCorrection_Kill* default_instance_;
};
// -------------------------------------------------------------------

class QoSCorrection : public ::google::protobuf::Message {
 public:
  QoSCorrection();
  virtual ~QoSCorrection();

  QoSCorrection(const QoSCorrection& from);

  inline QoSCorrection& operator=(const QoSCorrection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QoSCorrection& default_instance();

  void Swap(QoSCorrection* other);

  // implements Message ----------------------------------------------

  QoSCorrection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QoSCorrection& from);
  void MergeFrom(const QoSCorrection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef QoSCorrection_Kill Kill;

  typedef QoSCorrection_Type Type;
  static const Type KILL = QoSCorrection_Type_KILL;
  static inline bool Type_IsValid(int value) {
    return QoSCorrection_Type_IsValid(value);
  }
  static const Type Type_MIN =
    QoSCorrection_Type_Type_MIN;
  static const Type Type_MAX =
    QoSCorrection_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    QoSCorrection_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return QoSCorrection_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return QoSCorrection_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return QoSCorrection_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.slave.QoSCorrection.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::slave::QoSCorrection_Type type() const;
  inline void set_type(::mesos::slave::QoSCorrection_Type value);

  // optional .mesos.slave.QoSCorrection.Kill kill = 2;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 2;
  inline const ::mesos::slave::QoSCorrection_Kill& kill() const;
  inline ::mesos::slave::QoSCorrection_Kill* mutable_kill();
  inline ::mesos::slave::QoSCorrection_Kill* release_kill();
  inline void set_allocated_kill(::mesos::slave::QoSCorrection_Kill* kill);

  // @@protoc_insertion_point(class_scope:mesos.slave.QoSCorrection)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_kill();
  inline void clear_has_kill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::slave::QoSCorrection_Kill* kill_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fslave_2foversubscription_2eproto();
  friend void protobuf_AssignDesc_mesos_2fslave_2foversubscription_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fslave_2foversubscription_2eproto();

  void InitAsDefaultInstance();
  static QoSCorrection* default_instance_;
};
// ===================================================================


// ===================================================================

// QoSCorrection_Kill

// optional .mesos.FrameworkID framework_id = 1;
inline bool QoSCorrection_Kill::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QoSCorrection_Kill::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QoSCorrection_Kill::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QoSCorrection_Kill::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& QoSCorrection_Kill::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* QoSCorrection_Kill::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* QoSCorrection_Kill::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void QoSCorrection_Kill::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// optional .mesos.ExecutorID executor_id = 2;
inline bool QoSCorrection_Kill::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QoSCorrection_Kill::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QoSCorrection_Kill::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QoSCorrection_Kill::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& QoSCorrection_Kill::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* QoSCorrection_Kill::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* QoSCorrection_Kill::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void QoSCorrection_Kill::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional .mesos.ContainerID container_id = 3;
inline bool QoSCorrection_Kill::has_container_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QoSCorrection_Kill::set_has_container_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QoSCorrection_Kill::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QoSCorrection_Kill::clear_container_id() {
  if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
  clear_has_container_id();
}
inline const ::mesos::ContainerID& QoSCorrection_Kill::container_id() const {
  return container_id_ != NULL ? *container_id_ : *default_instance_->container_id_;
}
inline ::mesos::ContainerID* QoSCorrection_Kill::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) container_id_ = new ::mesos::ContainerID;
  return container_id_;
}
inline ::mesos::ContainerID* QoSCorrection_Kill::release_container_id() {
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline void QoSCorrection_Kill::set_allocated_container_id(::mesos::ContainerID* container_id) {
  delete container_id_;
  container_id_ = container_id;
  if (container_id) {
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
}

// -------------------------------------------------------------------

// QoSCorrection

// required .mesos.slave.QoSCorrection.Type type = 1;
inline bool QoSCorrection::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QoSCorrection::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QoSCorrection::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QoSCorrection::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::slave::QoSCorrection_Type QoSCorrection::type() const {
  return static_cast< ::mesos::slave::QoSCorrection_Type >(type_);
}
inline void QoSCorrection::set_type(::mesos::slave::QoSCorrection_Type value) {
  assert(::mesos::slave::QoSCorrection_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.slave.QoSCorrection.Kill kill = 2;
inline bool QoSCorrection::has_kill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QoSCorrection::set_has_kill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QoSCorrection::clear_has_kill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QoSCorrection::clear_kill() {
  if (kill_ != NULL) kill_->::mesos::slave::QoSCorrection_Kill::Clear();
  clear_has_kill();
}
inline const ::mesos::slave::QoSCorrection_Kill& QoSCorrection::kill() const {
  return kill_ != NULL ? *kill_ : *default_instance_->kill_;
}
inline ::mesos::slave::QoSCorrection_Kill* QoSCorrection::mutable_kill() {
  set_has_kill();
  if (kill_ == NULL) kill_ = new ::mesos::slave::QoSCorrection_Kill;
  return kill_;
}
inline ::mesos::slave::QoSCorrection_Kill* QoSCorrection::release_kill() {
  clear_has_kill();
  ::mesos::slave::QoSCorrection_Kill* temp = kill_;
  kill_ = NULL;
  return temp;
}
inline void QoSCorrection::set_allocated_kill(::mesos::slave::QoSCorrection_Kill* kill) {
  delete kill_;
  kill_ = kill;
  if (kill) {
    set_has_kill();
  } else {
    clear_has_kill();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace slave
}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::slave::QoSCorrection_Type>() {
  return ::mesos::slave::QoSCorrection_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fslave_2foversubscription_2eproto__INCLUDED
