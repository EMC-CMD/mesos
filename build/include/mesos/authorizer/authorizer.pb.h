// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/authorizer/authorizer.proto

#ifndef PROTOBUF_mesos_2fauthorizer_2fauthorizer_2eproto__INCLUDED
#define PROTOBUF_mesos_2fauthorizer_2fauthorizer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace mesos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
void protobuf_AssignDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
void protobuf_ShutdownFile_mesos_2fauthorizer_2fauthorizer_2eproto();

class ACL;
class ACL_Entity;
class ACL_RegisterFramework;
class ACL_RunTask;
class ACL_ShutdownFramework;
class ACLs;

enum ACL_Entity_Type {
  ACL_Entity_Type_SOME = 0,
  ACL_Entity_Type_ANY = 1,
  ACL_Entity_Type_NONE = 2
};
bool ACL_Entity_Type_IsValid(int value);
const ACL_Entity_Type ACL_Entity_Type_Type_MIN = ACL_Entity_Type_SOME;
const ACL_Entity_Type ACL_Entity_Type_Type_MAX = ACL_Entity_Type_NONE;
const int ACL_Entity_Type_Type_ARRAYSIZE = ACL_Entity_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACL_Entity_Type_descriptor();
inline const ::std::string& ACL_Entity_Type_Name(ACL_Entity_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACL_Entity_Type_descriptor(), value);
}
inline bool ACL_Entity_Type_Parse(
    const ::std::string& name, ACL_Entity_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACL_Entity_Type>(
    ACL_Entity_Type_descriptor(), name, value);
}
// ===================================================================

class ACL_Entity : public ::google::protobuf::Message {
 public:
  ACL_Entity();
  virtual ~ACL_Entity();

  ACL_Entity(const ACL_Entity& from);

  inline ACL_Entity& operator=(const ACL_Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_Entity& default_instance();

  void Swap(ACL_Entity* other);

  // implements Message ----------------------------------------------

  ACL_Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_Entity& from);
  void MergeFrom(const ACL_Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ACL_Entity_Type Type;
  static const Type SOME = ACL_Entity_Type_SOME;
  static const Type ANY = ACL_Entity_Type_ANY;
  static const Type NONE = ACL_Entity_Type_NONE;
  static inline bool Type_IsValid(int value) {
    return ACL_Entity_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ACL_Entity_Type_Type_MIN;
  static const Type Type_MAX =
    ACL_Entity_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ACL_Entity_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ACL_Entity_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ACL_Entity_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ACL_Entity_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.ACL.Entity.Type type = 1 [default = SOME];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::ACL_Entity_Type type() const;
  inline void set_type(::mesos::ACL_Entity_Type value);

  // repeated string values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:mesos.ACL.Entity)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_AssignDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fauthorizer_2fauthorizer_2eproto();

  void InitAsDefaultInstance();
  static ACL_Entity* default_instance_;
};
// -------------------------------------------------------------------

class ACL_RegisterFramework : public ::google::protobuf::Message {
 public:
  ACL_RegisterFramework();
  virtual ~ACL_RegisterFramework();

  ACL_RegisterFramework(const ACL_RegisterFramework& from);

  inline ACL_RegisterFramework& operator=(const ACL_RegisterFramework& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RegisterFramework& default_instance();

  void Swap(ACL_RegisterFramework* other);

  // implements Message ----------------------------------------------

  ACL_RegisterFramework* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_RegisterFramework& from);
  void MergeFrom(const ACL_RegisterFramework& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  inline bool has_principals() const;
  inline void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  inline const ::mesos::ACL_Entity& principals() const;
  inline ::mesos::ACL_Entity* mutable_principals();
  inline ::mesos::ACL_Entity* release_principals();
  inline void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  inline bool has_roles() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 2;
  inline const ::mesos::ACL_Entity& roles() const;
  inline ::mesos::ACL_Entity* mutable_roles();
  inline ::mesos::ACL_Entity* release_roles();
  inline void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RegisterFramework)
 private:
  inline void set_has_principals();
  inline void clear_has_principals();
  inline void set_has_roles();
  inline void clear_has_roles();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_AssignDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fauthorizer_2fauthorizer_2eproto();

  void InitAsDefaultInstance();
  static ACL_RegisterFramework* default_instance_;
};
// -------------------------------------------------------------------

class ACL_RunTask : public ::google::protobuf::Message {
 public:
  ACL_RunTask();
  virtual ~ACL_RunTask();

  ACL_RunTask(const ACL_RunTask& from);

  inline ACL_RunTask& operator=(const ACL_RunTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RunTask& default_instance();

  void Swap(ACL_RunTask* other);

  // implements Message ----------------------------------------------

  ACL_RunTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_RunTask& from);
  void MergeFrom(const ACL_RunTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  inline bool has_principals() const;
  inline void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  inline const ::mesos::ACL_Entity& principals() const;
  inline ::mesos::ACL_Entity* mutable_principals();
  inline ::mesos::ACL_Entity* release_principals();
  inline void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  inline bool has_users() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline const ::mesos::ACL_Entity& users() const;
  inline ::mesos::ACL_Entity* mutable_users();
  inline ::mesos::ACL_Entity* release_users();
  inline void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RunTask)
 private:
  inline void set_has_principals();
  inline void clear_has_principals();
  inline void set_has_users();
  inline void clear_has_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_AssignDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fauthorizer_2fauthorizer_2eproto();

  void InitAsDefaultInstance();
  static ACL_RunTask* default_instance_;
};
// -------------------------------------------------------------------

class ACL_ShutdownFramework : public ::google::protobuf::Message {
 public:
  ACL_ShutdownFramework();
  virtual ~ACL_ShutdownFramework();

  ACL_ShutdownFramework(const ACL_ShutdownFramework& from);

  inline ACL_ShutdownFramework& operator=(const ACL_ShutdownFramework& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ShutdownFramework& default_instance();

  void Swap(ACL_ShutdownFramework* other);

  // implements Message ----------------------------------------------

  ACL_ShutdownFramework* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_ShutdownFramework& from);
  void MergeFrom(const ACL_ShutdownFramework& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  inline bool has_principals() const;
  inline void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  inline const ::mesos::ACL_Entity& principals() const;
  inline ::mesos::ACL_Entity* mutable_principals();
  inline ::mesos::ACL_Entity* release_principals();
  inline void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity framework_principals = 2;
  inline bool has_framework_principals() const;
  inline void clear_framework_principals();
  static const int kFrameworkPrincipalsFieldNumber = 2;
  inline const ::mesos::ACL_Entity& framework_principals() const;
  inline ::mesos::ACL_Entity* mutable_framework_principals();
  inline ::mesos::ACL_Entity* release_framework_principals();
  inline void set_allocated_framework_principals(::mesos::ACL_Entity* framework_principals);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ShutdownFramework)
 private:
  inline void set_has_principals();
  inline void clear_has_principals();
  inline void set_has_framework_principals();
  inline void clear_has_framework_principals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* framework_principals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_AssignDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fauthorizer_2fauthorizer_2eproto();

  void InitAsDefaultInstance();
  static ACL_ShutdownFramework* default_instance_;
};
// -------------------------------------------------------------------

class ACL : public ::google::protobuf::Message {
 public:
  ACL();
  virtual ~ACL();

  ACL(const ACL& from);

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL& default_instance();

  void Swap(ACL* other);

  // implements Message ----------------------------------------------

  ACL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ACL_Entity Entity;
  typedef ACL_RegisterFramework RegisterFramework;
  typedef ACL_RunTask RunTask;
  typedef ACL_ShutdownFramework ShutdownFramework;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.ACL)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_AssignDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fauthorizer_2fauthorizer_2eproto();

  void InitAsDefaultInstance();
  static ACL* default_instance_;
};
// -------------------------------------------------------------------

class ACLs : public ::google::protobuf::Message {
 public:
  ACLs();
  virtual ~ACLs();

  ACLs(const ACLs& from);

  inline ACLs& operator=(const ACLs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACLs& default_instance();

  void Swap(ACLs* other);

  // implements Message ----------------------------------------------

  ACLs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACLs& from);
  void MergeFrom(const ACLs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool permissive = 1 [default = true];
  inline bool has_permissive() const;
  inline void clear_permissive();
  static const int kPermissiveFieldNumber = 1;
  inline bool permissive() const;
  inline void set_permissive(bool value);

  // repeated .mesos.ACL.RegisterFramework register_frameworks = 2;
  inline int register_frameworks_size() const;
  inline void clear_register_frameworks();
  static const int kRegisterFrameworksFieldNumber = 2;
  inline const ::mesos::ACL_RegisterFramework& register_frameworks(int index) const;
  inline ::mesos::ACL_RegisterFramework* mutable_register_frameworks(int index);
  inline ::mesos::ACL_RegisterFramework* add_register_frameworks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >&
      register_frameworks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >*
      mutable_register_frameworks();

  // repeated .mesos.ACL.RunTask run_tasks = 3;
  inline int run_tasks_size() const;
  inline void clear_run_tasks();
  static const int kRunTasksFieldNumber = 3;
  inline const ::mesos::ACL_RunTask& run_tasks(int index) const;
  inline ::mesos::ACL_RunTask* mutable_run_tasks(int index);
  inline ::mesos::ACL_RunTask* add_run_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >&
      run_tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >*
      mutable_run_tasks();

  // repeated .mesos.ACL.ShutdownFramework shutdown_frameworks = 4;
  inline int shutdown_frameworks_size() const;
  inline void clear_shutdown_frameworks();
  static const int kShutdownFrameworksFieldNumber = 4;
  inline const ::mesos::ACL_ShutdownFramework& shutdown_frameworks(int index) const;
  inline ::mesos::ACL_ShutdownFramework* mutable_shutdown_frameworks(int index);
  inline ::mesos::ACL_ShutdownFramework* add_shutdown_frameworks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework >&
      shutdown_frameworks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework >*
      mutable_shutdown_frameworks();

  // @@protoc_insertion_point(class_scope:mesos.ACLs)
 private:
  inline void set_has_permissive();
  inline void clear_has_permissive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework > register_frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask > run_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework > shutdown_frameworks_;
  bool permissive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_AssignDesc_mesos_2fauthorizer_2fauthorizer_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fauthorizer_2fauthorizer_2eproto();

  void InitAsDefaultInstance();
  static ACLs* default_instance_;
};
// ===================================================================


// ===================================================================

// ACL_Entity

// optional .mesos.ACL.Entity.Type type = 1 [default = SOME];
inline bool ACL_Entity::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_Entity::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_Entity::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_Entity::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::ACL_Entity_Type ACL_Entity::type() const {
  return static_cast< ::mesos::ACL_Entity_Type >(type_);
}
inline void ACL_Entity::set_type(::mesos::ACL_Entity_Type value) {
  assert(::mesos::ACL_Entity_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated string values = 2;
inline int ACL_Entity::values_size() const {
  return values_.size();
}
inline void ACL_Entity::clear_values() {
  values_.Clear();
}
inline const ::std::string& ACL_Entity::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* ACL_Entity::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void ACL_Entity::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void ACL_Entity::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void ACL_Entity::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACL_Entity::add_values() {
  return values_.Add();
}
inline void ACL_Entity::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void ACL_Entity::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void ACL_Entity::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ACL_Entity::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ACL_Entity::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// ACL_RegisterFramework

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RegisterFramework::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RegisterFramework::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RegisterFramework::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RegisterFramework::clear_principals() {
  if (principals_ != NULL) principals_->::mesos::ACL_Entity::Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RegisterFramework::principals() const {
  return principals_ != NULL ? *principals_ : *default_instance_->principals_;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) principals_ = new ::mesos::ACL_Entity;
  return principals_;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::release_principals() {
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline void ACL_RegisterFramework::set_allocated_principals(::mesos::ACL_Entity* principals) {
  delete principals_;
  principals_ = principals;
  if (principals) {
    set_has_principals();
  } else {
    clear_has_principals();
  }
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_RegisterFramework::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RegisterFramework::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RegisterFramework::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RegisterFramework::clear_roles() {
  if (roles_ != NULL) roles_->::mesos::ACL_Entity::Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_RegisterFramework::roles() const {
  return roles_ != NULL ? *roles_ : *default_instance_->roles_;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) roles_ = new ::mesos::ACL_Entity;
  return roles_;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::release_roles() {
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline void ACL_RegisterFramework::set_allocated_roles(::mesos::ACL_Entity* roles) {
  delete roles_;
  roles_ = roles;
  if (roles) {
    set_has_roles();
  } else {
    clear_has_roles();
  }
}

// -------------------------------------------------------------------

// ACL_RunTask

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RunTask::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RunTask::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RunTask::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RunTask::clear_principals() {
  if (principals_ != NULL) principals_->::mesos::ACL_Entity::Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RunTask::principals() const {
  return principals_ != NULL ? *principals_ : *default_instance_->principals_;
}
inline ::mesos::ACL_Entity* ACL_RunTask::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) principals_ = new ::mesos::ACL_Entity;
  return principals_;
}
inline ::mesos::ACL_Entity* ACL_RunTask::release_principals() {
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline void ACL_RunTask::set_allocated_principals(::mesos::ACL_Entity* principals) {
  delete principals_;
  principals_ = principals;
  if (principals) {
    set_has_principals();
  } else {
    clear_has_principals();
  }
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_RunTask::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RunTask::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RunTask::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RunTask::clear_users() {
  if (users_ != NULL) users_->::mesos::ACL_Entity::Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_RunTask::users() const {
  return users_ != NULL ? *users_ : *default_instance_->users_;
}
inline ::mesos::ACL_Entity* ACL_RunTask::mutable_users() {
  set_has_users();
  if (users_ == NULL) users_ = new ::mesos::ACL_Entity;
  return users_;
}
inline ::mesos::ACL_Entity* ACL_RunTask::release_users() {
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline void ACL_RunTask::set_allocated_users(::mesos::ACL_Entity* users) {
  delete users_;
  users_ = users;
  if (users) {
    set_has_users();
  } else {
    clear_has_users();
  }
}

// -------------------------------------------------------------------

// ACL_ShutdownFramework

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ShutdownFramework::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ShutdownFramework::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ShutdownFramework::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ShutdownFramework::clear_principals() {
  if (principals_ != NULL) principals_->::mesos::ACL_Entity::Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ShutdownFramework::principals() const {
  return principals_ != NULL ? *principals_ : *default_instance_->principals_;
}
inline ::mesos::ACL_Entity* ACL_ShutdownFramework::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) principals_ = new ::mesos::ACL_Entity;
  return principals_;
}
inline ::mesos::ACL_Entity* ACL_ShutdownFramework::release_principals() {
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline void ACL_ShutdownFramework::set_allocated_principals(::mesos::ACL_Entity* principals) {
  delete principals_;
  principals_ = principals;
  if (principals) {
    set_has_principals();
  } else {
    clear_has_principals();
  }
}

// required .mesos.ACL.Entity framework_principals = 2;
inline bool ACL_ShutdownFramework::has_framework_principals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ShutdownFramework::set_has_framework_principals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ShutdownFramework::clear_has_framework_principals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ShutdownFramework::clear_framework_principals() {
  if (framework_principals_ != NULL) framework_principals_->::mesos::ACL_Entity::Clear();
  clear_has_framework_principals();
}
inline const ::mesos::ACL_Entity& ACL_ShutdownFramework::framework_principals() const {
  return framework_principals_ != NULL ? *framework_principals_ : *default_instance_->framework_principals_;
}
inline ::mesos::ACL_Entity* ACL_ShutdownFramework::mutable_framework_principals() {
  set_has_framework_principals();
  if (framework_principals_ == NULL) framework_principals_ = new ::mesos::ACL_Entity;
  return framework_principals_;
}
inline ::mesos::ACL_Entity* ACL_ShutdownFramework::release_framework_principals() {
  clear_has_framework_principals();
  ::mesos::ACL_Entity* temp = framework_principals_;
  framework_principals_ = NULL;
  return temp;
}
inline void ACL_ShutdownFramework::set_allocated_framework_principals(::mesos::ACL_Entity* framework_principals) {
  delete framework_principals_;
  framework_principals_ = framework_principals;
  if (framework_principals) {
    set_has_framework_principals();
  } else {
    clear_has_framework_principals();
  }
}

// -------------------------------------------------------------------

// ACL

// -------------------------------------------------------------------

// ACLs

// optional bool permissive = 1 [default = true];
inline bool ACLs::has_permissive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACLs::set_has_permissive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACLs::clear_has_permissive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACLs::clear_permissive() {
  permissive_ = true;
  clear_has_permissive();
}
inline bool ACLs::permissive() const {
  return permissive_;
}
inline void ACLs::set_permissive(bool value) {
  set_has_permissive();
  permissive_ = value;
}

// repeated .mesos.ACL.RegisterFramework register_frameworks = 2;
inline int ACLs::register_frameworks_size() const {
  return register_frameworks_.size();
}
inline void ACLs::clear_register_frameworks() {
  register_frameworks_.Clear();
}
inline const ::mesos::ACL_RegisterFramework& ACLs::register_frameworks(int index) const {
  return register_frameworks_.Get(index);
}
inline ::mesos::ACL_RegisterFramework* ACLs::mutable_register_frameworks(int index) {
  return register_frameworks_.Mutable(index);
}
inline ::mesos::ACL_RegisterFramework* ACLs::add_register_frameworks() {
  return register_frameworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >&
ACLs::register_frameworks() const {
  return register_frameworks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >*
ACLs::mutable_register_frameworks() {
  return &register_frameworks_;
}

// repeated .mesos.ACL.RunTask run_tasks = 3;
inline int ACLs::run_tasks_size() const {
  return run_tasks_.size();
}
inline void ACLs::clear_run_tasks() {
  run_tasks_.Clear();
}
inline const ::mesos::ACL_RunTask& ACLs::run_tasks(int index) const {
  return run_tasks_.Get(index);
}
inline ::mesos::ACL_RunTask* ACLs::mutable_run_tasks(int index) {
  return run_tasks_.Mutable(index);
}
inline ::mesos::ACL_RunTask* ACLs::add_run_tasks() {
  return run_tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >&
ACLs::run_tasks() const {
  return run_tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >*
ACLs::mutable_run_tasks() {
  return &run_tasks_;
}

// repeated .mesos.ACL.ShutdownFramework shutdown_frameworks = 4;
inline int ACLs::shutdown_frameworks_size() const {
  return shutdown_frameworks_.size();
}
inline void ACLs::clear_shutdown_frameworks() {
  shutdown_frameworks_.Clear();
}
inline const ::mesos::ACL_ShutdownFramework& ACLs::shutdown_frameworks(int index) const {
  return shutdown_frameworks_.Get(index);
}
inline ::mesos::ACL_ShutdownFramework* ACLs::mutable_shutdown_frameworks(int index) {
  return shutdown_frameworks_.Mutable(index);
}
inline ::mesos::ACL_ShutdownFramework* ACLs::add_shutdown_frameworks() {
  return shutdown_frameworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework >&
ACLs::shutdown_frameworks() const {
  return shutdown_frameworks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework >*
ACLs::mutable_shutdown_frameworks() {
  return &shutdown_frameworks_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ACL_Entity_Type>() {
  return ::mesos::ACL_Entity_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fauthorizer_2fauthorizer_2eproto__INCLUDED
